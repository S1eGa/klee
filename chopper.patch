diff --git a/.gitignore b/.gitignore
index 60f7185..cdbe809 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,6 +3,7 @@ Release+Asserts/
 Debug/
 Debug+Asserts/
 Output/
+klee_build/
 
 cscope.*
 *~
@@ -11,6 +12,9 @@ cscope.*
 *.sum
 *.out
 *.status
+*.swp
+*.swo
+*.orig
 
 # In source build files
 docs/doxygen.cfg
diff --git a/.travis/klee.sh b/.travis/klee.sh
index 61806df..cdce334 100755
--- a/.travis/klee.sh
+++ b/.travis/klee.sh
@@ -10,8 +10,8 @@ SVN_BRANCH="release_$( echo ${LLVM_VERSION} | sed 's/\.//g')"
 # Select the compiler to use to generate LLVM bitcode
 ###############################################################################
 if [ "${LLVM_VERSION}" != "2.9" ]; then
-    KLEE_CC=/usr/bin/clang-${LLVM_VERSION}
-    KLEE_CXX=/usr/bin/clang++-${LLVM_VERSION}
+    KLEE_CC=clang-${LLVM_VERSION}
+    KLEE_CXX=clang++-${LLVM_VERSION}
 else
     # Just use pre-built llvm-gcc downloaded earlier
     KLEE_CC=${BUILD_DIR}/llvm-gcc/bin/llvm-gcc
@@ -32,7 +32,7 @@ fi
 if [ "${KLEE_UCLIBC}" != "0" ]; then
     git clone --depth 1 -b ${KLEE_UCLIBC} git://github.com/klee/klee-uclibc.git
     cd klee-uclibc
-    ./configure --make-llvm-lib --with-cc "${KLEE_CC}" --with-llvm-config /usr/bin/llvm-config-${LLVM_VERSION}
+    ./configure --make-llvm-lib --with-cc "${KLEE_CC}" --with-llvm-config /usr/local/bin/llvm-config
     make
     if [ "X${USE_CMAKE}" == "X1" ]; then
       KLEE_UCLIBC_CONFIGURE_OPTION="-DENABLE_KLEE_UCLIBC=TRUE -DKLEE_UCLIBC_PATH=$(pwd) -DENABLE_POSIX_RUNTIME=TRUE"
@@ -136,10 +136,10 @@ if [ "X${USE_CMAKE}" == "X1" ]; then
     CMAKE_BUILD_TYPE="Debug"
   fi
   # Compute CMake build type
-  CXXFLAGS="${COVERAGE_FLAGS} ${SANITIZER_CXX_FLAGS}" \
+  CXXFLAGS="${COVERAGE_FLAGS} ${SANITIZER_CXX_FLAGS} -fno-rtti" \
   CFLAGS="${COVERAGE_FLAGS} ${SANITIZER_C_FLAGS}" \
   cmake \
-    -DLLVM_CONFIG_BINARY="/usr/lib/llvm-${LLVM_VERSION}/bin/llvm-config" \
+    -DLLVM_CONFIG_BINARY="/usr/local/lib/bin/llvm-config" \
     -DLLVMCC="${KLEE_CC}" \
     -DLLVMCXX="${KLEE_CXX}" \
     ${KLEE_STP_CONFIGURE_OPTION} \
@@ -147,13 +147,17 @@ if [ "X${USE_CMAKE}" == "X1" ]; then
     ${KLEE_METASMT_CONFIGURE_OPTION} \
     ${KLEE_UCLIBC_CONFIGURE_OPTION} \
     ${TCMALLOC_OPTION} \
-    -DGTEST_SRC_DIR=${GTEST_SRC_DIR} \
+    -DENABLE_UNIT_TESTS=OFF \
     -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} \
     ${KLEE_ASSERTS_OPTION} \
     -DENABLE_UNIT_TESTS=TRUE \
     -DENABLE_SYSTEM_TESTS=TRUE \
     -DLIT_ARGS="-v" \
+    -DSVF_ROOT_DIR=/home/klee/SVF \
+    -DDG_ROOT_DIR=/home/klee/dg \
+    -DSLICING_ROOT_DIR=/home/klee/se-slicing \
     ${KLEE_SRC}
+  export LD_LIBRARY_PATH=${BUILD_DIR}/build-svf/lib:${BUILD_DIR}/build-svf/lib/CUDD:${BUILD_DIR}/build-dg/src
   make
 else
   # Build KLEE
@@ -234,14 +238,14 @@ if [ ${COVERAGE} -eq 1 ]; then
     cd zcov
 
 #these files are not where zcov expects them to be after install so we move them
-    sudo cp js/sorttable.js /usr/local/lib/python2.7/dist-packages/zcov-0.3.0.dev0-py2.7.egg/zcov/js/sorttable.js 
-    sudo cp js/sourceview.js /usr/local/lib/python2.7/dist-packages/zcov-0.3.0.dev0-py2.7.egg/zcov/js/sourceview.js 
+    sudo cp js/sorttable.js /usr/local/lib/python2.7/dist-packages/zcov-0.3.0.dev0-py2.7.egg/zcov/js/sorttable.js
+    sudo cp js/sourceview.js /usr/local/lib/python2.7/dist-packages/zcov-0.3.0.dev0-py2.7.egg/zcov/js/sourceview.js
     sudo cp style.css /usr/local/lib/python2.7/dist-packages/zcov-0.3.0.dev0-py2.7.egg/zcov/style.css
 
 #install zcov dependency
     sudo apt-get install -y enscript
 
-#update gcov from v4.6 to v4.8. This is becauase gcda files are made for v4.8 and cause 
+#update gcov from v4.6 to v4.8. This is becauase gcda files are made for v4.8 and cause
 #a segmentation fault in v4.6
     sudo apt-get install -y ggcov
     sudo rm /usr/bin/gcov
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 97c51a2..a0b64f8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -25,6 +25,8 @@ if (POLICY CMP0054)
   cmake_policy(SET CMP0054 OLD)
 endif()
 
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+
 if (POLICY CMP0042)
   # Enable `MACOSX_RPATH` by default.
   cmake_policy(SET CMP0042 NEW)
@@ -243,6 +245,12 @@ if (NOT EXISTS "${LLVM_AS}")
   message(FATAL_ERROR "Failed to find llvm-as at \"${LLVM_AS}\"")
 endif()
 
+# Find opt (LLVM)
+set(LLVM_OPT "${LLVM_TOOLS_BINARY_DIR}/opt")
+if (NOT EXISTS "${LLVM_OPT}")
+  message(FATAL_ERROR "Failed to find opt at \"${LLVM_OPT}\"")
+endif()
+
 ################################################################################
 # Find bitcode compiler
 ################################################################################
@@ -274,8 +282,10 @@ if (USE_CXX11)
 else()
   # This is needed because with GCC 6 the default changed from gnu++98 to
   # gnu++14.
-  add_global_cxx_flag("-std=gnu++98" REQUIRED)
+  add_global_cxx_flag("-std=gnu++11" REQUIRED)
 endif()
+# specific flags for DG
+add_global_cxx_flag("-DHAVE_LLVM -DENABLE_CFG")
 
 ################################################################################
 # Warnings
@@ -398,6 +408,11 @@ if (NOT LLVM_ENABLE_RTTI)
   endif()
 endif()
 
+################################################################################
+# Remove some spammy warnings
+################################################################################
+klee_component_add_cxx_flag("-Wno-misleading-indentation")
+
 ################################################################################
 # Support for compressed logs
 ################################################################################
@@ -619,6 +634,24 @@ else()
   set(SUPPORT_KLEE_UCLIBC 0) # For config.h
 endif()
 

 ################################################################################
 # Generate `config.h`
 ################################################################################
diff --git a/README.md b/README.md
index 6d36bc7..9a483e9 100644
--- a/README.md
+++ b/README.md
@@ -1,27 +1,121 @@
-KLEE Symbolic Virtual Machine
+KLEE/CSE Project
 =============================
+An extension of KLEE (http://klee.github.io).
 
-[![Build Status](https://travis-ci.org/klee/klee.svg?branch=master)](https://travis-ci.org/klee/klee)
+## Build
+Build LLVM (3.4)
+```
+mkdir build
+cd build
+cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON <LLVM_SRC>
+make
+```
+Build SVF (Pointer Analysis)
+* https://github.com/davidtr1037/SVF/tree/master
 
-`KLEE` is a symbolic virtual machine built on top of the LLVM compiler
-infrastructure. Currently, there are two primary components:
+Build DG (Static Slicing)
+* https://github.com/davidtr1037/dg/tree/master
 
-  1. The core symbolic virtual machine engine; this is responsible for
-     executing LLVM bitcode modules with support for symbolic
-     values. This is comprised of the code in lib/.
+Build Chopper:
+```
+git checkout master
+mkdir klee_build
+cd klee_build
+CXXFLAGS="-fno-rtti" cmake \
+    -DENABLE_SOLVER_STP=ON \
+    -DENABLE_POSIX_RUNTIME=ON \
+    -DENABLE_KLEE_UCLIBC=ON \
+    -DKLEE_UCLIBC_PATH=<KLEE_UCLIBC_DIR> \
+    -DLLVM_CONFIG_BINARY=<LLVM_CONFIG_PATH> \
+    -DENABLE_UNIT_TESTS=OFF \
+    -DKLEE_RUNTIME_BUILD_TYPE=Release+Asserts \
+    -DENABLE_SYSTEM_TESTS=ON \
+    -DSVF_ROOT_DIR=<SVF_PROJECT_DIR> \
+    -DDG_ROOT_DIR=<DG_PROJECT_DIR> \
+    <KLEE_ROOT_DIR>
+make
+```
 
-  2. A POSIX/Linux emulation layer oriented towards supporting uClibc,
-     with additional support for making parts of the operating system
-     environment symbolic.
+Notes:
+* Use llvm-config from the CMake build (LLVM 3.4)
+* Use klee-uclibc from [here](https://github.com/davidtr1037/klee-uclibc)
 
-Additionally, there is a simple library for replaying computed inputs
-on native code (for closed programs). There is also a more complicated
-infrastructure for replaying the inputs generated for the POSIX/Linux
-emulation layer, which handles running native programs in an
-environment that matches a computed test input, including setting up
-files, pipes, environment variables, and passing command line
-arguments.
+## Usage Example
+Let's look at the following program:
+```C
+#include <stdio.h>
 
-Coverage information can be found [here](http://vm-klee.doc.ic.ac.uk:55555/index.html).
+#include <klee/klee.h>
 
-For further information, see the [webpage](http://klee.github.io/).
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *o) {
+    o->x = 0;
+    o->y = 0;
+}
+
+int main(int argc, char *argv[]) {
+    object_t o;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o);
+    if (k > 0) {
+        printf("%d\n", o.x);
+    } else {
+        printf("%d\n", o.y);
+    }
+
+    return 0;
+}
+```
+
+Compile the program:
+```
+clang -c -g -emit-llvm main.c -o main.bc
+opt -mem2reg main.bc -o main.bc (required for better pointer analysis)
+```
+
+Run KLEE (static analysis related debug messages are written to stdout):
+```
+klee -libc=klee -search=dfs -skip-functions=f main.bc
+```
+
+## Options
+### Skipping Functions
+The skipped functions are set using the following option:
+```
+-skip-functions=<function1>[:line1/line2/...],<function2>[:line1/line2/...],...
+```
+### Inlining
+In some cases, inlining can improve the precision of static analysis.
+Functions can be inlined using the following option:
+```
+-inline=<function1>,<function2>,...
+```
+### Search Heuristic
+The chopping-aware search heuristic can be used using the following option:
+```
+-split-search
+```
+and the ratio can be set by:
+```
+-split-ratio=<uint> // ratio for choosing recovery states (default = 20)
+```
+### Slicing
+Slicing for skipped functions can be disabled using the following option:
+```
+-use-slicer=0
+```
+### Debugging
+More verbose debug messages can be produced using the following option:
+```
+-debug-only=basic
+```
+
+## Notes:
+* When using klee-libc, some files (memcpy.c, memset.c) should be recompiled with `-O1` to avoid vector instructions.
diff --git a/cmake/find_bitcode_compiler.cmake b/cmake/find_bitcode_compiler.cmake
index 615931f..0db56e2 100644
--- a/cmake/find_bitcode_compiler.cmake
+++ b/cmake/find_bitcode_compiler.cmake
@@ -15,24 +15,24 @@
 
 message(STATUS "Looking for bitcode compilers")
 
-find_program(
-  LLVMCC
-  NAMES "clang-${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}" "clang" "llvm-gcc"
-   # Give the LLVM tools directory higher priority than the system directory.
-  HINTS "${LLVM_TOOLS_BINARY_DIR}"
-)
+# find_program(
+#   LLVMCC
+#   NAMES "clang-${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}" "clang" "llvm-gcc"
+#    # Give the LLVM tools directory higher priority than the system directory.
+#   HINTS "${LLVM_TOOLS_BINARY_DIR}"
+# )
 if (LLVMCC)
   message(STATUS "Found ${LLVMCC}")
 else()
   message(FATAL_ERROR "Failed to find C bitcode compiler")
 endif()
 
-find_program(
-  LLVMCXX
-  NAMES "clang++-${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}" "clang++" "llvm-g++"
-   # Give the LLVM tools directory higher priority than the system directory.
-  HINTS "${LLVM_TOOLS_BINARY_DIR}"
-)
+# find_program(
+#   LLVMCXX
+#   NAMES "clang++-${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}" "clang++" "llvm-g++"
+#    # Give the LLVM tools directory higher priority than the system directory.
+#   HINTS "${LLVM_TOOLS_BINARY_DIR}"
+# )
 if (LLVMCXX)
   message(STATUS "Found ${LLVMCXX}")
 else()
diff --git a/cmake/find_llvm.cmake b/cmake/find_llvm.cmake
index 0df6b4b..82967df 100644
--- a/cmake/find_llvm.cmake
+++ b/cmake/find_llvm.cmake
@@ -86,7 +86,7 @@ else()
       "${LLVM_PACKAGE_VERSION}")
   else()
     # try x.y pattern
-    set(_llvm_version_regex "^([0-9]+)\\.([0-9]+)$")
+    set(_llvm_version_regex "^([0-9]+)\\.([0-9]+)(svn)$")
     if ("${LLVM_PACKAGE_VERSION}" MATCHES "${_llvm_version_regex}")
       string(REGEX REPLACE
         "${_llvm_version_regex}"
diff --git a/include/klee/ASContext.h b/include/klee/ASContext.h
new file mode 100644
index 0000000..684c210
--- /dev/null
+++ b/include/klee/ASContext.h
@@ -0,0 +1,42 @@
+#ifndef KLEE_ASCONTEXT_H
+#define KLEE_ASCONTEXT_H
+
+#include "llvm/IR/Instruction.h"
+
+#include "klee/Internal/Analysis/Cloner.h"
+
+#include <vector>
+
+namespace klee {
+
+class ExecutionState;
+
+class ASContext {
+public:
+
+    ASContext() : refCount(0) {
+
+    }
+
+    ASContext(Cloner *cloner, std::vector<llvm::Instruction *> &callTrace, llvm::Instruction *inst);
+    
+    ASContext(ASContext &other);
+
+    bool operator==(ASContext &other);
+
+    bool operator!=(ASContext &other);
+
+    void dump();
+
+    unsigned int refCount;
+
+private:
+
+    llvm::Instruction *getTranslatedInst(Cloner *cloner, llvm::Instruction *inst);
+
+    std::vector<llvm::Instruction *> trace;
+};
+
+}
+
+#endif
diff --git a/include/klee/AllocationRecord.h b/include/klee/AllocationRecord.h
new file mode 100644
index 0000000..cfe8ad8
--- /dev/null
+++ b/include/klee/AllocationRecord.h
@@ -0,0 +1,50 @@
+#ifndef KLEE_ALLOCATION_RECORD_H
+#define KLEE_ALLOCATION_RECORD_H
+
+#include "klee/ASContext.h"
+
+#include <list>
+
+namespace klee {
+
+class MemoryObject;
+
+class AllocationRecord {
+public:
+
+    AllocationRecord() {
+
+    }
+
+    AllocationRecord(const AllocationRecord &other);
+
+    AllocationRecord &operator=(const AllocationRecord &other);
+
+    ~AllocationRecord();
+
+    void addAddr(ASContext &context, MemoryObject *mo);
+    
+    MemoryObject *getAddr(ASContext &context);
+
+    bool exists(ASContext &context);
+
+    void dump();
+
+private:
+    /*  TODO: change ref<ASContext> to ASContext? */
+    typedef std::list<MemoryObject *> MemoryObjectList;
+    typedef std::pair<ref<ASContext>, MemoryObjectList> Entry;
+    typedef std::vector<Entry> Record;
+
+    void incRefCount();
+
+    void decRefCount();
+
+    Entry *find(ASContext &context);
+
+    Record record;
+};
+
+}
+
+#endif
diff --git a/include/klee/ExecutionState.h b/include/klee/ExecutionState.h
index 32f840f..c6ba165 100644
--- a/include/klee/ExecutionState.h
+++ b/include/klee/ExecutionState.h
@@ -10,13 +10,18 @@
 #ifndef KLEE_EXECUTIONSTATE_H
 #define KLEE_EXECUTIONSTATE_H
 
+#include <llvm/IR/Instruction.h>
+
 #include "klee/Constraints.h"
 #include "klee/Expr.h"
+#include "klee/AllocationRecord.h"
 #include "klee/Internal/ADT/TreeStream.h"
+#include "klee/Internal/Support/ErrorHandling.h"
 
 // FIXME: We do not want to be exposing these? :(
 #include "../../lib/Core/AddressSpace.h"
 #include "klee/Internal/Module/KInstIterator.h"
+#include "klee/Internal/Module/KModule.h"
 
 #include <map>
 #include <set>
@@ -61,10 +66,85 @@ struct StackFrame {
   ~StackFrame();
 };
 

+
+struct WrittenAddressInfo {
+  size_t maxSize;
+    unsigned int snapshotIndex;
+};
+
+/* recovery state result information */
+struct RecoveryResult {
+    /* did the recovery state wrote to the blocking load address */
+    bool modified;
+};
+
+enum {
+    PRIORITY_LOW,
+    PRIORITY_HIGH,
+};
+
 /// @brief ExecutionState representing a path under exploration
 class ExecutionState {
 public:
   typedef std::vector<StackFrame> stack_ty;
+  /* the reference count is used only for snapshot states */
+  unsigned int refCount;
 
 private:
   // unsupported, use copy constructor
@@ -72,6 +152,52 @@ private:
 
   std::map<std::string, std::string> fnAliases;
 
+  unsigned int type;
+
+  /* normal state properties */
+
+  typedef std::map<uint64_t, WrittenAddressInfo> WrittenAddresses;
+  typedef std::map<uint64_t, ref<Expr> > ValuesCache;
+  typedef std::map< std::pair<uint32_t, uint32_t>, ValuesCache> RecoveryCache;
+
+  /* a normal state has a suspend status */
+  bool suspendStatus;
+  /* history of taken snapshots, which are uses to create recovery states */
+  std::vector< ref<Snapshot> > snapshots;
+  /* a normal state has a unique recovery state */
+  ExecutionState *recoveryState;
+  /* TODO: rename/re-implement */
+  bool blockingLoadStatus;
+  /* resloved load addresses */
+  std::set<uint64_t> recoveredLoads;
+  /* we have to remember which allocations were executed */
+  AllocationRecord allocationRecord;
+  /* used for guiding multiple recovery states */
+  std::set< ref<Expr> > guidingConstraints;
+  /* we need to know if an address was written  */
+  WrittenAddresses writtenAddresses;
+  /* we use this to determine which recovery states must be run */
+  std::list< ref<RecoveryInfo> > pendingRecoveryInfos;
+  /* TODO: add docs */
+  RecoveryCache recoveryCache;
+
+  /* recovery state properties */
+
+  /* a recovery state must stop when reaching this instruction */
+  llvm::Instruction *exitInst;
+  /* a recovery state has its own dependent state */
+  ExecutionState *dependentState;
+  /* a reference to the originating state */
+  ExecutionState *originatingState;
+  /* TODO: should be ref<RecoveryInfo> */
+  ref<RecoveryInfo> recoveryInfo;
+  /* we use this record while executing a recovery state  */
+  AllocationRecord guidingAllocationRecord;
+  /* recursion level */
+  unsigned int level;
+  /* search priority */
+  int priority;
+
 public:
   // Execution - Control Flow specific
 
@@ -146,7 +272,7 @@ public:
   void removeFnAlias(std::string fn);
 
 private:
-  ExecutionState() : ptreeNode(0) {}
+  ExecutionState() : refCount(0), ptreeNode(0) {}
 
 public:
   ExecutionState(KFunction *kf);
@@ -165,11 +291,318 @@ public:
   void popFrame();
 
   void addSymbolic(const MemoryObject *mo, const Array *array);
-  void addConstraint(ref<Expr> e) { constraints.addConstraint(e); }
+  void addConstraint(ref<Expr> e) {
+    constraints.addConstraint(e);
+
+    if (isNormalState() && !isRecoveryState()) {
+      if (!getSnapshots().empty()) {
+        addGuidingConstraint(e);
+      }
+    }
+  }
 
   bool merge(const ExecutionState &b);
   void dumpStack(llvm::raw_ostream &out) const;
+
+  void setType(int type) {
+    this->type = type;
+  }
+
+  bool isNormalState() {
+    return (type & NORMAL_STATE) != 0;
+  }
+
+  bool isRecoveryState() {
+    return (type & RECOVERY_STATE) != 0;
+  }
+
+  bool isSuspended() {
+    return suspendStatus;
+  }
+
+  bool isResumed() {
+    return !isSuspended();
+  }
+
+  void setSuspended() {
+    assert(isNormalState());
+    suspendStatus = true;
+  }
+
+  void setResumed() {
+    assert(isNormalState());
+    suspendStatus = false;
+  }
+
+  std::vector< ref<Snapshot> > &getSnapshots() {
+    assert(isNormalState());
+    return snapshots;
+  }
+
+  void addSnapshot(ref<Snapshot> snapshot) {
+    assert(isNormalState());
+    snapshots.push_back(snapshot);
+  }
+
+  unsigned int getCurrentSnapshotIndex() {
+    assert(isNormalState());
+    assert(!snapshots.empty());
+    return snapshots.size() - 1;
+  }
+
+  ExecutionState *getRecoveryState() {
+    assert(isNormalState());
+    return recoveryState;
+  }
+
+  void setRecoveryState(ExecutionState *state) {
+    assert(isNormalState());
+    if (state) {
+      assert(state->isRecoveryState());
+    }
+    recoveryState = state;
+  }
+
+  /* TODO: rename/re-implement */
+  bool isBlockingLoadRecovered() {
+    assert(isNormalState());
+    return blockingLoadStatus;
+  }
+
+  /* TODO: rename/re-implement */
+  void markLoadAsUnrecovered() {
+    assert(isNormalState());
+    blockingLoadStatus = false;
+  }
+
+  /* TODO: rename/re-implement */
+  void markLoadAsRecovered() {
+    assert(isNormalState());
+    blockingLoadStatus = true;
+  }
+
+  std::set<uint64_t> &getRecoveredLoads() {
+    assert(isNormalState());
+    return recoveredLoads;
+  }
+
+  void addRecoveredAddress(uint64_t address) {
+    assert(isNormalState());
+    recoveredLoads.insert(address);
+  }
+
+  bool isAddressRecovered(uint64_t address) {
+    assert(isNormalState());
+    return recoveredLoads.find(address) != recoveredLoads.end();
+  }
+
+  void clearRecoveredAddresses() {
+    assert(isNormalState());
+    recoveredLoads.clear();
+  }
+
+  llvm::Instruction *getExitInst() {
+    assert(isRecoveryState());
+    return exitInst;
+  }
+
+  void setExitInst(llvm::Instruction *exitInst) {
+    assert(isRecoveryState());
+    this->exitInst = exitInst;
+  }
+
+  ExecutionState *getDependentState() {
+    assert(isRecoveryState());
+    return dependentState;
+  }
+
+  void setDependentState(ExecutionState *state) {
+    assert(isRecoveryState());
+    assert(state->isNormalState());
+    dependentState = state;
+  }
+
+  ExecutionState *getOriginatingState() {
+    assert(isRecoveryState());
+    return originatingState;
+  }
+
+  void setOriginatingState(ExecutionState *state) {
+    assert(isRecoveryState());
+    assert(state->isNormalState());
+    originatingState = state;
+  }
+
+  ref<RecoveryInfo> getRecoveryInfo() {
+    assert(isRecoveryState());
+    return recoveryInfo;
+  }
+
+  void setRecoveryInfo(ref<RecoveryInfo> recoveryInfo) {
+    assert(isRecoveryState());
+    this->recoveryInfo = recoveryInfo;
+  }
+
+  void getCallTrace(std::vector<llvm::Instruction *> &callTrace);
+
+  AllocationRecord &getAllocationRecord() {
+    assert(isNormalState());
+    return allocationRecord;
+  }
+
+  void setAllocationRecord(AllocationRecord &record) {
+    assert(isNormalState());
+    allocationRecord = record;
+  }
+
+  AllocationRecord &getGuidingAllocationRecord() {
+    assert(isRecoveryState());
+    return guidingAllocationRecord;
+  }
+
+  void setGuidingAllocationRecord(AllocationRecord &record) {
+    assert(isRecoveryState());
+    guidingAllocationRecord = record;
+  }
+
+  std::set <ref<Expr> > &getGuidingConstraints() {
+    assert(isNormalState());
+    return guidingConstraints;
+  }
+
+  void setGuidingConstraints(std::set< ref<Expr> > &constraints) {
+    assert(isNormalState());
+    guidingConstraints = constraints;
+  }
+
+  void addGuidingConstraint(ref<Expr> condition) {
+    assert(isNormalState());
+    guidingConstraints.insert(condition);
+  }
+
+  void clearGuidingConstraints() {
+    assert(isNormalState());
+    guidingConstraints.clear();
+  }
+
+  void addWrittenAddress(uint64_t address, size_t size, unsigned int snapshotIndex) {
+    assert(isNormalState());
+    WrittenAddressInfo &info = writtenAddresses[address];
+    if (size > info.maxSize) {
+      info.maxSize = size;
+    }
+    info.snapshotIndex = snapshotIndex;
+  }
+
+  bool getWrittenAddressInfo(uint64_t address, size_t loadSize,
+                             WrittenAddressInfo &info) {
+    assert(isNormalState());
+    WrittenAddresses::iterator i = writtenAddresses.find(address);
+    if (i == writtenAddresses.end()) {
+      return false;
+    }
+
+    info = i->second;
+
+    // we have a complete overwrite iff we write at least loadSize bits
+    size_t writtenSize = i->second.maxSize;
+    return writtenSize >= loadSize;
+  }
+
+  unsigned int getStartingIndex(uint64_t address, size_t size) {
+    WrittenAddressInfo info;
+    if (!getWrittenAddressInfo(address, size, info)) {
+      /* there was no overwrite... */
+      return 0;
+    }
+
+    return info.snapshotIndex + 1;
+  }
+
+  bool isInDependentMode() {
+    assert(isNormalState());
+    /* TODO: add doc... */
+    return !getSnapshots().empty();
+  }
+
+  std::list< ref<RecoveryInfo> > &getPendingRecoveryInfos() {
+    return pendingRecoveryInfos;
+  }
+
+  ref<RecoveryInfo> getPendingRecoveryInfo() {
+    ref<RecoveryInfo> ri = pendingRecoveryInfos.front();
+    pendingRecoveryInfos.pop_front();
+    return ri;
+  }
+
+  bool hasPendingRecoveryInfo() {
+    return !pendingRecoveryInfos.empty();
+  }
+
+  RecoveryCache &getRecoveryCache() {
+    assert(isNormalState());
+    return recoveryCache;
+  }
+
+  void setRecoveryCache(RecoveryCache &cache) {
+    assert(isNormalState());
+    recoveryCache = cache;
+  }
+
+  void updateRecoveredValue(
+    unsigned int index,
+    unsigned int sliceId,
+    uint64_t address,
+    ref<Expr> expr
+  ) {
+    auto key = std::make_pair(index, sliceId);
+    ValuesCache &valuesCache = recoveryCache[key];
+    valuesCache[address] = expr;
+  };
+
+  bool getRecoveredValue(
+    unsigned int index,
+    unsigned int sliceId,
+    uint64_t address,
+    ref<Expr> &expr
+  ) {
+    auto key = std::make_pair(index, sliceId);
+    RecoveryCache::iterator i = recoveryCache.find(key);
+    if (i == recoveryCache.end()) {
+      return false;
+    }
+
+    ValuesCache &valuesCache = i->second;
+    ValuesCache::iterator j = valuesCache.find(address);
+    if (j == valuesCache.end()) {
+      return false;
+    }
+
+    expr = j->second;
+    return true;
+  };
+
+  unsigned int getLevel() {
+    assert(isRecoveryState());
+    return level;
+  }
+
+  void setLevel(unsigned int level) {
+    this->level = level;
+  }
+
+  int getPriority() {
+    assert(isRecoveryState());
+    return priority;
+  }
+
+  void setPriority(int priority) {
+    assert(isRecoveryState());
+    this->priority = priority;
+  }
+
 };
+
 }
 
 #endif
diff --git a/include/klee/Internal/Analysis/AAPass.h b/include/klee/Internal/Analysis/AAPass.h
new file mode 100644
index 0000000..8e9417d
--- /dev/null
+++ b/include/klee/Internal/Analysis/AAPass.h
@@ -0,0 +1,57 @@
+#ifndef AAPASS_H
+#define AAPASS_H
+
+#include "MemoryModel/PointerAnalysis.h"
+#include <llvm/Analysis/AliasAnalysis.h>
+#include <llvm/Pass.h>
+
+class AAPass : public llvm::ModulePass, public llvm::AliasAnalysis {
+
+public:
+  static char ID;
+
+  enum AliasCheckRule {
+    Conservative, ///< return MayAlias if any pta says alias
+    Veto,         ///< return NoAlias if any pta says no alias
+    Precise       ///< return alias result by the most precise pta
+  };
+
+  AAPass()
+      : llvm::ModulePass(ID), llvm::AliasAnalysis(),
+        type(PointerAnalysis::Default_PTA), _pta(0) {}
+
+  ~AAPass();
+
+  virtual inline void getAnalysisUsage(llvm::AnalysisUsage &au) const {
+    au.setPreservesAll();
+  }
+
+  virtual inline void *getAdjustedAnalysisPointer(llvm::AnalysisID id) {
+    return this;
+  }
+
+  virtual inline llvm::AliasAnalysis::AliasResult
+  alias(const llvm::AliasAnalysis::Location &LocA,
+        const llvm::AliasAnalysis::Location &LocB) {
+    return alias(LocA.Ptr, LocB.Ptr);
+  }
+
+  virtual llvm::AliasAnalysis::AliasResult alias(const llvm::Value *V1,
+                                                 const llvm::Value *V2);
+
+  virtual bool runOnModule(llvm::Module &module);
+
+  virtual inline const char *getPassName() const { return "AAPass"; }
+
+  void setPAType(PointerAnalysis::PTATY type) { this->type = type; }
+
+  BVDataPTAImpl *getPTA() { return _pta; }
+
+private:
+  void runPointerAnalysis(llvm::Module &module, u32_t kind);
+
+  PointerAnalysis::PTATY type;
+  BVDataPTAImpl *_pta;
+};
+
+#endif /* AAPASS_H */
diff --git a/include/klee/Internal/Analysis/Annotator.h b/include/klee/Internal/Analysis/Annotator.h
new file mode 100644
index 0000000..4ca506f
--- /dev/null
+++ b/include/klee/Internal/Analysis/Annotator.h
@@ -0,0 +1,48 @@
+#ifndef ANNOTATOR_H
+#define ANNOTATOR_H
+
+#include <stdbool.h>
+#include <iostream>
+#include <map>
+#include <set>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instruction.h>
+
+#include "ModRefAnalysis.h"
+
+class Annotator {
+public:
+  struct AnnotationInfo {
+    uint32_t subId;
+    std::set<std::string> fnames;
+
+    AnnotationInfo() : subId(0) {}
+  };
+
+  typedef std::map<uint32_t, AnnotationInfo> AnnotationsMap;
+
+  Annotator(llvm::Module *module, ModRefAnalysis *mra)
+      : module(module), mra(mra), argId(0) {}
+
+  void annotate();
+
+  std::set<std::string> &getAnnotatedNames(uint32_t sliceId);
+
+private:
+  void annotateStores(std::set<llvm::Instruction *> &stores, uint32_t sliceId);
+
+  void annotateStore(llvm::Instruction *inst, uint32_t sliceId);
+
+  static std::string getAnnotatedName(uint32_t sliceId, uint32_t subId);
+
+  llvm::Function *getCriterionFunction(llvm::Value *pointer, uint32_t sliceId);
+
+  llvm::Module *module;
+  ModRefAnalysis *mra;
+  AnnotationsMap annotationsMap;
+  uint32_t argId;
+};
+
+#endif
diff --git a/include/klee/Internal/Analysis/Cloner.h b/include/klee/Internal/Analysis/Cloner.h
new file mode 100644
index 0000000..c2b50b9
--- /dev/null
+++ b/include/klee/Internal/Analysis/Cloner.h
@@ -0,0 +1,60 @@
+#ifndef CLONER_H
+#define CLONER_H
+
+#include <stdbool.h>
+#include <iostream>
+#include <set>
+#include <map>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/Transforms/Utils/ValueMapper.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "ReachabilityAnalysis.h"
+
+class Cloner {
+public:
+
+  struct SliceInfo {
+    /* the cloned/sliced function */
+    llvm::Function *f;
+    /* we have to know if it was already sliced */
+    bool isSliced;
+    /* translates an original value to a cloned one */
+    llvm::ValueToValueMapTy *v2vmap;
+  };
+
+  typedef std::map<llvm::Value *, llvm::Value *> ValueTranslationMap;
+  typedef std::map<uint32_t, SliceInfo> SliceMap;
+  typedef std::map<llvm::Function *, SliceMap> FunctionMap;
+  typedef std::map<llvm::Function *, ValueTranslationMap *> CloneInfoMap;
+  typedef std::set<llvm::Function *> FunctionSet;
+  typedef std::map<llvm::Function *, FunctionSet> ReachabilityMap;
+
+  Cloner(llvm::Module *module, ReachabilityAnalysis *ra,
+         llvm::raw_ostream &debugs);
+
+  ~Cloner();
+
+  void clone(llvm::Function *f, uint32_t sliceId);
+
+  SliceMap *getSlices(llvm::Function *function);
+
+  SliceInfo *getSliceInfo(llvm::Function *function, uint32_t sliceId);
+
+  llvm::Value *translateValue(llvm::Value *);
+
+private:
+  void cloneFunction(llvm::Function *f, uint32_t sliceId);
+
+  ValueTranslationMap *buildReversedMap(llvm::ValueToValueMapTy *vmap);
+
+  llvm::Module *module;
+  ReachabilityAnalysis *ra;
+  FunctionMap functionMap;
+  CloneInfoMap cloneInfoMap;
+  llvm::raw_ostream &debugs;
+};
+
+#endif
diff --git a/include/klee/Internal/Analysis/Inliner.h b/include/klee/Internal/Analysis/Inliner.h
new file mode 100644
index 0000000..653a989
--- /dev/null
+++ b/include/klee/Internal/Analysis/Inliner.h
@@ -0,0 +1,34 @@
+#ifndef INLINER_H
+#define INLINER_H
+
+#include <stdio.h>
+#include <vector>
+
+#include <llvm/IR/Module.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "ReachabilityAnalysis.h"
+
+class Inliner {
+public:
+  Inliner(llvm::Module *module, ReachabilityAnalysis *ra,
+          std::vector<std::string> targets, std::vector<std::string> functions,
+          llvm::raw_ostream &debugs)
+      : module(module), ra(ra), targets(targets), functions(functions),
+        debugs(debugs) {}
+
+  ~Inliner() {};
+
+  void run();
+
+private:
+  void inlineCalls(llvm::Function *f, std::vector<std::string> functions);
+
+  llvm::Module *module;
+  ReachabilityAnalysis *ra;
+  std::vector<std::string> targets;
+  std::vector<std::string> functions;
+  llvm::raw_ostream &debugs;
+};
+
+#endif /* INLINER_H */
diff --git a/include/klee/Internal/Analysis/ModRefAnalysis.h b/include/klee/Internal/Analysis/ModRefAnalysis.h
new file mode 100644
index 0000000..ce350fa
--- /dev/null
+++ b/include/klee/Internal/Analysis/ModRefAnalysis.h
@@ -0,0 +1,184 @@
+#ifndef MODREFANALYSIS_H
+#define MODREFANALYSIS_H
+
+#include <stdbool.h>
+#include <iostream>
+#include <set>
+#include <map>
+#include <vector>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/Analysis/AliasAnalysis.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "ReachabilityAnalysis.h"
+#include "AAPass.h"
+
+class ModRefAnalysis {
+public:
+  typedef std::set<llvm::Instruction *> InstructionSet;
+
+  typedef std::map<llvm::Function *, PointsTo> ModPtsMap;
+  typedef std::map<llvm::Function *, InstructionSet> ModSetMap;
+
+  typedef std::map<llvm::Function *, PointsTo> RefPtsMap;
+
+  typedef std::map<std::pair<llvm::Function *, NodeID>, InstructionSet>
+  ObjToStoreMap;
+  typedef std::map<std::pair<llvm::Function *, NodeID>, InstructionSet>
+  ObjToLoadMap;
+  typedef std::map<NodeID, InstructionSet> ObjToOverridingStoreMap;
+  typedef std::map<llvm::Instruction *, InstructionSet> LoadToStoreMap;
+
+  typedef std::pair<const llvm::Value *, uint64_t> AllocSite;
+  typedef std::pair<llvm::Function *, AllocSite> ModInfo;
+
+  typedef std::map<llvm::Instruction *, std::set<ModInfo> > LoadToModInfoMap;
+  typedef std::map<ModInfo, InstructionSet> ModInfoToStoreMap;
+  typedef std::map<ModInfo, uint32_t> ModInfoToIdMap;
+  typedef std::map<uint32_t, ModInfo> IdToModInfoMap;
+  typedef std::map<llvm::Function *, uint32_t> RetSliceIdMap;
+
+  typedef enum {
+    Modifier,
+    ReturnValue,
+  } SideEffectType;
+
+  typedef struct {
+    SideEffectType type;
+    uint32_t id;
+    union {
+      ModInfo modInfo;
+      llvm::Function *f;
+    } info;
+
+    llvm::Function *getFunction() {
+      if (type == Modifier) {
+        return info.modInfo.first;
+      }
+      if (type == ReturnValue) {
+        return info.f;
+      }
+      assert(false);
+    }
+
+  } SideEffect;
+
+  typedef std::vector<SideEffect> SideEffects;
+
+  ModRefAnalysis(llvm::Module *module, ReachabilityAnalysis *ra, AAPass *aa,
+                 std::string entry, std::vector<std::string> targets,
+                 llvm::raw_ostream &debugs);
+
+  llvm::Function *getEntry();
+
+  std::vector<llvm::Function *> getTargets();
+
+  void run();
+
+  ModInfoToStoreMap &getModInfoToStoreMap();
+
+  SideEffects &getSideEffects();
+
+  bool hasSideEffects(llvm::Function *f);
+
+  bool getSideEffects(llvm::Function *f, InstructionSet &modSet);
+
+  InstructionSet &getOverridingStores();
+
+  ModInfoToIdMap &getModInfoToIdMap();
+
+  bool mayBlock(llvm::Instruction *load);
+
+  bool mayOverride(llvm::Instruction *store);
+
+  bool getRetSliceId(llvm::Function *f, uint32_t &id);
+
+  void getApproximateModInfos(llvm::Instruction *inst, AllocSite hint,
+                              std::set<ModInfo> &result);
+
+  void dumpModSetMap();
+
+  void dumpDependentLoads();
+
+  void dumpLoadToModInfoMap();
+
+  void dumpModInfoToStoreMap();
+
+  void dumpModInfoToIdMap();
+
+  void dumpOverridingStores();
+
+  void dumpInst(llvm::Instruction *load, const char *prefix = "");
+
+  void dumpModInfo(const ModInfo &modInfo, const char *prefix = "");
+
+private:
+  typedef std::map<llvm::Function *, bool> ReachabilityCache;
+
+  /* priate methods */
+
+  void computeMod(llvm::Function *entry, llvm::Function *f);
+
+  void collectModInfo(llvm::Function *f);
+
+  void addStore(llvm::Function *f, llvm::Instruction *store);
+
+  bool canIgnoreStackObject(llvm::Function *f, const llvm::Value *value);
+
+  void collectRefInfo(llvm::Function *entry);
+
+  void addLoad(llvm::Function *f, llvm::Instruction *load);
+
+  void addOverridingStore(llvm::Instruction *store);
+
+  void computeModRefInfo();
+
+  void computeModInfoToStoreMap();
+
+  AllocSite getAllocSite(NodeID);
+
+  bool hasReturnValue(llvm::Function *f);
+
+  llvm::AliasAnalysis::Location getLoadLocation(llvm::LoadInst *inst);
+
+  llvm::AliasAnalysis::Location getStoreLocation(llvm::StoreInst *inst);
+
+  /* private members */
+
+  llvm::Module *module;
+  ReachabilityAnalysis *ra;
+  AAPass *aa;
+
+  std::string entry;
+  std::vector<std::string> targets;
+  llvm::Function *entryFunction;
+  std::vector<llvm::Function *> targetFunctions;
+
+  ModPtsMap modPtsMap;
+  ObjToStoreMap objToStoreMap;
+  RefPtsMap refPtsMap;
+  ObjToLoadMap objToLoadMap;
+  ObjToOverridingStoreMap objToOverridingStoreMap;
+
+  ModSetMap modSetMap;
+
+  InstructionSet dependentLoads;
+
+  LoadToModInfoMap loadToModInfoMap;
+  ModInfoToStoreMap modInfoToStoreMap;
+
+  ModInfoToIdMap modInfoToIdMap;
+  RetSliceIdMap retSliceIdMap;
+
+  SideEffects sideEffects;
+
+  InstructionSet overridingStores;
+
+  ReachabilityCache cache;
+
+  llvm::raw_ostream &debugs;
+};
+
+#endif
diff --git a/include/klee/Internal/Analysis/ReachabilityAnalysis.h b/include/klee/Internal/Analysis/ReachabilityAnalysis.h
new file mode 100644
index 0000000..8160c9d
--- /dev/null
+++ b/include/klee/Internal/Analysis/ReachabilityAnalysis.h
@@ -0,0 +1,87 @@
+#ifndef REACHABILITYANALYSIS_H
+#define REACHABILITYANALYSIS_H
+
+#include <stdio.h>
+#include <vector>
+#include <set>
+#include <map>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+
+#include "AAPass.h"
+
+class ReachabilityAnalysis {
+public:
+  typedef std::set<llvm::Function *> FunctionSet;
+  typedef std::set<llvm::Instruction *> InstructionSet;
+  typedef std::map<llvm::Function *, FunctionSet> ReachabilityMap;
+  typedef std::map<llvm::FunctionType *, FunctionSet> FunctionTypeMap;
+  typedef std::map<llvm::Instruction *, FunctionSet> CallMap;
+  typedef std::map<llvm::Function *, InstructionSet> RetMap;
+
+  ReachabilityAnalysis(llvm::Module *module, std::string entry,
+                       std::vector<std::string> targets,
+                       llvm::raw_ostream &debugs)
+      : module(module), entry(entry), targets(targets), entryFunction(NULL),
+        aa(NULL), debugs(debugs) {}
+
+  ~ReachabilityAnalysis() {};
+
+  /* must be called before making any reachability analysis */
+  void prepare();
+
+  void usePA(AAPass *aa) { this->aa = aa; }
+
+  bool run(bool usePA);
+
+  void computeReachableFunctions(llvm::Function *entry, bool usePA,
+                                 FunctionSet &results);
+
+  FunctionSet &getReachableFunctions(llvm::Function *f);
+
+  void getReachableInstructions(std::vector<llvm::CallInst *> &callSites,
+                                InstructionSet &result);
+
+  void getCallTargets(llvm::Instruction *inst, FunctionSet &result);
+
+  void dumpReachableFunctions();
+
+private:
+  void removeUnusedValues();
+
+  void computeFunctionTypeMap();
+
+  void updateReachabilityMap(llvm::Function *f, bool usePA);
+
+  bool isVirtual(llvm::Function *f);
+
+  void resolveCallTargets(llvm::CallInst *callInst, bool usePA,
+                          FunctionSet &targets);
+
+  void resolveIndirectCallByType(llvm::Type *calledType, FunctionSet &targets);
+
+  void resolveIndirectCallByPA(llvm::Value *calledValue, FunctionSet &targets);
+
+  void updateCallMap(llvm::Instruction *callInst, FunctionSet &targets);
+
+  void updateRetMap(llvm::Instruction *callInst, FunctionSet &targets);
+
+  llvm::Function *extractFunction(llvm::ConstantExpr *ce);
+
+  llvm::Module *module;
+  std::string entry;
+  std::vector<std::string> targets;
+  llvm::Function *entryFunction;
+  std::vector<llvm::Function *> targetFunctions;
+  AAPass *aa;
+  FunctionTypeMap functionTypeMap;
+  ReachabilityMap reachabilityMap;
+  CallMap callMap;
+  RetMap retMap;
+  llvm::raw_ostream &debugs;
+};
+
+#endif /* REACHABILITYANALYSIS_H */
diff --git a/include/klee/Internal/Analysis/SVFPointerAnalysis.h b/include/klee/Internal/Analysis/SVFPointerAnalysis.h
new file mode 100644
index 0000000..005b23f
--- /dev/null
+++ b/include/klee/Internal/Analysis/SVFPointerAnalysis.h
@@ -0,0 +1,41 @@
+#ifndef SVFPOINTERANALYSIS_H
+#define SVFPOINTERANALYSIS_H
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/DataLayout.h>
+
+#include "llvm/analysis/PointsTo/PointerSubgraph.h"
+#include "llvm/analysis/PointsTo/PointsTo.h"
+
+#include "AAPass.h"
+
+using namespace dg;
+
+class SVFPointerAnalysis {
+public:
+  SVFPointerAnalysis(llvm::Module *module, LLVMPointerAnalysis *pta, AAPass *aa)
+      : module(module), pta(pta), aa(aa) {}
+
+  ~SVFPointerAnalysis() {}
+
+  void run();
+  void handleVirtualCalls();
+  void handleNode(PSNode *node);
+  void handleLoad(PSNode *node);
+  void handleStore(PSNode *node);
+  void handleGep(PSNode *node);
+  void handleCast(PSNode *node);
+  void handleFuncPtr(PSNode *node);
+  bool functionPointerCall(PSNode *callsite, PSNode *called);
+  void handlePhi(PSNode *node);
+  void handleOperand(PSNode *operand);
+  void updatePointsTo(PSNode *operand, PAGNode *pagnode);
+  PSNode *getAllocNode(ObjPN *node);
+  uint64_t getAllocNodeOffset(GepObjPN *node);
+
+  llvm::Module *module;
+  LLVMPointerAnalysis *pta;
+  AAPass *aa;
+};
+
+#endif
diff --git a/include/klee/Internal/Analysis/SliceGenerator.h b/include/klee/Internal/Analysis/SliceGenerator.h
new file mode 100644
index 0000000..c78577a
--- /dev/null
+++ b/include/klee/Internal/Analysis/SliceGenerator.h
@@ -0,0 +1,49 @@
+#ifndef SLICEGENERATOR_H
+#define SLICEGENERATOR_H
+
+#include <stdbool.h>
+#include <iostream>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+
+#include "llvm/analysis/PointsTo/PointsTo.h"
+
+#include "AAPass.h"
+#include "ReachabilityAnalysis.h"
+#include "ModRefAnalysis.h"
+#include "Annotator.h"
+#include "Cloner.h"
+
+class SliceGenerator {
+public:
+  SliceGenerator(llvm::Module *module, ReachabilityAnalysis *ra, AAPass *aa,
+                 ModRefAnalysis *mra, Cloner *cloner, llvm::raw_ostream &debugs,
+                 bool lazyMode = false)
+      : module(module), ra(ra), aa(aa), mra(mra), cloner(cloner),
+        debugs(debugs), lazyMode(lazyMode), annotator(0), llvmpta(0) {}
+
+  ~SliceGenerator();
+
+  void generate();
+
+  void generateSlice(llvm::Function *f, uint32_t sliceId,
+                     ModRefAnalysis::SideEffectType type);
+
+  void dumpSlice(llvm::Function *f, uint32_t sliceId, bool recursively = false);
+
+private:
+  void markAsSliced(llvm::Function *sliceEntry, uint32_t sliceId);
+
+  llvm::Module *module;
+  ReachabilityAnalysis *ra;
+  AAPass *aa;
+  ModRefAnalysis *mra;
+  Cloner *cloner;
+  llvm::raw_ostream &debugs;
+  bool lazyMode;
+  Annotator *annotator;
+  dg::LLVMPointerAnalysis *llvmpta;
+};
+
+#endif
diff --git a/include/klee/Internal/Analysis/Slicer.h b/include/klee/Internal/Analysis/Slicer.h
new file mode 100644
index 0000000..1cc3312
--- /dev/null
+++ b/include/klee/Internal/Analysis/Slicer.h
@@ -0,0 +1,52 @@
+#ifndef SLICER_H
+#define SLICER_H
+
+#include <stdio.h>
+
+#include <llvm/IR/Module.h>
+
+#include "llvm/LLVMDependenceGraph.h"
+#include "llvm/Slicer.h"
+#include "llvm/analysis/PointsTo/PointsTo.h"
+#include "llvm/analysis/ReachingDefinitions/ReachingDefinitions.h"
+
+#include "Cloner.h"
+
+using namespace dg;
+using namespace dg::analysis::rd;
+
+class Slicer {
+private:
+  uint32_t slice_id = 0;
+  bool got_slicing_criterion = true;
+
+protected:
+  llvm::Module *M;
+  uint32_t opts = 0;
+  std::string entryFunction;
+  std::vector<std::string> criterions;
+  LLVMPointerAnalysis *PTA;
+  std::unique_ptr<LLVMReachingDefinitions> RD;
+  LLVMDependenceGraph dg;
+  LLVMSlicer slicer;
+
+public:
+  Slicer(llvm::Module *mod, uint32_t o, std::string entryFunction,
+         std::vector<std::string> criterions, LLVMPointerAnalysis *llvmpta,
+         Cloner *cloner);
+  ~Slicer();
+
+  int run();
+  bool buildDG();
+  bool mark();
+  void computeEdges();
+  bool slice();
+  void remove_unused_from_module_rec();
+  bool remove_unused_from_module();
+  void make_declarations_external();
+  const LLVMDependenceGraph &getDG() const { return dg; }
+  LLVMDependenceGraph &getDG() { return dg; }
+  void setSliceId(uint32_t id) { slice_id = id; }
+};
+
+#endif /* SLICER_H */
diff --git a/include/klee/Internal/Module/InstructionInfoTable.h b/include/klee/Internal/Module/InstructionInfoTable.h
index 98af6ac..ce7cda5 100644
--- a/include/klee/Internal/Module/InstructionInfoTable.h
+++ b/include/klee/Internal/Module/InstructionInfoTable.h
@@ -10,6 +10,8 @@
 #ifndef KLEE_LIB_INSTRUCTIONINFOTABLE_H
 #define KLEE_LIB_INSTRUCTIONINFOTABLE_H
 
+#include "klee/Internal/Analysis/Cloner.h"
+
 #include <map>
 #include <string>
 #include <set>
@@ -59,12 +61,13 @@ namespace klee {
                                  const std::string *&File, unsigned &Line);
 
   public:
-    InstructionInfoTable(llvm::Module *m);
+    InstructionInfoTable(llvm::Module *m, bool isSkippingFunctions, Cloner *cloner);
     ~InstructionInfoTable();
 
     unsigned getMaxID() const;
     const InstructionInfo &getInfo(const llvm::Instruction*) const;
     const InstructionInfo &getFunctionInfo(const llvm::Function*) const;
+    void addClonedInfo(Cloner *cloner, llvm::Function *f);
   };
 
 }
diff --git a/include/klee/Internal/Module/KInstruction.h b/include/klee/Internal/Module/KInstruction.h
index 62f514f..a715a39 100644
--- a/include/klee/Internal/Module/KInstruction.h
+++ b/include/klee/Internal/Module/KInstruction.h
@@ -38,8 +38,24 @@ namespace klee {
     /// Destination register index.
     unsigned dest;
 
+    /* TODO: add doc... */
+    bool isCloned;
+    /* points to the original instruction if the instruction is cloned */
+    llvm::Instruction *origInst;
+    /* relevant only for load instructions */
+    bool mayBlock;
+    /* relevant only for store instructions */
+    bool mayOverride;
+
   public:
     virtual ~KInstruction(); 
+
+    llvm::Instruction *getOrigInst() {
+      if (isCloned) {
+        return origInst;
+      }
+      return inst;
+    }
   };
 
   struct KGEPInstruction : KInstruction {
diff --git a/include/klee/Internal/Module/KModule.h b/include/klee/Internal/Module/KModule.h
index 76db469..d899e2d 100644
--- a/include/klee/Internal/Module/KModule.h
+++ b/include/klee/Internal/Module/KModule.h
@@ -13,6 +13,13 @@
 #include "klee/Config/Version.h"
 #include "klee/Interpreter.h"
 
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
 #include <map>
 #include <set>
 #include <vector>
@@ -53,6 +60,8 @@ namespace klee {
     /// Whether instructions in this function should count as
     /// "coverable" for statistics and search heuristics.
     bool trackCoverage;
+    
+    bool isCloned;
 
   private:
     KFunction(const KFunction&);
@@ -108,7 +117,7 @@ namespace klee {
     std::map<llvm::Constant*, KConstant*> constantMap;
     KConstant* getKConstant(llvm::Constant *c);
 
-    Cell *constantTable;
+    std::vector<Cell> constantTable;
 
     // Functions which are part of KLEE runtime
     std::set<const llvm::Function*> internalFunctions;
@@ -124,11 +133,21 @@ namespace klee {
     /// Initialize local data structures.
     //
     // FIXME: ihandler should not be here
-    void prepare(const Interpreter::ModuleOptions &opts, 
-                 InterpreterHandler *ihandler);
+    void prepare(const Interpreter::ModuleOptions &opts,
+                 const std::vector<Interpreter::SkippedFunctionOption> &skippedFunctions,
+                 InterpreterHandler *ihandler,
+                 ReachabilityAnalysis *ra,
+                 Inliner *inliner,
+                 AAPass *aa,
+                 ModRefAnalysis *mra,
+                 Cloner *cloner,
+                 SliceGenerator *sliceGenerator);
 
     /// Return an id for the given constant, creating a new one if necessary.
     unsigned getConstantID(llvm::Constant *c, KInstruction* ki);
+
+    void addFunction(KFunction *kf, bool isSkippingFunctions, Cloner *cloner, ModRefAnalysis *mra);
+
   };
 } // End klee namespace
 
diff --git a/include/klee/Internal/Support/Debug.h b/include/klee/Internal/Support/Debug.h
index 8f46b93..f5e8f59 100644
--- a/include/klee/Internal/Support/Debug.h
+++ b/include/klee/Internal/Support/Debug.h
@@ -24,4 +24,6 @@
 #endif
 #define KLEE_DEBUG(X) KLEE_DEBUG_WITH_TYPE(DEBUG_TYPE, X)
 
+#define DEBUG_BASIC "basic"
+
 #endif
diff --git a/include/klee/Interpreter.h b/include/klee/Interpreter.h
index ece84b2..4ed01ab 100644
--- a/include/klee/Interpreter.h
+++ b/include/klee/Interpreter.h
@@ -40,6 +40,12 @@ public:
 
   virtual void incPathsExplored() = 0;
 
+  virtual void incRecoveryStatesCount() = 0;
+
+  virtual void incGeneratedSlicesCount() = 0;
+
+  virtual void incSnapshotsCount() = 0;
+
   virtual void processTestCase(const ExecutionState &state,
                                const char *err, 
                                const char *suffix) = 0;
@@ -70,30 +76,60 @@ public:
 	  SMTLIB2 //.SMT2 files (SMTLIB version 2 files)
   };
 
+  struct SkippedFunctionOption {
+    std::string name;
+    /* TODO: change to lines? */
+    std::vector<unsigned int> lines;
+
+    SkippedFunctionOption(std::string name, std::vector<unsigned int> &lines) :
+      name(name), lines(lines)
+    {
+
+    }
+
+  };
+
+  struct ErrorLocationOption {
+    std::string filename;
+    std::vector<unsigned> lines;
+
+    ErrorLocationOption(std::string filename, std::vector<unsigned> &lines) :
+        filename(filename), lines(lines) {}
+  };
+
   /// InterpreterOptions - Options varying the runtime behavior during
   /// interpretation.
   struct InterpreterOptions {
     /// A frequency at which to make concrete reads return constrained
     /// symbolic values. This is used to test the correctness of the
     /// symbolic execution on concrete programs.
+    typedef std::map<std::string, std::vector<unsigned> > ErrorLocations;
+
     unsigned MakeConcreteSymbolic;
+    std::vector<SkippedFunctionOption> skippedFunctions;
+    std::vector<std::string> inlinedFunctions;
+    ErrorLocations errorLocations;
+    unsigned int maxErrorCount;
+
+    InterpreterOptions() : 
+      MakeConcreteSymbolic(false),
+      maxErrorCount(0)
+    {
 
-    InterpreterOptions()
-      : MakeConcreteSymbolic(false)
-    {}
+    }
   };
 
 protected:
-  const InterpreterOptions interpreterOpts;
+  InterpreterOptions interpreterOpts;
 
-  Interpreter(const InterpreterOptions &_interpreterOpts)
+  Interpreter(InterpreterOptions &_interpreterOpts)
     : interpreterOpts(_interpreterOpts)
   {}
 
 public:
   virtual ~Interpreter() {}
 
-  static Interpreter *create(const InterpreterOptions &_interpreterOpts,
+  static Interpreter *create(InterpreterOptions &_interpreterOpts,
                              InterpreterHandler *ih);
 
   /// Register the module to be executed.  
diff --git a/lib/Analysis/AAPass.cpp b/lib/Analysis/AAPass.cpp
new file mode 100644
index 0000000..da40515
--- /dev/null
+++ b/lib/Analysis/AAPass.cpp
@@ -0,0 +1,57 @@
+#include <MemoryModel/PointerAnalysis.h>
+#include <WPA/Andersen.h>
+#include <WPA/FlowSensitive.h>
+
+#include "klee/Internal/Analysis/AAPass.h"
+
+using namespace llvm;
+
+char AAPass::ID = 0;
+
+static RegisterPass<AAPass> WHOLEPROGRAMPA("AAPass",
+        "Whole Program Pointer Analysis Pass");
+
+AAPass::~AAPass() {
+    delete _pta;
+}
+
+bool AAPass::runOnModule(llvm::Module& module) {
+    runPointerAnalysis(module, type);
+    return false;
+}
+
+void AAPass::runPointerAnalysis(llvm::Module& module, u32_t kind) {
+    switch (kind) {
+    case PointerAnalysis::Andersen_WPA:
+        _pta = new Andersen();
+        break;
+    case PointerAnalysis::AndersenLCD_WPA:
+        _pta = new AndersenLCD();
+        break;
+    case PointerAnalysis::AndersenWave_WPA:
+        _pta = new AndersenWave();
+        break;
+    case PointerAnalysis::AndersenWaveDiff_WPA:
+        _pta = new AndersenWaveDiff();
+        break;
+    case PointerAnalysis::FSSPARSE_WPA:
+        _pta = new FlowSensitive();
+        break;
+    default:
+        llvm::errs() << "This pointer analysis has not been implemented yet.\n";
+        break;
+    }
+
+    _pta->analyze(module);
+}
+
+llvm::AliasAnalysis::AliasResult AAPass::alias(const Value* V1, const Value* V2) {
+    llvm::AliasAnalysis::AliasResult result = MayAlias;
+
+    PAG* pag = _pta->getPAG();
+    if (pag->hasValueNode(V1) && pag->hasValueNode(V2)) {
+        result = _pta->alias(V1, V2);
+    }
+
+    return result;
+}
diff --git a/lib/Analysis/Annotator.cpp b/lib/Analysis/Annotator.cpp
new file mode 100644
index 0000000..fb40efb
--- /dev/null
+++ b/lib/Analysis/Annotator.cpp
@@ -0,0 +1,109 @@
+#include <stdbool.h>
+#include <iostream>
+#include <map>
+#include <set>
+#include <vector>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/IRBuilder.h>
+#include <llvm/Support/InstIterator.h>
+
+#include <llvm-c/Core.h>
+
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Annotator.h"
+
+using namespace std;
+using namespace llvm;
+
+void Annotator::annotate() {
+    ModRefAnalysis::ModInfoToStoreMap &modInfoToStoreMap = mra->getModInfoToStoreMap();
+    ModRefAnalysis::ModInfoToIdMap &modInfoToIdMap = mra->getModInfoToIdMap();
+
+    for (ModRefAnalysis::ModInfoToStoreMap::iterator i = modInfoToStoreMap.begin(); i != modInfoToStoreMap.end(); i++) {
+        ModRefAnalysis::ModInfo modInfo = i->first;
+        set<Instruction *> &stores = i->second;
+
+        uint32_t sliceId = modInfoToIdMap[modInfo];
+        annotateStores(stores, sliceId);
+    }
+}
+
+void Annotator::annotateStores(set<Instruction *> &stores, uint32_t sliceId) {
+    for (set<Instruction *>::iterator i = stores.begin(); i != stores.end(); i++) {
+        Instruction *inst = *i;
+        annotateStore(inst, sliceId);
+    }
+}
+
+void Annotator::annotateStore(Instruction *inst, uint32_t sliceId) {
+    StoreInst *store = dyn_cast<StoreInst>(inst);
+    Value *pointerOperand = store->getPointerOperand();
+
+    /* generate a unique argument name */
+    string name = string("__crit_arg_") + to_string(argId++);
+    /* insert load */
+    LoadInst *loadInst = new LoadInst(pointerOperand, name.data());
+    loadInst->setAlignment(store->getAlignment());
+    loadInst->insertAfter(inst);
+
+    /* create criterion function */
+    Function *criterionFunction = getCriterionFunction(pointerOperand, sliceId);
+
+    /* insert call */
+    vector<Value* > args;
+    args.push_back(dyn_cast<Value>(loadInst));
+    CallInst *callInst = CallInst::Create(criterionFunction, args, "");
+    callInst->insertAfter(loadInst);
+}
+
+Function *Annotator::getCriterionFunction(Value *pointerOperand, uint32_t sliceId) {
+    PointerType *pointerType = dyn_cast<PointerType>(pointerOperand->getType());
+    Type *requiredType = pointerType->getElementType();
+
+    /* get annotation info */
+    AnnotationInfo &ai = annotationsMap[sliceId];
+
+    /* search for matching functions */
+    for (set<string>::iterator i = ai.fnames.begin(); i != ai.fnames.end(); i++) {
+        string fname = *i;
+        Function *f = module->getFunction(fname);
+        assert(f);
+
+        /* a criterion function has exactly one parameter */
+        Type *argType = f->getFunctionType()->getParamType(0);
+        if (argType == requiredType) {
+            return f;
+        }
+    }
+
+    /* generate a unique function name */
+    string fname = getAnnotatedName(sliceId, ai.subId);
+    module->getOrInsertFunction(
+        fname,
+        Type::getVoidTy(module->getContext()), 
+        requiredType,
+        NULL
+    );
+
+    ai.subId++;
+    ai.fnames.insert(fname);
+
+    return module->getFunction(fname);
+}
+
+string Annotator::getAnnotatedName(uint32_t sliceId, uint32_t subId) {
+    return string("__crit_") + to_string(sliceId) + string("_") + to_string(subId);
+}
+
+set<string> &Annotator::getAnnotatedNames(uint32_t sliceId) {
+    AnnotationsMap::iterator i = annotationsMap.find(sliceId);
+    if (i == annotationsMap.end()) {
+        /* TODO: this should not happen */
+        assert(false);
+    }
+
+    return i->second.fnames;
+}
diff --git a/lib/Analysis/CMakeLists.txt b/lib/Analysis/CMakeLists.txt
new file mode 100644
index 0000000..9178d09
--- /dev/null
+++ b/lib/Analysis/CMakeLists.txt
@@ -0,0 +1,56 @@
+#===------------------------------------------------------------------------===#
+#
+#                     The KLEE Symbolic Virtual Machine
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+#===------------------------------------------------------------------------===#
+
+klee_add_component(kleeAnalysis
+    ReachabilityAnalysis.cpp
+    Inliner.cpp
+    AAPass.cpp
+    ModRefAnalysis.cpp
+    Annotator.cpp
+    Cloner.cpp
+    Slicer.cpp
+    SVFPointerAnalysis.cpp
+    SliceGenerator.cpp
+)
+
+# TODO: Work out what the correct LLVM components are for kleeCore.
+set(LLVM_COMPONENTS
+  core
+  support
+)
+
+if ("${LLVM_PACKAGE_VERSION}" VERSION_EQUAL "3.6" OR
+    "${LLVM_PACKAGE_VERSION}" VERSION_GREATER "3.6")
+  list(APPEND LLVM_COMPONENTS mcjit executionengine native)
+else()
+  list(APPEND LLVM_COMPONENTS jit engine)
+endif()
+
+find_library(SVF_LIB Svf.so HINTS ${SVF_ROOT_DIR}/build/lib)
+find_library(CUDD_LIB Cudd.so HINTS ${SVF_ROOT_DIR}/build/lib/CUDD)
+find_library(LLVMDG_LIB LLVMdg HINTS ${DG_ROOT_DIR}/build/src)
+find_library(LLVMPTA_LIB LLVMpta HINTS ${DG_ROOT_DIR}/build/src)
+find_library(PTA_LIB PTA HINTS ${DG_ROOT_DIR}/build/src)
+find_library(RD_LIB RD HINTS ${DG_ROOT_DIR}/build/src)
+
+klee_get_llvm_libs(LLVM_LIBS ${LLVM_COMPONENTS})
+target_link_libraries(kleeAnalysis PUBLIC
+    ${SVF_LIB}
+    ${CUDD_LIB}
+    ${LLVMDG_LIB}
+    ${LLVMPTA_LIB}
+    ${PTA_LIB}
+    ${RD_LIB}
+    ${LLVM_LIBS}
+)
+target_include_directories(kleeAnalysis PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/lib/Analysis/Cloner.cpp b/lib/Analysis/Cloner.cpp
new file mode 100644
index 0000000..35d88f5
--- /dev/null
+++ b/lib/Analysis/Cloner.cpp
@@ -0,0 +1,148 @@
+#include <stdbool.h>
+#include <iostream>
+#include <set>
+#include <map>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/Support/ValueHandle.h>
+#include <llvm/Support/raw_os_ostream.h>
+#include <llvm/Transforms/Utils/Cloning.h>
+#include <llvm/Transforms/Utils/ValueMapper.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+
+using namespace std;
+using namespace llvm;
+
+Cloner::Cloner(llvm::Module *module, ReachabilityAnalysis *ra, raw_ostream &debugs) :
+    module(module),
+    ra(ra),
+    debugs(debugs)
+{
+}
+
+void Cloner::clone(Function *f, uint32_t sliceId) {
+    /* compute reachable functions only once */
+    set<Function *> &reachable = ra->getReachableFunctions(f);
+    debugs << f->getName() << ": " << reachable.size() << " reachable functions\n";
+
+    for (set<Function *>::iterator j = reachable.begin(); j != reachable.end(); j++) {
+        Function *f = *j;
+        if (f->isDeclaration()) {
+            continue;
+        }
+
+        debugs << "cloning: " << f->getName() << "\n";
+        cloneFunction(f, sliceId);
+    }
+}
+
+void Cloner::cloneFunction(Function *f, uint32_t sliceId) {
+    /* TODO: check the last parameter! */
+    ValueToValueMapTy *v2vmap = new ValueToValueMapTy();
+    Function *cloned = CloneFunction(f, *v2vmap, true);
+
+    /* set function name */
+    string clonedName = f->getName().str() + string("_clone_") + to_string(sliceId);
+    cloned->setName(StringRef(clonedName));
+
+    /* update map */
+    SliceInfo sliceInfo = {
+        .f = cloned,
+        .isSliced = false,
+        .v2vmap = v2vmap
+    };
+    functionMap[f][sliceId] = sliceInfo;
+
+    /* update map */
+    cloneInfoMap[cloned] = buildReversedMap(v2vmap);
+}
+
+Cloner::ValueTranslationMap *Cloner::buildReversedMap(ValueToValueMapTy *v2vmap) {
+    ValueTranslationMap *map = new ValueTranslationMap();
+    for (ValueToValueMapTy::iterator i = v2vmap->begin(); i != v2vmap->end(); i++) {
+        /* TODO: should be const Value... */
+        Value *value = (Value *)(i->first);
+        WeakVH &wvh = i->second;
+        Value *mappedValue  = &*wvh;
+
+        /* map only instructions */
+        if (!dyn_cast<Instruction>(value)) {
+            continue;
+        }
+
+        map->insert(make_pair(mappedValue, value));
+    }
+
+    return map;
+}
+
+Cloner::SliceMap *Cloner::getSlices(llvm::Function *function) {
+    FunctionMap::iterator i = functionMap.find(function);
+    if (i == functionMap.end()) {
+        return 0;
+    }
+
+    SliceMap &sliceMap = i->second;
+    return &sliceMap;
+}
+
+Cloner::SliceInfo *Cloner::getSliceInfo(llvm::Function *function, uint32_t sliceId) {
+    SliceMap *sliceMap = getSlices(function);
+    if (!sliceMap) {
+        return 0;
+    }
+
+    SliceMap::iterator i = sliceMap->find(sliceId);
+    if (i == sliceMap->end()) {
+        return 0;
+    }
+
+    SliceInfo &sliceInfo = i->second;
+    return &sliceInfo;
+}
+
+/* translate a cloned value to it's original one */
+Value *Cloner::translateValue(Value *value) {
+    Instruction *inst = dyn_cast<Instruction>(value);
+    if (!inst) {
+        /* TODO: do we clone only instructions? */
+        return value;
+    }
+
+    Function *f = inst->getParent()->getParent();
+    CloneInfoMap::iterator entry = cloneInfoMap.find(f);
+    if (entry == cloneInfoMap.end()) {
+        /* the value is not contained in a cloned function */
+        return value;
+    }
+
+    ValueTranslationMap *map = entry->second;
+    ValueTranslationMap::iterator i = map->find(value);
+    if (i == map->end()) {
+        /* TODO: add assert instead? */
+        return NULL;
+    }
+
+    return i->second;
+}
+
+Cloner::~Cloner() {
+    for (FunctionMap::iterator i = functionMap.begin(); i != functionMap.end(); i++) {
+        SliceMap &sliceMap = i->second;
+        for (SliceMap::iterator j = sliceMap.begin(); j != sliceMap.end(); j++) {
+            SliceInfo &sliceInfo = j->second;
+            /* TODO: refactor? */
+            Function *cloned = sliceInfo.f;
+            delete cloned;
+            ValueToValueMapTy *v2vmap = sliceInfo.v2vmap;
+            delete v2vmap;
+        }
+    }
+}
diff --git a/lib/Analysis/Inliner.cpp b/lib/Analysis/Inliner.cpp
new file mode 100644
index 0000000..c840ae2
--- /dev/null
+++ b/lib/Analysis/Inliner.cpp
@@ -0,0 +1,74 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/Constants.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/Support/raw_ostream.h>
+#include <llvm/Transforms/Utils/Cloning.h>
+
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+
+using namespace std;
+using namespace llvm;
+
+void Inliner::run() {
+    if (functions.empty()) {
+        return;
+    }
+
+    for (vector<string>::iterator i = targets.begin(); i != targets.end(); i++) {
+        Function *entry = module->getFunction(*i);
+        assert(entry);
+
+        /* we can't use pointer analysis at this point... */
+        set<Function *> reachable;
+        ra->computeReachableFunctions(entry, false, reachable);
+        for (set<Function *>::iterator i = reachable.begin(); i != reachable.end(); i++) {
+            Function *f = *i;
+            if (f->isDeclaration()) {
+                continue;
+            }
+
+            inlineCalls(f, functions);
+        }
+    }
+}
+
+void Inliner::inlineCalls(Function *f, vector<string> functions) {
+    vector<CallInst *> calls;
+
+    for (inst_iterator i = inst_begin(f); i != inst_end(f); i++) {
+        Instruction *inst = &*i;
+        if (inst->getOpcode() != Instruction::Call) {
+            continue;
+        }
+
+        CallInst *callInst = dyn_cast<CallInst>(inst);
+        Function *calledFunction = callInst->getCalledFunction();
+        if (!calledFunction) {
+            /* TODO: handle aliases, ... */
+            continue;
+        }
+
+        if (find(functions.begin(), functions.end(), calledFunction->getName().str()) == functions.end()) {
+            continue;
+        }
+
+        calls.push_back(callInst);
+    }
+
+    for (vector<CallInst *>::iterator i = calls.begin(); i != calls.end(); i++) {
+        CallInst *callInst = *i;
+
+        /* inline function call */
+        InlineFunctionInfo ifi;
+        assert(InlineFunction(callInst, ifi)); 
+    }
+}
diff --git a/lib/Analysis/ModRefAnalysis.cpp b/lib/Analysis/ModRefAnalysis.cpp
new file mode 100644
index 0000000..f85770b
--- /dev/null
+++ b/lib/Analysis/ModRefAnalysis.cpp
@@ -0,0 +1,540 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+#include <set>
+#include <map>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/DataLayout.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/Analysis/AliasAnalysis.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "MemoryModel/PointerAnalysis.h"
+#include "MSSA/MemRegion.h"
+#include "MSSA/MemPartition.h"
+
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+
+using namespace std;
+using namespace llvm;
+
+/* ModRefAnalysis class */
+
+ModRefAnalysis::ModRefAnalysis(
+    llvm::Module *module,
+    ReachabilityAnalysis *ra,
+    AAPass *aa,
+    string entry,
+    vector<string> targets,
+    llvm::raw_ostream &debugs
+) :
+    module(module), ra(ra), aa(aa), entry(entry), targets(targets), debugs(debugs)
+{
+
+}
+
+Function *ModRefAnalysis::getEntry() {
+    return entryFunction;
+}
+
+vector<Function *> ModRefAnalysis::getTargets() {
+    return targetFunctions;
+}
+
+void ModRefAnalysis::run() {
+    /* validation */
+    entryFunction = module->getFunction(entry);
+    if (!entryFunction) {
+        errs() << "entry function '" << entry << "' is not found (or unreachable)\n";
+        assert(false);
+    }
+    for (vector<string>::iterator i = targets.begin(); i != targets.end(); i++) {
+        string name = *i;
+        Function *f = module->getFunction(name);
+        if (!f) {
+            errs() << "function '" << name << "' is not found (or unreachable)\n";
+            assert(false);
+        }
+        targetFunctions.push_back(f);
+    }
+
+    /* collect mod information for each target function */
+    for (vector<Function *>::iterator i = targetFunctions.begin(); i != targetFunctions.end(); i++) {
+        Function *f = *i;
+        collectModInfo(f);
+    }
+
+    /* collect ref information with respect to the relevant call sites */
+    for (vector<Function *>::iterator i = targetFunctions.begin(); i != targetFunctions.end(); i++) {
+        Function *f = *i;
+        collectRefInfo(f);
+    }
+
+    /* compute the side effects of each target function */
+    computeModRefInfo();
+
+    /* for each modified object compute the modifying store instructions */
+    computeModInfoToStoreMap();
+
+    /* debug */
+    //dumpModSetMap();
+    //dumpDependentLoads();
+    //dumpLoadToModInfoMap();
+    //dumpModInfoToStoreMap();
+    //dumpModInfoToIdMap();
+    //dumpOverridingStores();
+}
+
+ModRefAnalysis::ModInfoToStoreMap &ModRefAnalysis::getModInfoToStoreMap() {
+    return modInfoToStoreMap;
+}
+
+bool ModRefAnalysis::mayBlock(Instruction *load) {
+    return dependentLoads.find(load) != dependentLoads.end();
+}
+
+bool ModRefAnalysis::mayOverride(Instruction *store) {
+    return overridingStores.find(store) != overridingStores.end();
+}
+
+ModRefAnalysis::SideEffects &ModRefAnalysis::getSideEffects() {
+    return sideEffects;
+}
+
+bool ModRefAnalysis::hasSideEffects(Function *f) {
+    InstructionSet &modSet = modSetMap[f];
+    return !modSet.empty();
+}
+
+bool ModRefAnalysis::getSideEffects(Function *f, InstructionSet &modSet) {
+    ModSetMap::iterator i = modSetMap.find(f);
+    if (i == modSetMap.end()) {
+        return false;
+    }
+
+    modSet = i->second;
+    return true;
+}
+
+ModRefAnalysis::InstructionSet &ModRefAnalysis::getOverridingStores() {
+    return overridingStores;
+}
+
+ModRefAnalysis::ModInfoToIdMap &ModRefAnalysis::getModInfoToIdMap() {
+    return modInfoToIdMap;
+}
+
+bool ModRefAnalysis::getRetSliceId(llvm::Function *f, uint32_t &id) {
+    RetSliceIdMap::iterator i = retSliceIdMap.find(f);
+    if (i == retSliceIdMap.end()) {
+        return false;
+    }
+
+    id = i->second;
+    return true;
+}
+
+void ModRefAnalysis::collectModInfo(Function *entry) {
+    set<Function *> &reachable = ra->getReachableFunctions(entry);
+
+    for (set<Function *>::iterator i = reachable.begin(); i != reachable.end(); i++) {
+        Function *f = *i;
+        if (f->isDeclaration()) {
+            continue;
+        }
+
+        for (inst_iterator j = inst_begin(f); j != inst_end(f); j++) {
+            Instruction *inst = &*j;
+            if (inst->getOpcode() == Instruction::Store) {
+                addStore(entry, inst);
+            } 
+        }
+    }
+
+    /* we don't need it any more... */
+    cache.clear();
+}
+
+void ModRefAnalysis::addStore(
+    Function *f,
+    Instruction *store
+) {
+    AliasAnalysis::Location storeLocation = getStoreLocation(dyn_cast<StoreInst>(store));
+    NodeID id = aa->getPTA()->getPAG()->getValueNode(storeLocation.Ptr);
+    PointsTo &pts = aa->getPTA()->getPts(id);
+
+    PointsTo &modPts = modPtsMap[f];
+
+    for (PointsTo::iterator i = pts.begin(); i != pts.end(); ++i) {
+        NodeID nodeId = *i;
+
+        /* get allocation site */
+        PAGNode *pagNode = aa->getPTA()->getPAG()->getPAGNode(nodeId);
+        ObjPN *obj = dyn_cast<ObjPN>(pagNode);
+        if (!obj) {
+            /* TODO: handle */
+            assert(false);
+        }
+
+        /* TODO: check static objects? */
+        if (obj->getMemObj()->isStack()) {
+            const Value *value = obj->getMemObj()->getRefVal();
+            if (canIgnoreStackObject(f, value)) {
+                continue;
+            }
+        }
+
+        pair<Function *, NodeID> k = make_pair(f, nodeId);
+        objToStoreMap[k].insert(store);
+        modPts.set(nodeId);
+    }
+}
+
+bool ModRefAnalysis::canIgnoreStackObject(
+    Function *f,
+    const Value *value
+) {
+    bool result;
+    AllocaInst *alloca = dyn_cast<AllocaInst>((Value *)(value));
+    if (!alloca) {
+        return false;
+    }
+
+    /* get the allocating function */
+    Function *allocatingFunction = dyn_cast<Function>(alloca->getParent()->getParent());
+
+    ReachabilityCache::iterator i = cache.find(allocatingFunction);
+    if (i == cache.end()) {
+        /* check if the entry reachable from the allocating function */
+        set<Function *> reachable;
+        ra->computeReachableFunctions(allocatingFunction, true, reachable);
+
+        /* save result */
+        result = reachable.find(f) != reachable.end();
+        cache.insert(make_pair(allocatingFunction, result));
+    } else {
+        result = i->second;
+    }
+
+    /* if reachable, then the stack object can't be ignored */
+    return !result;
+}
+
+void ModRefAnalysis::collectRefInfo(Function *entry) {
+    vector<CallInst *> callSites;
+    for (Value::use_iterator i = entry->use_begin(); i != entry->use_end(); i++) {
+        User *user = *i;
+        if (isa<CallInst>(user)) {
+            CallInst *callInst = dyn_cast<CallInst>(user);
+
+            /* check if the call site is relevant */
+            set<Function *> targets;
+            ra->getCallTargets(callInst, targets);
+            if (targets.find(entry) != targets.end()) {
+                callSites.push_back(dyn_cast<CallInst>(user));
+            }
+        }
+    }
+
+    /* get reachable instructions */
+    set<Instruction *> reachable;
+    ra->getReachableInstructions(callSites, reachable);
+
+    for (set<Instruction *>::iterator i = reachable.begin(); i != reachable.end(); i++) {
+        Instruction *inst = *i;
+
+        /* handle load */
+        if (inst->getOpcode() == Instruction::Load) {
+            addLoad(entry, inst);
+        }
+
+        /* handle store */
+        if (inst->getOpcode() == Instruction::Store) {
+            addOverridingStore(inst);
+        }
+    }
+}
+
+void ModRefAnalysis::addLoad(Function *f, Instruction *load) {
+    AliasAnalysis::Location loadLocation = getLoadLocation(dyn_cast<LoadInst>(load));
+    NodeID id = aa->getPTA()->getPAG()->getValueNode(loadLocation.Ptr);
+    PointsTo &pts = aa->getPTA()->getPts(id);
+
+    PointsTo &refPts = refPtsMap[f];
+    refPts |= pts;
+
+    for (PointsTo::iterator i = pts.begin(); i != pts.end(); ++i) {
+        NodeID nodeId = *i;
+        pair<Function *, NodeID> k = make_pair(f, nodeId);
+        objToLoadMap[k].insert(load);
+    }
+}
+
+void ModRefAnalysis::addOverridingStore(Instruction *store) {
+    AliasAnalysis::Location storeLocation = getStoreLocation(dyn_cast<StoreInst>(store));
+    NodeID id = aa->getPTA()->getPAG()->getValueNode(storeLocation.Ptr);
+    PointsTo &pts = aa->getPTA()->getPts(id);
+
+    for (PointsTo::iterator i = pts.begin(); i != pts.end(); ++i) {
+        NodeID nodeId = *i;
+        objToOverridingStoreMap[nodeId].insert(store);
+    }
+}
+
+void ModRefAnalysis::computeModRefInfo() {
+    for (ModPtsMap::iterator i = modPtsMap.begin(); i != modPtsMap.end(); i++) {
+        Function *f = i->first;
+        PointsTo &modPts = i->second;
+
+        /* get the corresponding ref-set */
+        PointsTo &refPts = refPtsMap[f];
+        /* compute the intersection */
+        PointsTo pts = modPts & refPts;
+        /* get the corresponding modifies-set */
+        InstructionSet &modSet = modSetMap[f];
+
+        for (PointsTo::iterator ni = pts.begin(); ni != pts.end(); ++ni) {
+            NodeID nodeId = *ni;
+
+            /* set key */
+            pair<Function *, NodeID> k = make_pair(f, nodeId);
+
+            /* update modifies-set */
+            InstructionSet &stores = objToStoreMap[k];
+            modSet.insert(stores.begin(), stores.end());
+
+            /* get allocation site */
+            AllocSite allocSite = getAllocSite(nodeId);
+
+            InstructionSet &loads = objToLoadMap[k];
+            for (InstructionSet::iterator i = loads.begin(); i != loads.end(); i++) {
+                Instruction *load = *i;
+
+                /* update with store instructions */
+                dependentLoads.insert(load);
+
+                /* update with allocation site */
+                ModInfo modInfo = make_pair(f, allocSite);
+                loadToModInfoMap[load].insert(modInfo);
+            }
+
+            /* update overriding stores */
+            InstructionSet &localOverridingStores = objToOverridingStoreMap[nodeId];
+            overridingStores.insert(localOverridingStores.begin(), localOverridingStores.end());
+        }
+    }
+}
+
+void ModRefAnalysis::computeModInfoToStoreMap() {
+    uint32_t sliceId = 1;
+
+    for (vector<Function *>::iterator i = targetFunctions.begin(); i != targetFunctions.end(); i++) {
+        Function *f = *i;
+        InstructionSet &modSet = modSetMap[f];
+
+        uint32_t retSliceId = sliceId++;
+        if (hasReturnValue(f)) {
+            retSliceIdMap[f] = retSliceId;
+            SideEffect sideEffect = {
+                .type = ReturnValue,
+                .id = retSliceId,
+                .info = {
+                    .f = f
+                }
+            };
+            sideEffects.push_back(sideEffect);
+        }
+
+        for (InstructionSet::iterator i = modSet.begin(); i != modSet.end(); i++) {
+            Instruction *store = *i;
+            AliasAnalysis::Location storeLocation = getStoreLocation(dyn_cast<StoreInst>(store));
+            NodeID id = aa->getPTA()->getPAG()->getValueNode(storeLocation.Ptr);
+            PointsTo &pts = aa->getPTA()->getPts(id);
+
+            for (PointsTo::iterator ni = pts.begin(); ni != pts.end(); ++ni) {
+                NodeID nodeId = *ni;
+
+                /* update store instructions */
+                AllocSite allocSite = getAllocSite(nodeId);
+                ModInfo modInfo = make_pair(f, allocSite);
+                modInfoToStoreMap[modInfo].insert(store);
+
+                if (modInfoToIdMap.find(modInfo) == modInfoToIdMap.end()) {
+                    uint32_t modSliceId = sliceId++;
+                    modInfoToIdMap[modInfo] = modSliceId;
+                    SideEffect sideEffect = {
+                        .type = Modifier,
+                        .id = modSliceId,
+                        .info = {
+                            .modInfo = modInfo
+                        }
+                    };
+                    sideEffects.push_back(sideEffect);
+                }
+            }
+        }
+    }
+}
+
+ModRefAnalysis::AllocSite ModRefAnalysis::getAllocSite(NodeID nodeId) {
+    PAGNode *pagNode = aa->getPTA()->getPAG()->getPAGNode(nodeId);
+    ObjPN *obj = dyn_cast<ObjPN>(pagNode);
+    assert(obj);
+
+    /* get allocation site value */
+    const MemObj *mo = obj->getMemObj();
+    const Value *allocSite = mo->getRefVal();
+
+    /* get offset in bytes */
+    uint64_t offset = 0;
+    if (obj->getNodeKind() == PAGNode::GepObjNode) {
+        GepObjPN *gepObj = dyn_cast<GepObjPN>(obj);
+        offset = gepObj->getLocationSet().getAccOffset(); 
+    }
+
+    return make_pair(allocSite, offset);
+}
+
+bool ModRefAnalysis::hasReturnValue(Function *f) {
+    return !f->getReturnType()->isVoidTy();
+}
+
+AliasAnalysis::Location ModRefAnalysis::getLoadLocation(LoadInst *inst) {
+    Value *addr = inst->getPointerOperand();
+    return AliasAnalysis::Location(addr);
+}
+
+AliasAnalysis::Location ModRefAnalysis::getStoreLocation(StoreInst *inst) {
+    Value *addr = inst->getPointerOperand();
+    return AliasAnalysis::Location(addr);
+}
+
+/* TODO: validate that a load can't have two ModInfo's with the same allocation site */
+void ModRefAnalysis::getApproximateModInfos(Instruction *inst, AllocSite hint, set<ModInfo> &result) {
+    assert(inst->getOpcode() == Instruction::Load);
+
+    LoadToModInfoMap::iterator entry = loadToModInfoMap.find(inst);
+    if (entry == loadToModInfoMap.end()) {
+        /* TODO: this should not happen */
+        assert(false);
+    }
+
+    set<ModInfo> &modifiers = entry->second;
+
+    for (set<ModInfo>::iterator i = modifiers.begin(); i != modifiers.end(); i++) {
+        ModInfo modInfo = *i;
+        AllocSite allocSite = modInfo.second;
+
+        /* compare only the allocation sites (values) */
+        if (allocSite.first == hint.first) {
+            result.insert(modInfo);
+        }
+    }
+
+    return;
+}
+
+void ModRefAnalysis::dumpModSetMap() {
+    debugs << "### ModSetMap ###\n";
+
+    for (ModSetMap::iterator i = modSetMap.begin(); i != modSetMap.end(); i++) {
+        Function *f = i->first;
+        InstructionSet &modSet = i->second;
+
+        debugs << "# " << f->getName() << " #\n";
+        for (InstructionSet::iterator j = modSet.begin(); j != modSet.end(); j++) {
+            Instruction *inst = *j;
+            dumpInst(inst);
+        }
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpDependentLoads() {
+    debugs << "### DependentLoads ###\n";
+
+    for (Instruction *inst : dependentLoads) {
+        dumpInst(inst);
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpLoadToModInfoMap() {
+    debugs << "### LoadToModInfoMap ###\n";
+
+    for (LoadToModInfoMap::iterator i = loadToModInfoMap.begin(); i != loadToModInfoMap.end(); i++) {
+        Instruction *load = i->first;
+        set<ModInfo> &modInfos = i->second;
+
+        dumpInst(load);
+        for (set<ModInfo>::iterator j = modInfos.begin(); j != modInfos.end(); j++) {
+            const ModInfo &modInfo = *j;
+            dumpModInfo(modInfo, "\t");
+        }
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpModInfoToStoreMap() {
+    debugs << "### ModInfoToStoreMap ###\n";
+
+    for (ModInfoToStoreMap::iterator i = modInfoToStoreMap.begin(); i != modInfoToStoreMap.end(); i++) {
+        const ModInfo &modInfo = i->first;
+        InstructionSet &stores = i->second;
+
+        dumpModInfo(modInfo);
+        for (InstructionSet::iterator j = stores.begin(); j != stores.end(); j++) {
+            Instruction *store = *j;
+            dumpInst(store, "\t");
+        }
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpModInfoToIdMap() {
+    debugs << "### ModInfoToIdMap ###\n";
+
+    for (ModInfoToIdMap::iterator i = modInfoToIdMap.begin(); i != modInfoToIdMap.end(); i++) {
+        const ModInfo &modInfo = i->first;
+        uint32_t id = i->second;
+        
+        dumpModInfo(modInfo);
+        debugs << "id: " << id << "\n";
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpOverridingStores() {
+    debugs << "### Overriding Stores ###\n";
+
+    for (InstructionSet::iterator j = overridingStores.begin(); j != overridingStores.end(); j++) {
+        Instruction *inst = *j;
+        dumpInst(inst);
+    }
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpInst(Instruction *inst, const char *prefix) {
+    Function *f = inst->getParent()->getParent();
+
+    debugs << prefix << "[" << f->getName() << "]";
+    inst->print(debugs);
+    debugs << "\n";
+}
+
+void ModRefAnalysis::dumpModInfo(const ModInfo &modInfo, const char *prefix) {
+    Function *f = modInfo.first;
+    AllocSite allocSite = modInfo.second;
+
+    const Value *value = allocSite.first;
+    uint64_t offset = allocSite.second;
+
+    debugs << prefix << "function: " << f->getName() << "\n";
+    debugs << prefix << "allocation site: "; value->print(debugs); debugs << "\n";
+    debugs << prefix << "offset: " << offset << "\n";
+}
diff --git a/lib/Analysis/ReachabilityAnalysis.cpp b/lib/Analysis/ReachabilityAnalysis.cpp
new file mode 100644
index 0000000..c693a34
--- /dev/null
+++ b/lib/Analysis/ReachabilityAnalysis.cpp
@@ -0,0 +1,424 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+#include <stack>
+#include <set>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/IR/Constants.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+
+using namespace std;
+using namespace llvm;
+
+void ReachabilityAnalysis::prepare() {
+  /* remove unused functions using fixpoint */
+  removeUnusedValues();
+  /* compute function type map for resolving indirect calls */
+  computeFunctionTypeMap();
+}
+
+void ReachabilityAnalysis::removeUnusedValues() {
+  bool changed = true;
+  set<string> keep;
+
+  /* entry function must not be removed */
+  keep.insert(entry);
+
+  while (changed) {
+    std::set<Function *> functions;
+
+    for (Module::iterator i = module->begin(); i != module->end(); i++) {
+      Function *f = &*i;
+      if (keep.find(f->getName().str()) != keep.end()) {
+        continue;
+      }
+
+      if (f->hasNUses(0)) {
+        functions.insert(f);
+      }
+    }
+
+    for (Function *f : functions) {
+      debugs << "erasing: " << f->getName() << "\n";
+      f->eraseFromParent();
+    }
+
+    changed = !functions.empty();
+  }
+}
+
+void ReachabilityAnalysis::computeFunctionTypeMap() {
+  for (Module::iterator i = module->begin(); i != module->end(); i++) {
+    /* add functions which may be virtual */
+    Function *f = &*i;
+    if (!isVirtual(f)) {
+      continue;
+    }
+
+    FunctionType *type = f->getFunctionType();
+    functionTypeMap[type].insert(f);
+
+    /* if a function pointer is casted, consider the casted type as well */
+    for (auto i = f->use_begin(); i != f->use_end(); i++) {
+      ConstantExpr *ce = dyn_cast<ConstantExpr>(*i);
+      if (ce && ce->isCast()) {
+        PointerType *pointerType = dyn_cast<PointerType>(ce->getType());
+        if (!pointerType) {
+          continue;
+        }
+
+        FunctionType *castedType =
+            dyn_cast<FunctionType>(pointerType->getElementType());
+        if (!castedType) {
+          continue;
+        }
+
+        functionTypeMap[castedType].insert(f);
+      }
+    }
+  }
+}
+
+bool ReachabilityAnalysis::run(bool usePA) {
+  vector<Function *> all;
+
+  /* check parameters... */
+  entryFunction = module->getFunction(entry);
+  if (!entryFunction) {
+    errs() << "entry function '" << entry << "' is not found\n";
+    return false;
+  }
+  all.push_back(entryFunction);
+
+  for (vector<string>::iterator i = targets.begin(); i != targets.end(); i++) {
+    string name = *i;
+    Function *f = module->getFunction(name);
+    if (!f) {
+      errs() << "function '" << name << "' is not found\n";
+      return false;
+    }
+    targetFunctions.push_back(f);
+    all.push_back(f);
+  }
+
+  /* build reachability map */
+  for (vector<Function *>::iterator i = all.begin(); i != all.end(); i++) {
+    updateReachabilityMap(*i, usePA);
+  }
+
+  /* debug */
+  dumpReachableFunctions();
+
+  return true;
+}
+
+void ReachabilityAnalysis::updateReachabilityMap(Function *f, bool usePA) {
+  FunctionSet &functions = reachabilityMap[f];
+  computeReachableFunctions(f, usePA, functions);
+}
+
+void ReachabilityAnalysis::computeReachableFunctions(Function *entry,
+                                                     bool usePA,
+                                                     FunctionSet &results) {
+  stack<Function *> stack;
+  FunctionSet pushed;
+
+  stack.push(entry);
+  pushed.insert(entry);
+  results.insert(entry);
+
+  while (!stack.empty()) {
+    Function *f = stack.top();
+    stack.pop();
+
+    for (inst_iterator iter = inst_begin(f); iter != inst_end(f); iter++) {
+      Instruction *inst = &*iter;
+      if (inst->getOpcode() != Instruction::Call) {
+        continue;
+      }
+
+      CallInst *callInst = dyn_cast<CallInst>(inst);
+
+      /* potential call targets */
+      FunctionSet targets;
+      resolveCallTargets(callInst, usePA, targets);
+
+      for (FunctionSet::iterator i = targets.begin(); i != targets.end(); i++) {
+        Function *target = *i;
+        results.insert(target);
+
+        if (target->isDeclaration()) {
+          continue;
+        }
+
+        if (pushed.find(target) == pushed.end()) {
+          stack.push(target);
+          pushed.insert(target);
+        }
+      }
+
+      if (usePA) {
+        updateCallMap(callInst, targets);
+        updateRetMap(callInst, targets);
+      }
+    }
+  }
+}
+
+bool ReachabilityAnalysis::isVirtual(Function *f) {
+  for (Value::use_iterator i = f->use_begin(); i != f->use_end(); i++) {
+    Value *use = *i;
+    CallInst *callInst = dyn_cast<CallInst>(use);
+    if (!callInst) {
+      /* we found a use which is not a call instruction */
+      return true;
+    }
+
+    for (unsigned int j = 0; j < callInst->getNumArgOperands(); j++) {
+      Value *arg = callInst->getArgOperand(j);
+      if (isa<Function>(arg)) {
+        if (arg == f) {
+          /* the function is passed as an argument */
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+void ReachabilityAnalysis::resolveCallTargets(CallInst *callInst, bool usePA,
+                                              FunctionSet &targets) {
+  Function *calledFunction = callInst->getCalledFunction();
+  Value *calledValue = callInst->getCalledValue();
+
+  if (!calledFunction) {
+    /* the called value should be one of these: function pointer, cast, alias */
+    if (isa<ConstantExpr>(calledValue)) {
+      Function *extracted =
+          extractFunction(dyn_cast<ConstantExpr>(calledValue));
+      if (!extracted) {
+        /* TODO: unexpected value... */
+        assert(false);
+      }
+      calledFunction = extracted;
+    }
+  }
+
+  if (calledFunction == NULL) {
+    /* the called value should be a function pointer */
+    if (usePA && aa) {
+      resolveIndirectCallByPA(calledValue, targets);
+    } else {
+      Type *calledType = calledValue->getType();
+      resolveIndirectCallByType(calledType, targets);
+    }
+  } else {
+    targets.insert(calledFunction);
+  }
+}
+
+void ReachabilityAnalysis::resolveIndirectCallByType(Type *calledType,
+                                                     FunctionSet &targets) {
+  if (!isa<PointerType>(calledType)) {
+    return;
+  }
+
+  Type *elementType = dyn_cast<PointerType>(calledType)->getElementType();
+  if (!elementType) {
+    return;
+  }
+
+  if (!isa<FunctionType>(elementType)) {
+    return;
+  }
+
+  FunctionType *functionType = dyn_cast<FunctionType>(elementType);
+  FunctionTypeMap::iterator i = functionTypeMap.find(functionType);
+  if (i != functionTypeMap.end()) {
+    FunctionSet &functions = i->second;
+    targets.insert(functions.begin(), functions.end());
+  }
+}
+
+void ReachabilityAnalysis::resolveIndirectCallByPA(Value *calledValue,
+                                                   FunctionSet &targets) {
+  if (!calledValue) {
+    return;
+  }
+
+  if (!aa->getPTA()->getPAG()->hasValueNode(calledValue)) {
+    debugs << "WARNING: no PAG node for: " << *calledValue << "\n";
+    return;
+  }
+
+  NodeID id = aa->getPTA()->getPAG()->getValueNode(calledValue);
+  PointsTo &pts = aa->getPTA()->getPts(id);
+
+  if (pts.empty()) {
+    return;
+  }
+
+  for (PointsTo::iterator i = pts.begin(); i != pts.end(); ++i) {
+    NodeID nodeId = *i;
+    PAGNode *pagNode = aa->getPTA()->getPAG()->getPAGNode(nodeId);
+    if (isa<ObjPN>(pagNode)) {
+      ObjPN *obj = dyn_cast<ObjPN>(pagNode);
+      const Value *value = obj->getMemObj()->getRefVal();
+      if (isa<Function>(value)) {
+        const Function *f = dyn_cast<const Function>(value);
+        targets.insert((Function *)(f));
+      }
+    }
+  }
+}
+
+Function *ReachabilityAnalysis::extractFunction(ConstantExpr *ce) {
+  if (!ce->isCast()) {
+    return NULL;
+  }
+
+  Value *value = ce->getOperand(0);
+  if (isa<Function>(value)) {
+    return dyn_cast<Function>(value);
+  }
+
+  if (isa<GlobalAlias>(value)) {
+    Constant *aliasee = dyn_cast<GlobalAlias>(value)->getAliasee();
+    if (isa<Function>(aliasee)) {
+      return dyn_cast<Function>(aliasee);
+    }
+    if (isa<ConstantExpr>(aliasee)) {
+      return extractFunction(dyn_cast<ConstantExpr>(aliasee));
+    }
+  }
+
+  return NULL;
+}
+
+void ReachabilityAnalysis::updateCallMap(Instruction *callInst,
+                                         FunctionSet &targets) {
+  callMap[callInst].insert(targets.begin(), targets.end());
+}
+
+void ReachabilityAnalysis::updateRetMap(Instruction *callInst,
+                                        FunctionSet &targets) {
+  Instruction *retInst = callInst->getNextNode();
+  for (FunctionSet::iterator i = targets.begin(); i != targets.end(); i++) {
+    Function *f = *i;
+    retMap[f].insert(retInst);
+  }
+}
+
+ReachabilityAnalysis::FunctionSet &
+ReachabilityAnalysis::getReachableFunctions(Function *f) {
+  ReachabilityMap::iterator i = reachabilityMap.find(f);
+  if (i == reachabilityMap.end()) {
+    assert(false);
+  }
+
+  return i->second;
+}
+
+void
+ReachabilityAnalysis::getReachableInstructions(vector<CallInst *> &callSites,
+                                               InstructionSet &result) {
+  stack<Instruction *> stack;
+  InstructionSet visited;
+
+  for (vector<CallInst *>::iterator i = callSites.begin(); i != callSites.end();
+       i++) {
+    CallInst *callInst = *i;
+    stack.push(callInst->getNextNode());
+  }
+
+  while (!stack.empty()) {
+    /* fetch an instruction */
+    Instruction *inst = stack.top();
+    stack.pop();
+
+    /* check if already visited */
+    if (visited.find(inst) != visited.end()) {
+      continue;
+    }
+
+    if (isa<CallInst>(inst)) {
+      CallMap::iterator i = callMap.find(inst);
+      if (i != callMap.end()) {
+        FunctionSet &targets = i->second;
+        for (FunctionSet::iterator j = targets.begin(); j != targets.end();
+             j++) {
+          Function *f = *j;
+          if (f->isDeclaration()) {
+            continue;
+          }
+
+          Instruction *first = f->begin()->begin();
+          stack.push(first);
+        }
+      }
+
+      stack.push(inst->getNextNode());
+
+    } else if (isa<ReturnInst>(inst)) {
+      Function *src = inst->getParent()->getParent();
+      RetMap::iterator i = retMap.find(src);
+      if (i != retMap.end()) {
+        InstructionSet &targets = i->second;
+        for (InstructionSet::iterator j = targets.begin(); j != targets.end();
+             j++) {
+          Instruction *retInst = *j;
+          stack.push(retInst);
+        }
+      }
+
+    } else if (isa<TerminatorInst>(inst)) {
+      TerminatorInst *termInst = dyn_cast<TerminatorInst>(inst);
+      for (unsigned int i = 0; i < termInst->getNumSuccessors(); i++) {
+        BasicBlock *bb = termInst->getSuccessor(i);
+        stack.push(bb->begin());
+      }
+    } else {
+      stack.push(inst->getNextNode());
+    }
+
+    visited.insert(inst);
+    result.insert(inst);
+  }
+}
+
+void ReachabilityAnalysis::getCallTargets(llvm::Instruction *inst,
+                                          FunctionSet &result) {
+  if (inst->getOpcode() != Instruction::Call) {
+    return;
+  }
+
+  CallMap::iterator i = callMap.find(inst);
+  if (i == callMap.end()) {
+    return;
+  }
+
+  result = i->second;
+}
+
+void ReachabilityAnalysis::dumpReachableFunctions() {
+  /* get all reachable functions */
+  FunctionSet &reachable = getReachableFunctions(entryFunction);
+
+  debugs << "### " << reachable.size() << " reachable functions ###\n";
+  for (FunctionSet::iterator i = reachable.begin(); i != reachable.end(); i++) {
+    Function *f = *i;
+    debugs << "    " << f->getName() << "\n";
+  }
+  debugs << "\n";
+}
diff --git a/lib/Analysis/SVFPointerAnalysis.cpp b/lib/Analysis/SVFPointerAnalysis.cpp
new file mode 100644
index 0000000..69f0e08
--- /dev/null
+++ b/lib/Analysis/SVFPointerAnalysis.cpp
@@ -0,0 +1,279 @@
+#include <stdio.h>
+
+#include <iostream>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+#include <llvm/IR/BasicBlock.h>
+#include <llvm/IR/Instruction.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/Support/InstIterator.h>
+#include <llvm/IR/Constants.h>
+#include <llvm/Support/raw_ostream.h>
+
+#include "analysis/PointsTo/PointerSubgraph.h"
+#include "analysis/Offset.h"
+
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/SVFPointerAnalysis.h"
+
+using namespace llvm;
+using namespace dg::analysis::pta;
+
+void SVFPointerAnalysis::run() {
+    /* update virtual call related nodes */
+    handleVirtualCalls();
+
+    for (auto &v : pta->getNodesMap()) {
+        PSNode *node = v.second.second;
+        handleNode(node);
+    }
+}
+
+void SVFPointerAnalysis::handleNode(PSNode *node) {
+    switch (node->getType()) {
+    case LOAD:
+        handleLoad(node);
+        break;
+
+    case STORE:
+        handleStore(node);
+        break;
+
+    case GEP:
+        handleGep(node);
+        break;
+
+    case CAST:
+        handleCast(node);
+        break;
+
+    case CONSTANT:
+        break;
+
+    case CALL_RETURN:
+    case RETURN:
+    case PHI:
+        handlePhi(node);
+        break;
+
+    case CALL_FUNCPTR:
+        break;
+
+    case MEMCPY:
+        /* TODO: handle? */
+        break;
+
+    case ALLOC:
+    case DYN_ALLOC:
+    case FUNCTION:
+        assert(node->doesPointsTo(node, 0));
+        assert(node->pointsTo.size() == 1);
+    case CALL:
+    case ENTRY:
+    case NOOP:
+        break;
+
+    default:
+        assert(false);
+    }
+}
+
+void SVFPointerAnalysis::handleVirtualCalls() {
+    std::set<PSNode *> visited;
+    bool changed = true;
+
+    while (changed) {
+        std::set<PSNode *> discovered;
+        changed = false;
+
+        /* first, get all relevant nodes */
+        for (auto &v : pta->getNodesMap()) {
+            PSNode *node = v.second.second;
+            if (node->getType() != CALL_FUNCPTR) {
+                continue;
+            }
+
+            if (visited.find(node) == visited.end()) {
+                discovered.insert(node);
+                changed = true;
+            }
+        }
+
+        for (PSNode *node : discovered) {
+            handleFuncPtr(node);
+            visited.insert(node);
+        }
+    }
+}
+
+void SVFPointerAnalysis::handleLoad(PSNode *node) {
+    handleOperand(node);
+    handleOperand(node->getOperand(0));
+}
+
+void SVFPointerAnalysis::handleStore(PSNode *node) {
+    handleOperand(node);
+    handleOperand(node->getOperand(1));
+}
+
+void SVFPointerAnalysis::handleGep(PSNode *node) {
+    handleOperand(node);
+    handleOperand(node->getOperand(0));
+}
+
+void SVFPointerAnalysis::handleCast(PSNode *node) {
+    handleOperand(node);
+    handleOperand(node->getOperand(0));
+}
+
+void SVFPointerAnalysis::handlePhi(PSNode *node) {
+    /* TODO: check if required! */
+    handleOperand(node);
+    for (PSNode *op : node->getOperands()) {
+        handleOperand(op);
+    }
+}
+
+void SVFPointerAnalysis::handleFuncPtr(PSNode *node) {
+    PSNode *operand = node->getOperand(0);
+    handleOperand(operand);
+
+    /* now, operand->pointsTo is updated */
+    for (const Pointer& ptr : operand->pointsTo) {
+        if (ptr.isValid()) {
+            functionPointerCall(node, ptr.target);
+        }
+    }
+}
+
+/* based on the code from DG */
+bool SVFPointerAnalysis::functionPointerCall(PSNode *callsite, PSNode *called) {
+    if (!isa<Function>(called->getUserData<Value>())) {
+        return false;
+    }
+
+    const Function *f = called->getUserData<Function>();
+    const CallInst *callInst = callsite->getUserData<CallInst>();
+
+    /* TODO: make a partial compatability check */
+    //if (!llvmutils::callIsCompatible(F, CI))
+    //    return false;
+
+    if (f->size() == 0) {
+        return callsite->getPairedNode()->addPointsTo(analysis::pta::PointerUnknown);
+    }
+
+    PSNodesSeq seq = pta->builder->createFuncptrCall(callInst, f);
+    assert(seq.first && seq.second);
+
+    PSNode *paired = callsite->getPairedNode();
+    paired->addOperand(seq.second);
+
+    if (callsite->successorsNum() == 1 && callsite->getSingleSuccessor() == paired) {
+        callsite->replaceSingleSuccessor(seq.first);
+    } else {
+        callsite->addSuccessor(seq.first);
+    }
+
+    seq.second->addSuccessor(paired);
+
+    return true;
+}
+
+void SVFPointerAnalysis::handleOperand(PSNode *operand) {
+    Value *value = operand->getUserData<Value>();
+    if (!value) {
+        return;
+    }
+
+    if (!aa->getPTA()->getPAG()->hasValueNode(value)) {
+        /* TODO: not a pointer? */
+        return;
+    }
+
+    NodeID id = aa->getPTA()->getPAG()->getValueNode(value);
+    PointsTo &pts = aa->getPTA()->getPts(id);
+
+    if (pts.empty()) {
+        operand->addPointsTo(NULLPTR);
+        return;
+    }
+
+    for (PointsTo::iterator i = pts.begin(); i != pts.end(); ++i) {
+        NodeID node_id = *i;
+        PAGNode *pagnode = aa->getPTA()->getPAG()->getPAGNode(node_id);
+        if (isa<ObjPN>(pagnode)) {
+            updatePointsTo(operand, pagnode);
+        }
+    }
+}
+
+void SVFPointerAnalysis::updatePointsTo(PSNode *operand, PAGNode *pagnode) {
+    int kind = pagnode->getNodeKind();
+    ObjPN *obj_node = NULL;
+    GepObjPN *gepobj_node = NULL;
+    PSNode *alloc_node = NULL;
+    uint64_t offset = 0;
+
+    switch (kind) {
+    case PAGNode::ObjNode:
+    case PAGNode::FIObjNode:
+        /* TODO: handle FIObjNode */
+        obj_node = dyn_cast<ObjPN>(pagnode);
+        alloc_node = getAllocNode(obj_node);
+        offset = 0;
+        break;
+
+    case PAGNode::GepObjNode:
+        gepobj_node = dyn_cast<GepObjPN>(pagnode);
+        alloc_node = getAllocNode(gepobj_node);
+        offset = getAllocNodeOffset(gepobj_node);
+        break;
+
+    case PAGNode::DummyObjNode:
+        /* TODO: are we supposed to do something? */
+        return;
+
+    default:
+        assert(false);
+        return;
+    }
+
+    if (!alloc_node) {
+        return;
+    }
+
+    /* add to PointsTo set */
+    operand->addPointsTo(Pointer(alloc_node, offset));
+}
+
+PSNode *SVFPointerAnalysis::getAllocNode(ObjPN *node) {
+    /* get SVF memory object (allocation site) */
+    const MemObj *mo = node->getMemObj();    
+
+    /* get corresponding DG node */
+    PSNode *ref_node = pta->builder->getNode(mo->getRefVal());
+    if (!ref_node) {
+        /* TODO: check why DG does not have this allocation site */
+        //assert(false);
+    }
+
+    return ref_node;
+}
+
+uint64_t SVFPointerAnalysis::getAllocNodeOffset(GepObjPN *node) {
+    LocationSet ls = node->getLocationSet();
+    assert(ls.isConstantOffset());
+
+    /* offset in bytes */
+    unsigned offsetInBytes = ls.getAccOffset();
+
+    const MemObj *mo = node->getMemObj();
+    if (mo->isArray()) {
+        /* arrays are handled insensitively */
+        return UNKNOWN_OFFSET;
+    }
+
+    return offsetInBytes;
+}
diff --git a/lib/Analysis/SliceGenerator.cpp b/lib/Analysis/SliceGenerator.cpp
new file mode 100644
index 0000000..c5e0abe
--- /dev/null
+++ b/lib/Analysis/SliceGenerator.cpp
@@ -0,0 +1,132 @@
+#include <stdbool.h>
+#include <iostream>
+
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Function.h>
+
+#include "llvm/Support/CommandLine.h"
+
+#include "llvm/analysis/PointsTo/PointsTo.h"
+
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Annotator.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SVFPointerAnalysis.h"
+#include "klee/Internal/Analysis/Slicer.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
+using namespace std;
+using namespace llvm;
+using namespace dg;
+
+
+void SliceGenerator::generate() {
+	/* add annotations for slicing */
+	annotator = new Annotator(module, mra);
+	annotator->annotate();
+
+    /* notes:
+       - UNKNOWN_OFFSET: field sensitive (not sure if this flag changes anything...)
+       - main: we need the nodes of the whole program
+    */
+    llvmpta = new LLVMPointerAnalysis(module, UNKNOWN_OFFSET, "main");
+    llvmpta->PS->setRoot(llvmpta->builder->buildLLVMPointerSubgraph());
+
+    /* translate the results of SVF to DG */
+    SVFPointerAnalysis svfpa(module, llvmpta, aa);
+    svfpa.run();
+
+    if (lazyMode) {
+        return;
+    }
+
+    /* generate all the slices... */
+    ModRefAnalysis::SideEffects &sideEffects = mra->getSideEffects();
+    for (ModRefAnalysis::SideEffects::iterator i = sideEffects.begin(); i != sideEffects.end(); i++) {
+        generateSlice(i->getFunction(), i->id, i->type);
+    }
+}
+
+void SliceGenerator::generateSlice(Function *f, uint32_t sliceId, ModRefAnalysis::SideEffectType type) {
+    std::vector<std::string> criterions;
+    std::set<std::string> fnames;
+
+    /* set criterion functions */
+    switch (type) {
+    case ModRefAnalysis::ReturnValue:
+        criterions.push_back("ret");
+        break;
+
+    case ModRefAnalysis::Modifier:
+        fnames = annotator->getAnnotatedNames(sliceId);
+        for (std::set<std::string>::iterator i = fnames.begin(); i != fnames.end(); i++) {
+            std::string fname = *i;
+            criterions.push_back(fname);
+        }
+        break;
+
+    default:
+        assert(false);
+        break;
+    }
+
+    /* create the clone (inclusive) */
+    cloner->clone(f, sliceId);
+
+    /* generate slice */
+    string entryName = f->getName().data();
+    Slicer slicer(module, 0, entryName, criterions, llvmpta, cloner);
+    slicer.setSliceId(sliceId);
+    slicer.run();
+
+    markAsSliced(f, sliceId);
+}
+
+void SliceGenerator::markAsSliced(Function *sliceEntry, uint32_t sliceId) {
+    set<Function *> &reachable = ra->getReachableFunctions(sliceEntry);
+
+    /* mark all reachable functions as sliced... */
+    for (set<Function *>::iterator i = reachable.begin(); i != reachable.end(); i++) {
+        Function *f = *i;
+        if (f->isDeclaration()) {
+            continue;
+        }
+
+        Cloner::SliceInfo *sliceInfo = cloner->getSliceInfo(*i, sliceId);
+        sliceInfo->isSliced = true;
+    }
+}
+
+void SliceGenerator::dumpSlice(Function *f, uint32_t sliceId, bool recursively) {
+    Cloner::SliceInfo *sliceInfo = cloner->getSliceInfo(f, sliceId);
+    if (!sliceInfo) {
+        /* slice not found... */
+        return;
+    }
+
+    set<Function *> functions;
+    if (recursively) {
+        set<Function *> &reachable = ra->getReachableFunctions(f);
+        functions.insert(reachable.begin(), reachable.end());
+    } else {
+        functions.insert(f);
+    }
+
+    for (set<Function *>::iterator i = functions.begin(); i != functions.end(); i++) {
+        Function *g = *i;
+        if (g->isDeclaration()) {
+            continue;
+        }
+
+        sliceInfo = cloner->getSliceInfo(g, sliceId);
+        if (sliceInfo->isSliced) {
+            sliceInfo->f->print(debugs);
+        }
+    }
+}
+
+SliceGenerator::~SliceGenerator() {
+    delete llvmpta;
+    delete annotator;
+}
diff --git a/lib/Analysis/Slicer.cpp b/lib/Analysis/Slicer.cpp
new file mode 100644
index 0000000..762c399
--- /dev/null
+++ b/lib/Analysis/Slicer.cpp
@@ -0,0 +1,564 @@
+#include <set>
+#include <string>
+
+#include <cassert>
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+
+#ifndef HAVE_LLVM
+#error "This code needs LLVM enabled"
+#endif
+
+#include <llvm/Config/llvm-config.h>
+
+#if (LLVM_VERSION_MAJOR < 3)
+#error "Unsupported version of LLVM"
+#endif
+
+// ignore unused parameters in LLVM libraries
+#if (__clang__)
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-parameter"
+#else
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#endif
+
+#if ((LLVM_VERSION_MAJOR == 3) && (LLVM_VERSION_MINOR < 5))
+ #include <llvm/Assembly/AssemblyAnnotationWriter.h>
+ #include <llvm/Analysis/Verifier.h>
+#else // >= 3.5
+ #include <llvm/IR/AssemblyAnnotationWriter.h>
+ #include <llvm/IR/Verifier.h>
+#endif
+
+#if LLVM_VERSION_MAJOR >= 4
+#include <llvm/Bitcode/BitcodeReader.h>
+#include <llvm/Bitcode/BitcodeWriter.h>
+#else
+#include <llvm/Bitcode/ReaderWriter.h>
+#endif
+
+#include <llvm/IR/LLVMContext.h>
+#include <llvm/IR/Module.h>
+#include <llvm/IR/Instructions.h>
+#include <llvm/Support/SourceMgr.h>
+#include <llvm/Support/raw_os_ostream.h>
+#include <llvm/Support/FormattedStream.h>
+#include <llvm/IRReader/IRReader.h>
+#include <llvm/Support/Signals.h>
+#include <llvm/Support/PrettyStackTrace.h>
+#include <llvm/Support/CommandLine.h>
+
+#if (__clang__)
+#pragma clang diagnostic pop // ignore -Wunused-parameter
+#else
+#pragma GCC diagnostic pop
+#endif
+
+#include <iostream>
+#include <fstream>
+
+#include "llvm/LLVMDependenceGraph.h"
+#include "llvm/Slicer.h"
+#include "llvm/LLVMDG2Dot.h"
+#include "TimeMeasure.h"
+
+#include "llvm/analysis/old/PointsTo.h"
+#include "llvm/analysis/old/ReachingDefs.h"
+#include "llvm/analysis/old/DefUse.h"
+
+#include "llvm/analysis/DefUse.h"
+#include "llvm/analysis/PointsTo/PointsTo.h"
+#include "llvm/analysis/ReachingDefinitions/ReachingDefinitions.h"
+
+#include "analysis/PointsTo/PointsToFlowInsensitive.h"
+#include "analysis/PointsTo/PointsToFlowSensitive.h"
+#include "analysis/PointsTo/Pointer.h"
+
+#include "klee/Internal/Analysis/SVFPointerAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/Slicer.h"
+
+using namespace dg;
+using llvm::errs;
+
+enum {
+    // annotate
+    ANNOTATE                    = 1,
+    // data dependencies
+    ANNOTATE_DD                 = 1 << 1,
+    // forward data dependencies
+    ANNOTATE_FORWARD_DD         = 1 << 2,
+    // control dependencies
+    ANNOTATE_CD                 = 1 << 3,
+    // points-to information
+    ANNOTATE_PTR                = 1 << 4,
+    // reaching definitions
+    ANNOTATE_RD                 = 1 << 5,
+    // post-dominators
+    ANNOTATE_POSTDOM            = 1 << 6,
+    // comment out nodes that will be sliced
+    ANNOTATE_SLICE              = 1 << 7,
+};
+
+enum PtaType {
+    old, fs, fi
+};
+
+llvm::cl::OptionCategory SlicingOpts("Slicer options", "");
+
+llvm::cl::opt<std::string> output("o",
+    llvm::cl::desc("Save the output to given file. If not specified,\n"
+                   "a .sliced suffix is used with the original module name."),
+    llvm::cl::value_desc("filename"), llvm::cl::init(""), llvm::cl::cat(SlicingOpts));
+
+//llvm::cl::opt<std::string> llvmfile(llvm::cl::Positional, llvm::cl::Required,
+//    llvm::cl::desc("<input file>"), llvm::cl::init("test"), llvm::cl::cat(SlicingOpts));
+std::string llvmfile = "test";
+
+//llvm::cl::opt<std::string> slicing_criterion("c", llvm::cl::Required,
+//    llvm::cl::desc("Slice with respect to the call-sites of a given function\n"
+//                   "i. e.: '-c foo' or '-c __assert_fail'. Special value is a 'ret'\n"
+//                   "in which case the slice is taken with respect to the return value\n"
+//                   "of the main() function. You can use comma separated list of more\n"
+//                   "function calls, e.g. -c foo,bar\n"), llvm::cl::value_desc("func"),
+//                   llvm::cl::init(""), llvm::cl::cat(SlicingOpts));
+
+llvm::cl::opt<uint64_t> pta_field_sensitivie("pta-field-sensitive",
+    llvm::cl::desc("Make PTA field sensitive/insensitive. The offset in a pointer\n"
+                   "is cropped to UNKNOWN_OFFSET when it is greater than N bytes.\n"
+                   "Default is full field-sensitivity (N = UNKNOWN_OFFSET).\n"),
+                   llvm::cl::value_desc("N"), llvm::cl::init(UNKNOWN_OFFSET),
+                   llvm::cl::cat(SlicingOpts));
+
+llvm::cl::opt<bool> rd_strong_update_unknown("rd-strong-update-unknown",
+    llvm::cl::desc("Let reaching defintions analysis do strong updates on memory defined\n"
+                   "with uknown offset in the case, that new definition overwrites\n"
+                   "the whole memory. May be unsound for out-of-bound access\n"),
+                   llvm::cl::init(false), llvm::cl::cat(SlicingOpts));
+
+llvm::cl::opt<bool> undefined_are_pure("undefined-are-pure",
+    llvm::cl::desc("Assume that undefined functions have no side-effects\n"),
+                   llvm::cl::init(false), llvm::cl::cat(SlicingOpts));
+
+llvm::cl::opt<PtaType> pta("pta",
+    llvm::cl::desc("Choose pointer analysis to use:"),
+    llvm::cl::values(
+        clEnumVal(old , "Old pointer analysis (flow-insensitive, deprecated)"),
+        clEnumVal(fi, "Flow-insensitive PTA (default)"),
+        clEnumVal(fs, "Flow-sensitive PTA")
+#if LLVM_VERSION_MAJOR < 4
+        , nullptr
+#endif
+        ),
+    llvm::cl::init(fi), llvm::cl::cat(SlicingOpts));
+
+llvm::cl::opt<CD_ALG> CdAlgorithm("cd-alg",
+    llvm::cl::desc("Choose control dependencies algorithm to use:"),
+    llvm::cl::values(
+        clEnumValN(CLASSIC , "classic", "Ferrante's algorithm (default)"),
+        clEnumValN(CONTROL_EXPRESSION, "ce", "Control expression based (experimental)")
+#if LLVM_VERSION_MAJOR < 4
+        , nullptr
+#endif
+         ),
+    llvm::cl::init(CLASSIC), llvm::cl::cat(SlicingOpts));
+
+static bool array_match(llvm::StringRef name, const char *names[])
+{
+    unsigned idx = 0;
+    while(names[idx]) {
+        if (name.equals(names[idx]))
+            return true;
+        ++idx;
+    }
+
+    return false;
+}
+
+static bool verify_module(llvm::Module *M)
+{
+    // the verifyModule function returns false if there
+    // are no errors
+
+#if ((LLVM_VERSION_MAJOR >= 4) || (LLVM_VERSION_MINOR >= 5))
+    return !llvm::verifyModule(*M, &llvm::errs());
+#else
+    return !llvm::verifyModule(*M, llvm::PrintMessageAction);
+#endif
+}
+
+static void replace_suffix(std::string& fl, const std::string& with)
+{
+    if (fl.size() > 2) {
+        if (fl.compare(fl.size() - 2, 2, ".o") == 0)
+            fl.replace(fl.end() - 2, fl.end(), with);
+        else if (fl.compare(fl.size() - 3, 3, ".bc") == 0)
+            fl.replace(fl.end() - 3, fl.end(), with);
+        else
+            fl += with;
+    } else {
+        fl += with;
+    }
+}
+static bool write_module(llvm::Module *M)
+{
+    // compose name if not given
+    std::string fl;
+    if (!output.empty()) {
+        fl = output;
+    } else {
+        fl = llvmfile;
+        replace_suffix(fl, ".sliced");
+    }
+
+    // open stream to write to
+    std::ofstream ofs(fl);
+    llvm::raw_os_ostream ostream(ofs);
+
+    // write the module
+    errs() << "INFO: saving sliced module to: " << fl.c_str() << "\n";
+    llvm::WriteBitcodeToFile(M, ostream);
+
+    return true;
+}
+
+static int verify_and_write_module(llvm::Module *M)
+{
+    int code = 1;
+
+    if (!verify_module(M)) {
+        errs() << "ERR: Verifying module failed, the IR is not valid\n";
+        errs() << "INFO: Saving anyway so that you can check it\n";
+    }
+
+    if (!write_module(M)) {
+        errs() << "Saving sliced module failed\n";
+        goto cleanup;
+    }
+
+    code = 0;
+
+cleanup:
+    // exit code
+    return code;
+}
+
+static int save_module(llvm::Module *M,
+                       bool should_verify_module = true)
+{
+    if (should_verify_module)
+        return verify_and_write_module(M);
+    else
+        return write_module(M);
+}
+
+/// --------------------------------------------------------------------
+//   - Slicer class -
+//
+//  The main class that represents slicer and covers the elementary
+//  functionality
+/// --------------------------------------------------------------------
+Slicer::Slicer(
+    llvm::Module *mod,
+    uint32_t o,
+    std::string entryFunction,
+    std::vector<std::string> criterions,
+    LLVMPointerAnalysis *llvmpta,
+    Cloner *cloner
+) :
+    M(mod), 
+    opts(o),
+    entryFunction(entryFunction),
+    criterions(criterions),
+    PTA(llvmpta),
+    RD(
+        new LLVMReachingDefinitions(
+            mod,
+            PTA,
+            rd_strong_update_unknown,
+            undefined_are_pure,
+            ~((uint32_t)(0)),
+            entryFunction
+        )
+    )
+{
+    assert(mod && "Need module");
+    slicer.setCloner(cloner);
+    slice_id = 0xdead;
+}
+
+int Slicer::run()
+{
+    if (!M) {
+        llvm::errs() << "Failed parsing '" << llvmfile << "' file:\n";
+        return 1;
+    }
+
+    // remove unused from module, we don't need that
+    //remove_unused_from_module_rec();
+
+    // build the dependence graph, so that we can dump it if desired
+    if (!buildDG()) {
+        errs() << "ERROR: Failed building DG\n";
+        return 1;
+    }
+
+    // mark nodes that are going to be in the slice
+    mark();
+
+    // slice the graph
+    if (!slice()) {
+        errs() << "ERROR: Slicing failed\n";
+        return 1;
+    }
+
+    // remove unused from module again, since slicing
+    // could and probably did make some other parts unused
+    //remove_unused_from_module_rec();
+
+    // fix linkage of declared functions (if needs to be fixed)
+    make_declarations_external();
+
+    return save_module(M, false);
+}
+
+bool Slicer::buildDG()
+{
+    debug::TimeMeasure tm;
+
+    tm.start();
+
+    //PTA->PS->setRoot(PTA->builder->buildLLVMPointerSubgraph());
+    //SVFPointerAnalysis *pa = new SVFPointerAnalysis(M, PTA.get(), svfaa);
+    //pa->run();
+
+    tm.stop();
+    tm.report("INFO: Points-to analysis took");
+
+    dg.build(M, PTA, M->getFunction(entryFunction));
+
+    // verify if the graph is built correctly
+    // FIXME - do it optionally (command line argument)
+    if (!dg.verify()) {
+        errs() << "ERR: verifying failed\n";
+        return false;
+    }
+
+    return true;
+}
+
+bool Slicer::mark()
+{
+    debug::TimeMeasure tm;
+    std::set<LLVMNode *> callsites;
+
+    assert(!criterions.empty() && "Do not have the slicing criterion");
+
+    for (std::string c : criterions) {
+        if (c == "ret") {
+            callsites.insert(dg.getExit());
+        }
+    }
+
+    // check for slicing criterion here, because
+    // we might have built new subgraphs that contain
+    // it during points-to analysis
+    bool ret = dg.getCallSites(criterions, &callsites);
+    got_slicing_criterion = true;
+    if (!ret) {
+        errs() << "Did not find slicing criterion:\n";
+        for (std::string c : criterions) {
+          errs() << "\tmissing criterion: " << c << "\n";
+        }
+        got_slicing_criterion = false;
+    }
+
+    // if we found slicing criterion, compute the rest
+    // of the graph. Otherwise just slice away the whole graph
+    // Also compute the edges when the user wants to annotate
+    // the file - due to debugging.
+    if (got_slicing_criterion || (opts & ANNOTATE))
+        computeEdges();
+
+    // don't go through the graph when we know the result:
+    // only empty main will stay there. Just delete the body
+    // of main and keep the return value
+    if (!got_slicing_criterion) {
+        /* TODO: decide what to do... */
+        return 0;
+    }
+
+    /* TODO: check what happens with the slicing... */
+    // we also do not want to remove any assumptions
+    // about the code
+    // FIXME: make it configurable and add control dependencies
+    // for these functions, so that we slice away the
+    // unneeded one
+    const char *sc[] = {
+        "__VERIFIER_assume",
+        "__VERIFIER_exit",
+        //"klee_assume",
+        "exit",
+        /* these are needed, otherwise vprintf crashes... */
+        "llvm.va_start",
+        "llvm.va_end",
+        NULL // termination
+    };
+
+    dg.getCallSites(sc, &callsites);
+
+    // FIXME: do this optional
+    /* TODO: add klee_* functions */
+    slicer.keepFunctionUntouched("__VERIFIER_assume");
+    slicer.keepFunctionUntouched("__VERIFIER_exit");
+    //slice_id = 1; //0xdead;
+
+    tm.start();
+    for (LLVMNode *start : callsites) {
+        slice_id = slicer.mark(start, slice_id);
+    }
+
+    tm.stop();
+    tm.report("INFO: Finding dependent nodes took");
+
+    return true;
+}
+
+void Slicer::computeEdges()
+{
+    debug::TimeMeasure tm;
+    assert(PTA && "BUG: No PTA");
+    assert(RD && "BUG: No RD");
+
+    tm.start();
+    RD->run();
+    tm.stop();
+    tm.report("INFO: Reaching defs analysis took");
+
+    LLVMDefUseAnalysis DUA(&dg, RD.get(), PTA, undefined_are_pure);
+    tm.start();
+    DUA.run(); // add def-use edges according that
+    tm.stop();
+    tm.report("INFO: Adding Def-Use edges took");
+
+    tm.start();
+    // add post-dominator frontiers
+    dg.computeControlDependencies(CdAlgorithm);
+    tm.stop();
+    tm.report("INFO: Computing control dependencies took");
+}
+
+bool Slicer::slice()
+{
+    // we created an empty main in this case
+    if (!got_slicing_criterion)
+        return true;
+
+    if (slice_id == 0) {
+        if (!mark())
+            return false;
+    }
+
+    debug::TimeMeasure tm;
+
+    tm.start();
+    slicer.slice(&dg, nullptr, slice_id);
+
+    tm.stop();
+    tm.report("INFO: Slicing dependence graph took");
+
+    analysis::SlicerStatistics& st = slicer.getStatistics();
+    errs() << "INFO: Sliced away " << st.nodesRemoved
+        << " from " << st.nodesTotal << " nodes in DG\n";
+
+    return true;
+}
+
+/* TODO: may collide with the reachability analysis? */
+void Slicer::remove_unused_from_module_rec()
+{
+    bool fixpoint;
+
+    do {
+        fixpoint = remove_unused_from_module();
+    } while (fixpoint);
+}
+
+bool Slicer::remove_unused_from_module()
+{
+    using namespace llvm;
+    // do not slice away these functions no matter what
+    // FIXME do it a vector and fill it dynamically according
+    // to what is the setup (like for sv-comp or general..)
+    const char *keep[] = {"main", "klee_assume", NULL};
+
+    // when erasing while iterating the slicer crashes
+    // so set the to be erased values into container
+    // and then erase them
+    std::set<Function *> funs;
+    std::set<GlobalVariable *> globals;
+    std::set<GlobalAlias *> aliases;
+    auto cf = getConstructedFunctions();
+
+    for (auto I = M->begin(), E = M->end(); I != E; ++I) {
+        Function *func = &*I;
+        if (array_match(func->getName(), keep))
+            continue;
+
+        // if the function is unused or we haven't constructed it
+        // at all in dependence graph, we can remove it
+        // (it may have some uses though - like when one
+        // unused func calls the other unused func
+        if (func->hasNUses(0))
+            funs.insert(func);
+    }
+
+    for (auto I = M->global_begin(), E = M->global_end(); I != E; ++I) {
+        GlobalVariable *gv = &*I;
+        if (gv->hasNUses(0))
+            globals.insert(gv);
+    }
+
+    for (GlobalAlias& ga : M->getAliasList()) {
+        if (ga.hasNUses(0))
+            aliases.insert(&ga);
+    }
+
+    for (Function *f : funs)
+        f->eraseFromParent();
+    for (GlobalVariable *gv : globals)
+        gv->eraseFromParent();
+    for (GlobalAlias *ga : aliases)
+        ga->eraseFromParent();
+
+    return (!funs.empty() || !globals.empty() || !aliases.empty());
+}
+
+// after we slice the LLVM, we somethimes have troubles
+// with function declarations:
+//
+//   Global is external, but doesn't have external or dllimport or weak linkage!
+//   i32 (%struct.usbnet*)* @always_connected
+//   invalid linkage type for function declaration
+//
+// This function makes the declarations external
+void Slicer::make_declarations_external()
+{
+    using namespace llvm;
+
+    // iterate over all functions in module
+    for (auto I = M->begin(), E = M->end(); I != E; ++I) {
+        Function *func = &*I;
+        if (func->size() == 0) {
+            // this will make sure that the linkage has right type
+            func->deleteBody();
+        }
+    }
+}
+
+Slicer::~Slicer() {
+    clearConstructedFunctions();
+}
diff --git a/lib/Basic/CMakeLists.txt b/lib/Basic/CMakeLists.txt
index d0a309c..d4ea43f 100644
--- a/lib/Basic/CMakeLists.txt
+++ b/lib/Basic/CMakeLists.txt
@@ -27,3 +27,8 @@ target_link_libraries(kleeBasic PRIVATE
   # of this because `kleaverSolver` depends on `kleeBasic`.
   kleaverSolver
 )
+target_include_directories(kleeBasic PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index 8a07493..f8cf1f1 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -6,6 +6,7 @@
 # License. See LICENSE.TXT for details.
 #
 #===------------------------------------------------------------------------===#
+add_subdirectory(Analysis)
 add_subdirectory(Basic)
 add_subdirectory(Support)
 add_subdirectory(Expr)
diff --git a/lib/Core/ASContext.cpp b/lib/Core/ASContext.cpp
new file mode 100644
index 0000000..831273d
--- /dev/null
+++ b/lib/Core/ASContext.cpp
@@ -0,0 +1,61 @@
+#include "klee/ASContext.h"
+#include "klee/Internal/Module/KInstruction.h"
+#include "klee/Internal/Module/KModule.h"
+#include "klee/Internal/Support/ErrorHandling.h"
+#include "klee/Internal/Support/Debug.h"
+
+#include "llvm/IR/Instruction.h"
+
+#include "klee/Internal/Analysis/Cloner.h"
+
+#include <vector>
+
+using namespace llvm;
+using namespace klee;
+
+ASContext::ASContext(Cloner *cloner, std::vector<Instruction *> &callTrace, Instruction *allocInst) {
+    refCount = 0;
+
+    for (std::vector<Instruction *>::iterator i = callTrace.begin(); i != callTrace.end(); i++) {
+        Instruction *inst = *i;
+        trace.push_back(getTranslatedInst(cloner, inst));
+    }
+
+    trace.push_back(getTranslatedInst(cloner, allocInst));
+}
+
+ASContext::ASContext(ASContext &other) :
+    refCount(0),
+    trace(other.trace)    
+{
+
+}
+
+/* TODO: use the translatedValue API? */
+Instruction *ASContext::getTranslatedInst(Cloner *cloner, Instruction *inst) {
+    Value *value = cloner->translateValue(inst);
+    if (!isa<Instruction>(value)) {
+        /* why... */
+        llvm_unreachable("Translated value is not an instruction");
+    }
+
+    return dyn_cast<Instruction>(value);
+}
+
+void ASContext::dump() {
+    DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("allocation site context:"));
+    for (std::vector<Instruction *>::iterator i = trace.begin(); i != trace.end(); i++) {
+        Instruction *inst = *i;
+        Function *f = inst->getParent()->getParent();
+        DEBUG_WITH_TYPE(DEBUG_BASIC, errs() << "  -- " << f->getName() << ":");
+        DEBUG_WITH_TYPE(DEBUG_BASIC, inst->dump());
+    }
+}
+
+bool ASContext::operator==(ASContext &other) {
+    return trace == other.trace;
+}
+
+bool ASContext::operator!=(ASContext &other) {
+    return !(*this == other);
+}
diff --git a/lib/Core/AllocationRecord.cpp b/lib/Core/AllocationRecord.cpp
new file mode 100644
index 0000000..e17a532
--- /dev/null
+++ b/lib/Core/AllocationRecord.cpp
@@ -0,0 +1,152 @@
+#include "Memory.h"
+#include "klee/ASContext.h"
+#include "klee/AllocationRecord.h"
+#include "klee/Internal/Support/ErrorHandling.h"
+#include "klee/Internal/Support/Debug.h"
+
+#include "llvm/Support/ErrorHandling.h"
+
+#include <map>
+#include <list>
+
+using namespace llvm;
+
+namespace klee {
+
+class MemoryObject;
+
+AllocationRecord::AllocationRecord(const AllocationRecord &other) :
+    record(other.record)
+{
+    incRefCount();
+}
+
+AllocationRecord &AllocationRecord::operator=(const AllocationRecord &other) {
+    if (this != &other) {
+        record = other.record;
+        incRefCount();
+    }
+    return *this;
+}
+
+/* TODO: may have some problems with the destructor of ExecutionState (refCount) */
+AllocationRecord::~AllocationRecord() {
+    decRefCount();
+}
+
+void AllocationRecord::incRefCount() {
+    for (Record::iterator i = record.begin(); i != record.end(); i++) {
+        Entry &entry = *i;
+        std::list<MemoryObject *> &memoryObjects = entry.second;
+        for (std::list<MemoryObject *>::iterator j = memoryObjects.begin(); j != memoryObjects.end(); j++) {
+            MemoryObject *mo = *j;
+            if (!mo) {
+                continue;
+            }
+
+            mo->refCount++;
+        }
+    }
+}
+
+void AllocationRecord::decRefCount() {
+    for (Record::iterator i = record.begin(); i != record.end(); i++) {
+        Entry &entry = *i;
+        std::list<MemoryObject *> &memoryObjects = entry.second;
+        for (std::list<MemoryObject *>::iterator j = memoryObjects.begin(); j != memoryObjects.end(); j++) {
+            MemoryObject *mo = *j;
+            if (!mo) {
+                continue;
+            }
+
+            assert(mo->refCount > 0);
+            mo->refCount--;
+            if (mo->refCount == 0) {
+                delete mo;
+            }
+        }
+    }
+}
+
+void AllocationRecord::addAddr(ASContext &context, MemoryObject *mo) {
+    Entry *entry = find(context);
+    if (!entry) {
+        ref<ASContext> c(new ASContext(context));
+        std::list<MemoryObject *> q;
+        q.push_back(mo);
+        record.push_back(std::make_pair(c, q));
+    } else {
+        std::list<MemoryObject *> &q = entry->second;
+        q.push_back(mo);
+    }
+
+    if (mo) {
+        mo->refCount++;
+    }
+}
+
+MemoryObject *AllocationRecord::getAddr(ASContext &context) {
+    Entry *entry = find(context);
+    if (entry == NULL) {
+      llvm_unreachable("Could not find any entry for the context");
+    }
+    
+    std::list<MemoryObject *> &q = entry->second;
+    if (q.empty()) {
+      llvm_unreachable("Could not find any MemoryObject for the context");
+    }
+
+    MemoryObject *mo = q.front();
+    q.pop_front();
+
+    if (mo) {
+        /* TODO: check reference count... */
+        mo->refCount--;
+    }
+
+    return mo;
+}
+
+bool AllocationRecord::exists(ASContext &context) {
+    return find(context) != NULL; 
+}
+
+AllocationRecord::Entry *AllocationRecord::find(ASContext &context) {
+    for (Record::iterator i = record.begin(); i != record.end(); i++) {
+        Entry &entry = *i;
+        if (*entry.first == context) {
+            return &entry;
+        }
+    }
+
+    return NULL;
+}
+
+void AllocationRecord::dump() {
+    if (record.empty()) {
+        DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("allocation record is empty"));
+    } else {
+        DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("allocation record:"));
+        for (Record::iterator i = record.begin(); i != record.end(); i++) {
+            Entry &entry = *i;
+
+            /* dump context */
+            ref<ASContext> c = entry.first;
+            c->dump();
+
+            /* dump addresses */
+            MemoryObjectList &memoryObjects = entry.second;
+            DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("memory objects:"));
+            for (MemoryObjectList::iterator j = memoryObjects.begin(); j != memoryObjects.end(); j++) {
+                MemoryObject *mo = *j;
+                if (mo) {
+                    DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("-- %lx", mo->address));
+                } else {
+                    DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("-- null"));
+                }
+            }
+        }
+    }
+}
+
+}
diff --git a/lib/Core/CMakeLists.txt b/lib/Core/CMakeLists.txt
index 86ce3cf..f812164 100644
--- a/lib/Core/CMakeLists.txt
+++ b/lib/Core/CMakeLists.txt
@@ -26,6 +26,8 @@ klee_add_component(kleeCore
   StatsTracker.cpp
   TimingSolver.cpp
   UserSearcher.cpp
+  ASContext.cpp
+  AllocationRecord.cpp
 )
 
 # TODO: Work out what the correct LLVM components are for
@@ -45,7 +47,13 @@ endif()
 
 klee_get_llvm_libs(LLVM_LIBS ${LLVM_COMPONENTS})
 target_link_libraries(kleeCore PUBLIC ${LLVM_LIBS})
+target_include_directories(kleeCore PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
 target_link_libraries(kleeCore PRIVATE
+  kleeAnalysis
   kleeBasic
   kleeModule
   kleaverSolver
diff --git a/lib/Core/ExecutionState.cpp b/lib/Core/ExecutionState.cpp
index 30d2026..1b40874 100644
--- a/lib/Core/ExecutionState.cpp
+++ b/lib/Core/ExecutionState.cpp
@@ -67,6 +67,23 @@ StackFrame::~StackFrame() {
 /***/
 
 ExecutionState::ExecutionState(KFunction *kf) :
+    /* TODO: fix? */
+    refCount(0),
+    type(NORMAL_STATE),
+
+    /* state properties */
+    suspendStatus(false),
+    recoveryState(0),
+    blockingLoadStatus(true),
+
+    /* recovery state properties */
+    exitInst(0),
+    dependentState(0),
+    originatingState(0),
+    recoveryInfo(0),
+    level(0),
+    priority(PRIORITY_LOW),
+
     pc(kf->instructions),
     prevPC(pc),
 
@@ -98,7 +115,33 @@ ExecutionState::~ExecutionState() {
 }
 
 ExecutionState::ExecutionState(const ExecutionState& state):
+    refCount(0),
     fnAliases(state.fnAliases),
+
+    type(state.type),
+
+    /* state properties */
+    suspendStatus(state.suspendStatus),
+    snapshots(state.snapshots),
+    recoveryState(state.recoveryState),
+    blockingLoadStatus(state.blockingLoadStatus),
+    recoveredLoads(state.recoveredLoads),
+    allocationRecord(state.allocationRecord),
+    /* TODO: copy only for originating states */
+    //guidingConstraints(state.guidingConstraints),
+    writtenAddresses(state.writtenAddresses),
+    pendingRecoveryInfos(state.pendingRecoveryInfos),
+    recoveryCache(state.recoveryCache),
+
+    /* recovery state properties */
+    exitInst(state.exitInst),
+    dependentState(state.dependentState),
+    originatingState(state.originatingState),
+    recoveryInfo(state.recoveryInfo),
+    guidingAllocationRecord(state.guidingAllocationRecord),
+    level(state.level),
+    priority(state.priority),
+
     pc(state.pc),
     prevPC(state.prevPC),
     stack(state.stack),
@@ -124,6 +167,11 @@ ExecutionState::ExecutionState(const ExecutionState& state):
 {
   for (unsigned int i=0; i<symbolics.size(); i++)
     symbolics[i].first->refCount++;
+
+  /* TODO: possibly not required if snapshots are cleared */
+  if (isNormalState() && !isRecoveryState()) {
+    guidingConstraints = state.guidingConstraints;
+  }
 }
 
 ExecutionState *ExecutionState::branch() {
@@ -136,6 +184,13 @@ ExecutionState *ExecutionState::branch() {
   weight *= .5;
   falseState->weight -= weight;
 
+  /* TODO remove assertions */
+  if (this->isNormalState()) {
+    assert(falseState->isNormalState() && "false state is not a normal state");
+  } else {
+    assert(falseState->isRecoveryState() && "false state is not a recovery state");
+  }
+
   return falseState;
 }
 
@@ -381,3 +436,17 @@ void ExecutionState::dumpStack(llvm::raw_ostream &out) const {
     target = sf.caller;
   }
 }
+
+void ExecutionState::getCallTrace(std::vector<Instruction *> &callTrace) {
+    for (std::vector<StackFrame>::iterator i = stack.begin(); i != stack.end(); i++) {
+        StackFrame sf = *i;
+
+        /* skip the main frame */
+        if (sf.kf->function->getName() == "main") {
+            continue;
+        }
+
+        Instruction *inst = sf.caller->inst;
+        callTrace.push_back(inst);
+    }
+}
diff --git a/lib/Core/Executor.cpp b/lib/Core/Executor.cpp
index c369b86..66c77ca 100644
--- a/lib/Core/Executor.cpp
+++ b/lib/Core/Executor.cpp
@@ -30,6 +30,7 @@
 #include "klee/TimerStatIncrementer.h"
 #include "klee/CommandLine.h"
 #include "klee/Common.h"
+#include "klee/ASContext.h"
 #include "klee/util/Assignment.h"
 #include "klee/util/ExprPPrinter.h"
 #include "klee/util/ExprSMTLIBPrinter.h"
@@ -46,6 +47,7 @@
 #include "klee/Internal/Support/FloatEvaluation.h"
 #include "klee/Internal/System/Time.h"
 #include "klee/Internal/System/MemoryUsage.h"
+#include "klee/Internal/Support/Debug.h"
 #include "klee/SolverStats.h"
 
 #if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
@@ -60,6 +62,7 @@
 #include "llvm/IR/Module.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/TypeBuilder.h"
+#include "llvm/IR/User.h"
 #else
 #include "llvm/Attributes.h"
 #include "llvm/BasicBlock.h"
@@ -89,6 +92,15 @@
 #include "llvm/IR/CallSite.h"
 #endif
 
+#include "llvm/PassManager.h"
+
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
 #ifdef HAVE_ZLIB_H
 #include "klee/Internal/Support/CompressionStream.h"
 #endif
@@ -119,7 +131,7 @@ namespace {
   DumpStatesOnHalt("dump-states-on-halt",
                    cl::init(true),
 		   cl::desc("Dump test cases for all active states on exit (default=on)"));
-  
+
   cl::opt<bool>
   AllowExternalSymCalls("allow-external-sym-calls",
                         cl::init(false),
@@ -290,10 +302,17 @@ namespace {
 		    clEnumValEnd),
 		  cl::ZeroOrMore);
 
+#if LLVM_VERSION_CODE < LLVM_VERSION(3, 0)
   cl::opt<unsigned int>
   StopAfterNInstructions("stop-after-n-instructions",
                          cl::desc("Stop execution after specified number of instructions (default=0 (off))"),
                          cl::init(0));
+#else
+  cl::opt<unsigned long long>
+  StopAfterNInstructions("stop-after-n-instructions",
+                         cl::desc("Stop execution after specified number of instructions (default=0 (off))"),
+                         cl::init(0));
+#endif
   
   cl::opt<unsigned>
   MaxForks("max-forks",
@@ -314,6 +333,22 @@ namespace {
   MaxMemoryInhibit("max-memory-inhibit",
             cl::desc("Inhibit forking at memory cap (vs. random terminate) (default=on)"),
             cl::init(true));
+
+  // CHASER options
+
+  cl::opt<bool>
+  PrintFunctionCalls("print-functions", cl::init(false),
+                     cl::desc("Print function calls (default=off)"));
+
+  cl::opt<bool>
+  LazySlicing("lazy-slicing", cl::init(true),
+              cl::desc("Lazy slicing of skipped functions (default=on)"));
+
+  llvm::cl::opt<bool> UseSlicer("use-slicer",
+                                llvm::cl::desc("Slice skipped functions"),
+                                llvm::cl::init(true));
+
+  llvm::cl::opt<bool> UseRecoveryCache("use-recovery-cache", cl::init(true), cl::desc(""));
 }
 
 
@@ -336,7 +371,9 @@ const char *Executor::TerminateReasonNames[] = {
   [ Unhandled ] = "xxx",
 };
 
-Executor::Executor(const InterpreterOptions &opts, InterpreterHandler *ih)
+#define HUGE_ALLOC_SIZE (1U << 31)
+
+Executor::Executor(InterpreterOptions &opts, InterpreterHandler *ih)
     : Interpreter(opts), kmodule(0), interpreterHandler(ih), searcher(0),
       externalDispatcher(new ExternalDispatcher()), statsTracker(0),
       pathWriter(0), symPathWriter(0), specialFunctionHandler(0),
@@ -346,7 +383,9 @@ Executor::Executor(const InterpreterOptions &opts, InterpreterHandler *ih)
       coreSolverTimeout(MaxCoreSolverTime != 0 && MaxInstructionTime != 0
                             ? std::min(MaxCoreSolverTime, MaxInstructionTime)
                             : std::max(MaxCoreSolverTime, MaxInstructionTime)),
-      debugInstFile(0), debugLogBuffer(debugBufferString) {
+      debugInstFile(0), debugLogBuffer(debugBufferString),
+      errorCount(0),
+      logFile(0) {
 
   if (coreSolverTimeout) UseForkedCoreSolver = true;
   Solver *coreSolver = klee::createCoreSolver(CoreSolverToUse);
@@ -392,6 +431,13 @@ Executor::Executor(const InterpreterOptions &opts, InterpreterHandler *ih)
                  ErrorInfo.c_str());
     }
   }
+
+  ra = NULL;
+  inliner = NULL;
+  aa = NULL;
+  mra = NULL;
+  cloner = NULL;
+  sliceGenerator = NULL;
 }
 
 
@@ -400,7 +446,7 @@ const Module *Executor::setModule(llvm::Module *module,
   assert(!kmodule && module && "can only register one module"); // XXX gross
   
   kmodule = new KModule(module);
-
+  
   // Initialize the context.
 #if LLVM_VERSION_CODE <= LLVM_VERSION(3, 1)
   TargetData *TD = kmodule->targetData;
@@ -411,9 +457,31 @@ const Module *Executor::setModule(llvm::Module *module,
                       (Expr::Width) TD->getPointerSizeInBits());
 
   specialFunctionHandler = new SpecialFunctionHandler(*this);
-
   specialFunctionHandler->prepare();
-  kmodule->prepare(opts, interpreterHandler);
+
+  if (!interpreterOpts.skippedFunctions.empty()) {
+    /* build target functions */
+    std::vector<std::string> targets;
+    for (auto i = interpreterOpts.skippedFunctions.begin(), e = interpreterOpts.skippedFunctions.end(); i != e; i++) {
+      targets.push_back(i->name);
+    }
+
+    logFile = interpreterHandler->openOutputFile("sa.log");
+
+    ra = new ReachabilityAnalysis(module, opts.EntryPoint, targets, *logFile);
+    inliner = new Inliner(module, ra, targets, interpreterOpts.inlinedFunctions, *logFile);
+    aa = new AAPass();
+    aa->setPAType(PointerAnalysis::Andersen_WPA);
+
+    mra = new ModRefAnalysis(kmodule->module, ra, aa, opts.EntryPoint, targets, *logFile);
+    cloner = new Cloner(module, ra, *logFile);
+    if (UseSlicer) {
+      sliceGenerator = new SliceGenerator(module, ra, aa, mra, cloner, *logFile, LazySlicing);
+    }
+  }
+
+  kmodule->prepare(opts, interpreterOpts.skippedFunctions, interpreterHandler, ra, inliner, aa, mra, cloner, sliceGenerator);
+
   specialFunctionHandler->bind();
 
   if (StatsTracker::useStatistics() || userSearcherRequiresMD2U()) {
@@ -422,7 +490,7 @@ const Module *Executor::setModule(llvm::Module *module,
                        interpreterHandler->getOutputFilename("assembly.ll"),
                        userSearcherRequiresMD2U());
   }
-  
+
   return module;
 }
 
@@ -436,6 +504,12 @@ Executor::~Executor() {
   if (statsTracker)
     delete statsTracker;
   delete solver;
+  /* TODO: is it the right place? */
+  if (sliceGenerator) delete sliceGenerator;
+  if (cloner) delete cloner;
+  if (mra) delete mra;
+  if (inliner) delete inliner;
+  if (ra) delete ra;
   delete kmodule;
   while(!timers.empty()) {
     delete timers.back();
@@ -444,6 +518,9 @@ Executor::~Executor() {
   if (debugInstFile) {
     delete debugInstFile;
   }
+  if (logFile) {
+    delete logFile;
+  }
 }
 
 /***/
@@ -679,6 +756,7 @@ void Executor::branch(ExecutionState &state,
                       const std::vector< ref<Expr> > &conditions,
                       std::vector<ExecutionState*> &result) {
   TimerStatIncrementer timer(stats::forkTime);
+
   unsigned N = conditions.size();
   assert(N);
 
@@ -699,6 +777,9 @@ void Executor::branch(ExecutionState &state,
     for (unsigned i=1; i<N; ++i) {
       ExecutionState *es = result[theRNG.getInt32() % i];
       ExecutionState *ns = es->branch();
+      if (ns->isRecoveryState()) {
+        interpreterHandler->incRecoveryStatesCount();
+      }
       addedStates.push_back(ns);
       result.push_back(ns);
       es->ptreeNode->data = 0;
@@ -756,9 +837,35 @@ void Executor::branch(ExecutionState &state,
     }
   }
 
-  for (unsigned i=0; i<N; ++i)
-    if (result[i])
-      addConstraint(*result[i], conditions[i]);
+  /* handle the forks */
+  for (unsigned i=0; i<N; ++i) {
+    ExecutionState *current = result[i];
+    if (current) {
+      if (current->isRecoveryState()) {
+        if (i != 0) {
+          /* here we must fork the dependent state */
+          DEBUG_WITH_TYPE(
+            DEBUG_BASIC,
+            klee_message("forked recovery state (switch): %p", current)
+          );
+          ExecutionState *prev = result[i - 1];
+          forkDependentStates(prev, current);
+        }
+      }
+    }
+  }
+
+  /* handle the constraints */
+  for (unsigned i=0; i<N; ++i) {
+    ExecutionState *current = result[i];
+    if (current) {
+      ref<Expr> condition = conditions[i];
+      addConstraint(*current, condition);
+      if (current->isRecoveryState()) {
+        mergeConstraintsForAll(*current, condition);
+      }
+    }
+  }
 }
 
 Executor::StatePair 
@@ -912,12 +1019,19 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
     return StatePair(0, &current);
   } else {
     TimerStatIncrementer timer(stats::forkTime);
-    ExecutionState *falseState, *trueState = &current;
+    ExecutionState *falseState = NULL, *trueState = &current;
+    ref<Expr> negatedCondition = Expr::createIsZero(condition);
 
     ++stats::forks;
-
     falseState = trueState->branch();
     addedStates.push_back(falseState);
+    if (trueState->isRecoveryState()) {
+      DEBUG_WITH_TYPE(
+        DEBUG_BASIC,
+        klee_message("forked recovery state: %p", falseState)
+      );
+      interpreterHandler->incRecoveryStatesCount();
+    }
 
     if (it != seedMap.end()) {
       std::vector<SeedInfo> seeds = it->second;
@@ -961,20 +1075,21 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
 
     if (!isInternal) {
       if (pathWriter) {
-        falseState->pathOS = pathWriter->open(current.pathOS);
         trueState->pathOS << "1";
+        falseState->pathOS = pathWriter->open(current.pathOS);
         falseState->pathOS << "0";
       }      
       if (symPathWriter) {
-        falseState->symPathOS = symPathWriter->open(current.symPathOS);
         trueState->symPathOS << "1";
+        falseState->symPathOS = symPathWriter->open(current.symPathOS);
         falseState->symPathOS << "0";
       }
     }
 
     addConstraint(*trueState, condition);
-    addConstraint(*falseState, Expr::createIsZero(condition));
+    addConstraint(*falseState, negatedCondition);
 
+    /* TODO: handle termination of recovery states... */
     // Kinda gross, do we even really still want this option?
     if (MaxDepth && MaxDepth<=trueState->depth) {
       terminateStateEarly(*trueState, "max-depth exceeded.");
@@ -982,6 +1097,14 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
       return StatePair(0, 0);
     }
 
+    if (trueState->isRecoveryState()) {
+      forkDependentStates(trueState, falseState);
+
+      /* propagate constraints if required */
+      mergeConstraintsForAll(*trueState, condition);
+      mergeConstraintsForAll(*falseState, negatedCondition);
+    }
+
     return StatePair(trueState, falseState);
   }
 }
@@ -1255,6 +1378,10 @@ void Executor::executeCall(ExecutionState &state,
                            Function *f,
                            std::vector< ref<Expr> > &arguments) {
   Instruction *i = ki->inst;
+
+  if (f && PrintFunctionCalls)
+    klee_message("Function: %s", f->getName().str().c_str());
+
   if (f && f->isDeclaration()) {
     switch(f->getIntrinsicID()) {
     case Intrinsic::not_intrinsic:
@@ -1300,6 +1427,10 @@ void Executor::executeCall(ExecutionState &state,
       }
       break;
     }
+    // FIXME: terrible hack to fix an issue with inlining of memcpy
+    case Intrinsic::lifetime_start:
+    case Intrinsic::lifetime_end:
+    // FIXME: terrible hack end
     case Intrinsic::vaend:
       // va_end is a noop for the interpreter.
       //
@@ -1323,6 +1454,60 @@ void Executor::executeCall(ExecutionState &state,
     // guess. This just done to avoid having to pass KInstIterator everywhere
     // instead of the actual instruction, since we can't make a KInstIterator
     // from just an instruction (unlike LLVM).
+
+    /* TODO: make it more readable... */
+    if (state.isNormalState() && !state.isRecoveryState() && isFunctionToSkip(state, f)) {
+      /* first, check if the skipped function has side effects */
+      if (mra->hasSideEffects(f)) {
+        /* create snapshot, recovery state will be created on demand... */
+        unsigned int index = state.getSnapshots().size();
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message("%p: adding snapshot (index = %u)", &state, index)
+        );
+        ref<ExecutionState> snapshotState(createSnapshotState(state));
+        ref<Snapshot> snapshot(new Snapshot(snapshotState, f));
+        state.addSnapshot(snapshot);
+        interpreterHandler->incSnapshotsCount();
+
+        /* TODO: will be replaced later... */
+        state.clearRecoveredAddresses();
+
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message("%p: skipping function call to %s", &state, f->getName().data())
+        );
+      }
+      return;
+    }
+
+    /* inject the sliced function if needed */
+    if (state.isRecoveryState()) {
+      ref<RecoveryInfo> recoveryInfo = state.getRecoveryInfo();
+      if (UseSlicer) {
+        f = getSlice(f, recoveryInfo->sliceId, ModRefAnalysis::Modifier);
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message("injecting slice: %s", f->getName().data())
+        );
+
+        /* handle fully sliced functions */
+        if (f->isDeclaration()) {
+          DEBUG_WITH_TYPE(
+            DEBUG_BASIC,
+            klee_message("ignoring fully sliced function: %s", f->getName().data())
+          );
+          return;
+        }
+      } else {
+        /* we do it for consistent debugging... */
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message("injecting: %s", f->getName().data())
+        );
+      }
+    }
+
     KFunction *kf = kmodule->functionMap[f];
     state.pushFrame(state.prevPC, kf);
     state.pc = kf->instructions;
@@ -1514,6 +1699,12 @@ static inline const llvm::fltSemantics * fpWidthToSemantics(unsigned width) {
 
 void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
   Instruction *i = ki->inst;
+  /* TODO: replace with a better predicate (call stack counter?) */
+  if (state.isRecoveryState() && state.getExitInst() == i) {
+    onRecoveryStateExit(state);
+    return;
+  }
+
   switch (i->getOpcode()) {
     // Control flow
   case Instruction::Ret: {
@@ -1772,6 +1963,11 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     Value *fp = cs.getCalledValue();
     Function *f = getTargetFunction(fp, state);
 
+    /* skip slicing annotations */
+    if (f && f->getName().startswith(StringRef("__crit"))) {
+        break;
+    }
+
     // Skip debug intrinsics, we can't evaluate their metadata arguments.
     if (f && isDebugIntrinsic(f, kmodule))
       break;
@@ -2108,6 +2304,20 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
   }
 
   case Instruction::Load: {
+    if (state.isNormalState() && state.isInDependentMode()) {
+      if (state.isBlockingLoadRecovered() && isMayBlockingLoad(state, ki)) {
+        /* TODO: rename variable */
+        bool success;
+        bool isBlocking = handleMayBlockingLoad(state, ki, success);
+        if (!success) {
+          return;
+        }
+        if (isBlocking) {
+          /* TODO: break? */
+          return;
+        }
+      }
+    }
     ref<Expr> base = eval(ki, 0, state).value;
     executeMemoryOperation(state, false, base, 0, ki);
     break;
@@ -2558,7 +2768,32 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
 
 void Executor::updateStates(ExecutionState *current) {
   if (searcher) {
-    searcher->update(current, addedStates, removedStates);
+    if (!removedStates.empty()) {
+        /* we don't want to pass suspended states to the searcher */
+        std::vector<ExecutionState *> filteredStates;
+        for (std::vector<ExecutionState *>::iterator i = removedStates.begin(); i != removedStates.end(); i++) {
+            ExecutionState *removedState = *i;
+            if (removedState->isNormalState() && removedState->isSuspended()) {
+                continue;
+            }
+            filteredStates.push_back(removedState);
+        }
+        searcher->update(current, addedStates, filteredStates);
+    } else {
+        searcher->update(current, addedStates, removedStates);
+    }
+
+    /* handle suspended states */
+    for (std::vector<ExecutionState *>::iterator i = suspendedStates.begin(); i != suspendedStates.end(); i++) {
+      searcher->removeState(*i);
+    }
+    suspendedStates.clear();
+
+    /* handle resumed states */
+    for (std::vector<ExecutionState *>::iterator i = resumedStates.begin(); i != resumedStates.end(); i++) {
+      searcher->addState(*i);
+    }
+    resumedStates.clear();
   }
   
   states.insert(addedStates.begin(), addedStates.end());
@@ -2569,8 +2804,13 @@ void Executor::updateStates(ExecutionState *current) {
        it != ie; ++it) {
     ExecutionState *es = *it;
     std::set<ExecutionState*>::iterator it2 = states.find(es);
-    assert(it2!=states.end());
-    states.erase(it2);
+    if (it2 == states.end()) {
+      /* TODO: trying to handle removal of suspended states. Find a better solution... */
+      assert(es->isNormalState() && es->isSuspended());
+      continue;
+    } else {
+      states.erase(it2);
+    }
     std::map<ExecutionState*, std::vector<SeedInfo> >::iterator it3 = 
       seedMap.find(es);
     if (it3 != seedMap.end())
@@ -2618,7 +2858,7 @@ void Executor::bindInstructionConstants(KInstruction *KI) {
   KGEPInstruction *kgepi = static_cast<KGEPInstruction*>(KI);
 
   if (GetElementPtrInst *gepi = dyn_cast<GetElementPtrInst>(KI->inst)) {
-    computeOffsets(kgepi, gep_type_begin(gepi), gep_type_end(gepi));
+    computeOffsets(kgepi, klee::gep_type_begin(gepi), klee::gep_type_end(gepi));
   } else if (InsertValueInst *ivi = dyn_cast<InsertValueInst>(KI->inst)) {
     computeOffsets(kgepi, iv_type_begin(ivi), iv_type_end(ivi));
     assert(kgepi->indices.empty() && "InsertValue constant offset expected");
@@ -2636,10 +2876,11 @@ void Executor::bindModuleConstants() {
       bindInstructionConstants(kf->instructions[i]);
   }
 
-  kmodule->constantTable = new Cell[kmodule->constants.size()];
   for (unsigned i=0; i<kmodule->constants.size(); ++i) {
-    Cell &c = kmodule->constantTable[i];
-    c.value = evalConstant(kmodule->constants[i]);
+    Cell c = {
+        .value = evalConstant(kmodule->constants[i])
+    };
+    kmodule->constantTable.push_back(c);
   }
 }
 
@@ -2659,7 +2900,14 @@ void Executor::checkMemoryUsage() {
         unsigned numStates = states.size();
         unsigned toKill = std::max(1U, numStates - numStates * MaxMemory / mbs);
         klee_warning("killing %d states (over memory cap)", toKill);
-        std::vector<ExecutionState *> arr(states.begin(), states.end());
+        std::vector<ExecutionState *> arr;
+        for (std::set<ExecutionState *>::iterator i = states.begin(); i != states.end(); i++) {
+          ExecutionState *toremove = *i;
+          if ((toremove->isNormalState() && toremove->isSuspended()) || toremove->isRecoveryState())  {
+            continue;
+          }
+          arr.push_back(toremove);
+        }
         for (unsigned i = 0, N = arr.size(); N && i < toKill; ++i, --N) {
           unsigned idx = rand() % N;
           // Make two pulls to try and not hit a state that
@@ -2776,6 +3024,7 @@ void Executor::run(ExecutionState &initialState) {
   searcher->update(0, newStates, std::vector<ExecutionState *>());
 
   while (!states.empty() && !haltExecution) {
+    assert(!searcher->empty());
     ExecutionState &state = searcher->selectState();
     KInstruction *ki = state.pc;
     stepInstruction(state);
@@ -2850,7 +3099,9 @@ void Executor::terminateState(ExecutionState &state) {
                       "replay did not consume all objects in test input.");
   }
 
-  interpreterHandler->incPathsExplored();
+  if (!state.isRecoveryState()) {
+    interpreterHandler->incPathsExplored();
+  }
 
   std::vector<ExecutionState *>::iterator it =
       std::find(addedStates.begin(), addedStates.end(), &state);
@@ -2876,14 +3127,22 @@ void Executor::terminateStateEarly(ExecutionState &state,
       (AlwaysOutputSeeds && seedMap.count(&state)))
     interpreterHandler->processTestCase(state, (message + "\n").str().c_str(),
                                         "early");
-  terminateState(state);
+  if (state.isRecoveryState()) {
+    terminateStateRecursively(state);
+  } else {
+    terminateState(state);
+  }
 }
 
 void Executor::terminateStateOnExit(ExecutionState &state) {
   if (!OnlyOutputStatesCoveringNew || state.coveredNew || 
       (AlwaysOutputSeeds && seedMap.count(&state)))
     interpreterHandler->processTestCase(state, 0, 0);
-  terminateState(state);
+  if (state.isRecoveryState()) {
+    terminateStateRecursively(state);
+  } else {
+    terminateState(state);
+  }
 }
 
 const InstructionInfo & Executor::getLastNonKleeInternalInstruction(const ExecutionState &state,
@@ -2952,6 +3211,9 @@ void Executor::terminateStateOnError(ExecutionState &state,
   
   if (EmitAllErrors ||
       emittedErrors.insert(std::make_pair(lastInst, message)).second) {
+    if (shouldExitOn(termReason)) {
+      errorCount++;
+    }
     if (ii.file != "") {
       klee_message("ERROR: %s:%d: %s", ii.file.c_str(), ii.line, message.c_str());
     } else {
@@ -2984,11 +3246,38 @@ void Executor::terminateStateOnError(ExecutionState &state,
 
     interpreterHandler->processTestCase(state, msg.str().c_str(), suffix);
   }
-    
-  terminateState(state);
 
-  if (shouldExitOn(termReason))
-    haltExecution = true;
+  if (state.isRecoveryState()) {
+    terminateStateRecursively(state);
+  } else {
+    terminateState(state);
+  }
+
+  if (shouldExitOn(termReason)) {
+    unsigned int maxCount = interpreterOpts.maxErrorCount;
+
+    if (interpreterOpts.errorLocations.empty()) {
+      if (maxCount == 0 || maxCount == errorCount) {
+        haltExecution = true;
+      }
+    } else if (ii.file != "") {
+      InterpreterOptions::ErrorLocations &errorLocations = interpreterOpts.errorLocations;
+      for (std::vector<ErrorLocationOption>::size_type i = 0; i < errorLocations.size(); ++i) {
+        std::string basename = ii.file.substr(ii.file.find_last_of("/\\") + 1);
+        InterpreterOptions::ErrorLocations::iterator entry = errorLocations.find(basename);
+        if (entry != errorLocations.end()) {
+          entry->second.erase(std::remove(entry->second.begin(), entry->second.end(), ii.line), entry->second.end());
+          if (entry->second.empty()) {
+            errorLocations.erase(entry);
+          }
+          break;
+        }
+      }
+      if (errorLocations.empty()) {
+        haltExecution = true;
+      }
+    }
+  }
 }
 
 // XXX shoot me
@@ -3141,8 +3430,17 @@ void Executor::executeAlloc(ExecutionState &state,
                             const ObjectState *reallocFrom) {
   size = toUnique(state, size);
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(size)) {
-    MemoryObject *mo = memory->allocate(CE->getZExtValue(), isLocal, false, 
-                                        state.prevPC->inst);
+    MemoryObject *mo = NULL;
+    if (state.isRecoveryState() && isDynamicAlloc(state.prevPC->inst)) {
+      mo = onExecuteAlloc(state, CE->getZExtValue(), isLocal, state.prevPC->inst, zeroMemory);
+    } else {
+      if (CE->getZExtValue() < HUGE_ALLOC_SIZE) {
+        mo = memory->allocate(CE->getZExtValue(), isLocal, false, state.prevPC->inst);
+      } else {
+        klee_message("NOTE: found huge concrete malloc (size = %ld), returning 0",
+                     CE->getZExtValue());
+      }
+    }
     if (!mo) {
       bindLocal(target, state, 
                 ConstantExpr::alloc(0, Context::get().getPointerWidth()));
@@ -3178,7 +3476,7 @@ void Executor::executeAlloc(ExecutionState &state,
     bool success = solver->getValue(state, size, example);
     assert(success && "FIXME: Unhandled solver failure");
     (void) success;
-    
+
     // Try and start with a small example.
     Expr::Width W = example->getWidth();
     while (example->Ugt(ConstantExpr::alloc(128, W))->isTrue()) {
@@ -3214,7 +3512,7 @@ void Executor::executeAlloc(ExecutionState &state,
         // malloc will fail for it, so lets fork and return 0.
         StatePair hugeSize = 
           fork(*fixedSize.second, 
-               UltExpr::create(ConstantExpr::alloc(1<<31, W), size), 
+               UltExpr::create(ConstantExpr::alloc(HUGE_ALLOC_SIZE, W), size),
                true);
         if (hugeSize.first) {
           klee_message("NOTE: found huge malloc, returning 0");
@@ -3264,6 +3562,9 @@ void Executor::executeFree(ExecutionState &state,
                               getAddressInfo(*it->second, address));
       } else {
         it->second->addressSpace.unbindObject(mo);
+        if (it->second->isRecoveryState()) {
+            onExecuteFree(it->second, mo);
+        }
         if (target)
           bindLocal(target, *it->second, Expr::createPointer(0));
       }
@@ -3356,9 +3657,18 @@ void Executor::executeMemoryOperation(ExecutionState &state,
         } else {
           ObjectState *wos = state.addressSpace.getWriteable(mo, os);
           wos->write(offset, value);
-        }          
+          if (state.isRecoveryState()) {
+            onRecoveryStateWrite(state, address, mo, offset, value);
+          }
+          if (state.isNormalState()) {
+            onNormalStateWrite(state, address, value);
+          }
+        }
       } else {
         ref<Expr> result = os->read(offset, type);
+        if (state.isNormalState()) {
+          onNormalStateRead(state, address, type);
+        }
         
         if (interpreterOpts.MakeConcreteSymbolic)
           result = replaceReadWithSymbolic(state, result);
@@ -3749,7 +4059,943 @@ Expr::Width Executor::getWidthForLLVMType(LLVM_TYPE_Q llvm::Type *type) const {
 
 ///
 
-Interpreter *Interpreter::create(const InterpreterOptions &opts,
+Interpreter *Interpreter::create(InterpreterOptions &opts,
                                  InterpreterHandler *ih) {
   return new Executor(opts, ih);
 }
+
+bool Executor::isMayBlockingLoad(ExecutionState &state, KInstruction *ki) {
+  /* basic check based on static analysis */
+  if (!ki->mayBlock) {
+    return false;
+  }
+
+  /* there is no need for recovery, if the value is not used... */
+  if (ki->inst->hasNUses(0)) {
+    return false;
+  }
+
+  if (!isRecoveryRequired(state, ki)) {
+    return false;
+  }
+
+  return true;
+}
+
+bool Executor::isRecoveryRequired(ExecutionState &state, KInstruction *ki) {
+  /* resolve address expression */
+  ref<Expr> addressExpr = eval(ki, 0, state).value;
+  if (!isa<ConstantExpr>(addressExpr)) {
+    addressExpr = state.constraints.simplifyExpr(addressExpr);
+    addressExpr = toConstant(state, addressExpr, "resolveOne failure");
+  }
+
+  uint64_t address = dyn_cast<ConstantExpr>(addressExpr)->getZExtValue();
+  Expr::Width width = getWidthForLLVMType(ki->inst->getType());
+  size_t size = Expr::getMinBytesForWidth(width);
+
+  /* check if already recovered */
+  if (state.isAddressRecovered(address)) {
+    DEBUG_WITH_TYPE(
+      DEBUG_BASIC,
+      klee_message("%p: load from %#lx is already recovered", &state, address)
+    );
+    return false;
+  }
+
+  /* check if someone has written to this location */
+  WrittenAddressInfo info;
+  if (!state.getWrittenAddressInfo(address, size, info)) {
+    /* this address was not overriden */
+    return true;
+  }
+
+  /* TODO: handle recovered loads... */
+  if (state.getCurrentSnapshotIndex() == info.snapshotIndex) {
+    /* TODO: hack... */
+    state.markLoadAsUnrecovered();
+    DEBUG_WITH_TYPE(
+      DEBUG_BASIC,
+      klee_message("location (%lx, %zu) was written, recovery is not required", address, size);
+    );
+    return false;
+  }
+
+  return true;
+}
+
+bool Executor::handleMayBlockingLoad(ExecutionState &state, KInstruction *ki,
+                                     bool &success) {
+  success = true;
+  /* find which slices should be executed... */
+  std::list< ref<RecoveryInfo> > &recoveryInfos = state.getPendingRecoveryInfos();
+  if (!getAllRecoveryInfo(state, ki, recoveryInfos)) {
+    success = false;
+    return false;
+  }
+  if (recoveryInfos.empty()) {
+    /* we are not dependent on previously skipped functions */
+    return false;
+  }
+
+  /* TODO: move to another place? */
+  state.pc = state.prevPC;
+
+  ref<RecoveryInfo> ri = state.getPendingRecoveryInfo();
+  startRecoveryState(state, ri);
+
+  if (!state.isSuspended()) {
+    suspendState(state);
+  }
+
+  return true;
+}
+
+bool Executor::getAllRecoveryInfo(ExecutionState &state, KInstruction *ki,
+                                  std::list<ref<RecoveryInfo> > &result) {
+  Instruction *loadInst;
+  uint64_t loadBase;
+  uint64_t loadAddr;
+  uint64_t loadSize;
+  ModRefAnalysis::AllocSite preciseAllocSite;
+
+  /* TODO: decide which value to pass (original, cloned) */
+  loadInst = ki->getOrigInst();
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("%p: may-blocking load:", &state));
+  DEBUG_WITH_TYPE(DEBUG_BASIC, errs() << "- instruction:" << *loadInst << "\n");
+  DEBUG_WITH_TYPE(DEBUG_BASIC, errs() << "- stack trace:\n");
+  DEBUG_WITH_TYPE(DEBUG_BASIC, state.dumpStack(errs()));
+
+  if (!getLoadInfo(state, ki, loadBase, loadAddr, loadSize, preciseAllocSite))
+    return false;
+
+  /* get the allocation site computed by static analysis */
+  std::set<ModRefAnalysis::ModInfo> approximateModInfos;
+  mra->getApproximateModInfos(ki->getOrigInst(), preciseAllocSite, approximateModInfos);
+
+  /* all the recovery information which may be required  */
+  std::list< ref<RecoveryInfo> > required;
+  /* the snapshots of the state */
+  std::vector< ref<Snapshot> > &snapshots = state.getSnapshots();
+  /* we start from the last snapshot which is not affected by an overwrite */
+  unsigned int startIndex = state.getStartingIndex(loadAddr, loadSize);
+
+  /* collect recovery information */
+  for (unsigned int index = startIndex; index < snapshots.size(); index++) {
+    if (state.isRecoveryState()) {
+      if (state.getRecoveryInfo()->snapshotIndex == index) {
+        break;
+      }
+    }
+
+    ref<Snapshot> snapshot = snapshots[index];
+    Function *snapshotFunction = snapshot->f;
+
+    for (std::set<ModRefAnalysis::ModInfo>::iterator j = approximateModInfos.begin(); j != approximateModInfos.end(); j++) {
+      ModRefAnalysis::ModInfo modInfo = *j;
+      if (modInfo.first != snapshotFunction) {
+        /* the function of the snapshot must match the modifier */
+        continue;
+      }
+
+      /* get the corresponding slice id */
+      ModRefAnalysis::ModInfoToIdMap &modInfoToIdMap = mra->getModInfoToIdMap();
+      ModRefAnalysis::ModInfoToIdMap::iterator entry = modInfoToIdMap.find(modInfo);
+      if (entry == modInfoToIdMap.end()) {
+        llvm_unreachable("ModInfoToIdMap is empty");
+      }
+
+      uint32_t sliceId = entry->second;
+
+      /* initialize... */
+      ref<RecoveryInfo> recoveryInfo(new RecoveryInfo());
+      recoveryInfo->loadInst = loadInst;
+      recoveryInfo->loadBase = loadBase;
+      recoveryInfo->loadAddr = loadAddr;
+      recoveryInfo->loadSize = loadSize;
+      recoveryInfo->f = modInfo.first;
+      recoveryInfo->sliceId = sliceId;
+      recoveryInfo->snapshot = snapshot;
+      recoveryInfo->snapshotIndex = index;
+
+      required.push_back(recoveryInfo);
+
+      /* TODO: validate that each snapshot corresponds to at most one modifier */
+      break;
+    }
+  }
+
+  /* do some filtering... */
+  for (std::list< ref<RecoveryInfo> >::reverse_iterator i = required.rbegin(); i != required.rend(); i++) {
+    ref<RecoveryInfo> recoveryInfo = *i;
+    unsigned int index = recoveryInfo->snapshotIndex;
+    unsigned int sliceId = recoveryInfo->sliceId;
+
+    DEBUG_WITH_TYPE(
+      DEBUG_BASIC,
+      klee_message(
+        "recovery info: addr = %#lx, size = %lx, function: %s, slice id = %u, snapshot index = %u",
+        recoveryInfo->loadAddr,
+        recoveryInfo->loadSize,
+        recoveryInfo->f->getName().data(),
+        recoveryInfo->sliceId,
+        recoveryInfo->snapshotIndex
+      )
+    );
+
+    ref<Expr> expr;
+    if (UseRecoveryCache && state.getRecoveredValue(index, sliceId, loadAddr, expr)) {
+      /* this slice was already executed from this snapshot,
+         and we know which value was written (or not) */
+      state.addRecoveredAddress(loadAddr);
+
+      if (!expr.isNull()) {
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message(
+            "%p: cached recovered value (index = %u, slice id = %u, addr = %lx)",
+            &state,
+            index,
+            sliceId,
+            loadAddr
+          )
+        );
+
+        /* execute write without recovering */
+        ref<Expr> base = eval(ki, 0, state).value;
+        executeMemoryOperation(state, true, base, expr, 0);
+
+        /* TODO: add docs */
+        break;
+
+      } else {
+        DEBUG_WITH_TYPE(
+          DEBUG_BASIC,
+          klee_message(
+            "%p: ignoring non-modifying slice (index = %u, slice id = %u, addr = %lx)",
+            &state,
+            index,
+            sliceId,
+            loadAddr
+          )
+        );
+      }
+    } else {
+      /* the slice was never executed, so we must add it */
+      DEBUG_WITH_TYPE(
+        DEBUG_BASIC,
+        klee_message(
+          "%p: adding recovery info for a non-executed slice (index = %u, slice id = %u)",
+          &state,
+          index,
+          sliceId
+        )
+      );
+      /* TODO: add docs */
+      if (UseRecoveryCache) {
+        state.updateRecoveredValue(index, sliceId, loadAddr, NULL);
+      }
+      result.push_front(recoveryInfo);
+    }
+  }
+  return true;
+}
+
+bool Executor::getLoadInfo(ExecutionState &state, KInstruction *ki,
+                           uint64_t &loadBase, uint64_t &loadAddr, uint64_t &loadSize,
+                           ModRefAnalysis::AllocSite &allocSite) {
+  ObjectPair op;
+  bool success;
+  ConstantExpr *ce;
+
+  ref<Expr> address = eval(ki, 0, state).value;
+
+  if (SimplifySymIndices) {
+    if (!isa<ConstantExpr>(address)) {
+      address = state.constraints.simplifyExpr(address);
+    }
+  }
+
+  /* execute solver query */
+  solver->setTimeout(coreSolverTimeout);
+  if (!state.addressSpace.resolveOne(state, solver, address, op, success)) {
+    address = toConstant(state, address, "resolveOne failure (getLoadInfo)");
+    success = state.addressSpace.resolveOne(cast<ConstantExpr>(address), op);
+  }
+  solver->setTimeout(0);
+
+  if (success) {
+    /* get load address */
+    ce = dyn_cast<ConstantExpr>(address);
+    if (!ce) {
+      /* TODO: use the resolve() API in order to support symbolic addresses */
+      state.dumpStack(llvm::errs());
+      llvm_unreachable("getLoadInfo() does not support symbolic addresses");
+    }
+
+    loadBase = op.first->address;
+    loadAddr = ce->getZExtValue();
+
+    /* get load size */
+    Expr::Width width = getWidthForLLVMType(ki->inst->getType());
+    loadSize = Expr::getMinBytesForWidth(width);
+
+    /* get allocation site value and offset */
+    const MemoryObject *mo = op.first;
+    /* TODO: we don't actually need the offset... */
+    ref<Expr> offsetExpr = mo->getOffsetExpr(address);
+    offsetExpr = toConstant(state, offsetExpr, "...");
+    ce = dyn_cast<ConstantExpr>(offsetExpr);
+    assert(ce);
+
+    /* translate value... */
+    const Value *translatedValue = cloner->translateValue((Value *)(mo->allocSite));
+    uint64_t offset = ce->getZExtValue();
+
+    /* get the precise allocation site */
+    allocSite = std::make_pair(translatedValue, offset);
+  } else {
+    DEBUG_WITH_TYPE(
+      DEBUG_BASIC,
+      klee_message("Unable to resolve blocking load address to one memory object")
+    );
+    ResolutionList rl;
+    solver->setTimeout(coreSolverTimeout);
+    bool incomplete = state.addressSpace.resolve(state, solver, address, rl, 0,
+                                                 coreSolverTimeout);
+    solver->setTimeout(0);
+
+    if (rl.empty()) {
+      if (!incomplete) {
+        klee_warning(
+            "Unable to resolve blocking load to any address. Terminating state");
+        terminateStateOnError(
+            state, "Unable to resolve blocking load to any address", Unhandled);
+      } else {
+        klee_warning("Unable to resolve blocking load address: Solver timeout");
+        terminateStateEarly(
+            state, "Unable to resolve blocking load address: solver timeout");
+      }
+    } else {
+      klee_warning("Resolving blocking load address: multiple resolutions");
+      terminateStateEarly(
+          state, "Resolving blocking load address: multiple resolutions");
+    }
+    return false;
+  }
+  return true;
+}
+
+void Executor::suspendState(ExecutionState &state) {
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("suspending: %p", &state));
+  state.setSuspended();
+  suspendedStates.push_back(&state);
+}
+
+void Executor::resumeState(ExecutionState &state, bool implicitlyCreated) {
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("resuming: %p", &state));
+  state.setResumed();
+  state.setRecoveryState(0);
+  state.markLoadAsUnrecovered();
+  if (implicitlyCreated) {
+    DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("adding an implicitly created state: %p", &state));
+    addedStates.push_back(&state);
+  } else {
+    resumedStates.push_back(&state);
+  }
+
+  /* debug... */
+  state.getAllocationRecord().dump();
+}
+
+void Executor::onRecoveryStateExit(ExecutionState &state) {
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("%p: recovery state reached exit instruction", &state));
+
+  ExecutionState *dependentState = state.getDependentState();
+  //dumpConstrains(*dependentState);
+
+  /* check if we need to run another recovery state */
+  if (dependentState->hasPendingRecoveryInfo()) {
+    ref<RecoveryInfo> ri = dependentState->getPendingRecoveryInfo();
+    startRecoveryState(*dependentState, ri);
+  } else {
+    notifyDependentState(state);
+  }
+  terminateState(state);
+}
+
+void Executor::notifyDependentState(ExecutionState &recoveryState) {
+  ExecutionState *dependentState = recoveryState.getDependentState();
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("%p: notifying dependent state %p", &recoveryState, dependentState));
+
+  if (recoveryState.isNormalState()) {
+    /* the allocation record of the recovery states contains the allocation record of the dependent state */
+    dependentState->setAllocationRecord(recoveryState.getAllocationRecord());
+  }
+
+  if (states.find(dependentState) == states.end()) {
+    resumeState(*dependentState, true);
+  } else {
+    resumeState(*dependentState, false);
+  }
+}
+
+void Executor::startRecoveryState(ExecutionState &state, ref<RecoveryInfo> recoveryInfo) {
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message(
+      "starting recovery for function %s, load address %#lx",
+      recoveryInfo->f->getName().str().c_str(),
+      recoveryInfo->loadAddr
+    )
+  );
+
+  ref<ExecutionState> snapshotState = recoveryInfo->snapshot->state;
+
+  /* TODO: non-first snapshots hold normal state properties! */
+
+  /* initialize recovery state */
+  ExecutionState *recoveryState = new ExecutionState(*snapshotState);
+  if (recoveryInfo->snapshotIndex == 0) {
+    /* a recovery state which is created from the first snapshot has no dependencies */
+    recoveryState->setType(RECOVERY_STATE);
+  } else {
+    /* in this case, a recovery state may depend on previous skipped functions */
+    recoveryState->setType(NORMAL_STATE | RECOVERY_STATE);
+
+    /* initialize... */
+    recoveryState->setResumed();
+    /* not linked to any recovery state at this point */
+    recoveryState->setRecoveryState(0);
+    /* TODO: we need only a prefix of the snapshots... */
+    recoveryState->markLoadAsRecovered();
+    recoveryState->clearRecoveredAddresses();
+    /* TODO: we actually need only a prefix of that */
+    recoveryState->setRecoveryCache(state.getRecoveryCache());
+    /* this state may create another recovery state, so it must hold the allocation record */
+    recoveryState->setAllocationRecord(state.getAllocationRecord());
+    /* make sure it is empty... */
+    assert(recoveryState->getGuidingConstraints().empty());
+    /* TODO: handle writtenAddresses */
+
+    assert(recoveryState->getPendingRecoveryInfos().empty());
+  }
+
+  /* set exit instruction */
+  recoveryState->setExitInst(snapshotState->pc->inst);
+
+  /* set dependent state */
+  recoveryState->setDependentState(&state);
+
+  /* set originating state */
+  ExecutionState *originatingState;
+  if (state.isRecoveryState()) {
+    originatingState = state.getOriginatingState();
+  } else {
+    /* this must be the originating state */
+    originatingState = &state;
+  }
+  recoveryState->setOriginatingState(originatingState);
+
+  /* set recovery information */
+  recoveryState->setRecoveryInfo(recoveryInfo);
+
+  /* pass allocation record to recovery state */
+  recoveryState->setGuidingAllocationRecord(state.getAllocationRecord());
+
+  /* recursion level */
+  unsigned int level = state.isRecoveryState() ? state.getLevel() + 1 : 0;
+  recoveryState->setLevel(level);
+
+  /* add the guiding constraints to the recovery state */
+  std::set< ref<Expr> > &constraints = originatingState->getGuidingConstraints();
+  for (std::set< ref<Expr> >::iterator i = constraints.begin(); i != constraints.end(); i++) {
+    addConstraint(*recoveryState, *i);
+  }
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message("adding %lu guiding constraints", constraints.size())
+  );
+
+  /* TODO: update prevPC? */
+  recoveryState->pc = recoveryState->prevPC;
+
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message(
+      "adding recovery state: %p (snapshot index = %u, level = %u)",
+      recoveryState,
+      recoveryInfo->snapshotIndex,
+      recoveryState->getLevel()
+    )
+  );
+
+  /* link the current state to it's recovery state */
+  state.setRecoveryState(recoveryState);
+
+  /* update process tree */
+  state.ptreeNode->data = 0;
+  std::pair<PTree::Node*, PTree::Node*> res = processTree->split(state.ptreeNode, recoveryState, &state);
+  recoveryState->ptreeNode = res.first;
+  state.ptreeNode = res.second;
+
+  /* add the recovery state to the searcher */
+  recoveryState->setPriority(PRIORITY_HIGH);
+  addedStates.push_back(recoveryState);
+
+  /* update statistics */
+  interpreterHandler->incRecoveryStatesCount();
+}
+
+/* TODO: handle vastart calls */
+void Executor::onRecoveryStateWrite(
+  ExecutionState &state,
+  ref<Expr> address,
+  const MemoryObject *mo,
+  ref<Expr> offset,
+  ref<Expr> value
+) {
+  ref<RecoveryInfo> recoveryInfo = state.getRecoveryInfo();
+  if (recoveryInfo->loadBase != mo->address) {
+    return;
+  }
+
+  assert(isa<ConstantExpr>(address));
+  assert(isa<ConstantExpr>(offset));
+
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message(
+      "write in state %p: mo = %p, address = %lx, size = %x, offset = %lx",
+      &state,
+      mo,
+      mo->address,
+      mo->size,
+      dyn_cast<ConstantExpr>(offset)->getZExtValue()
+    )
+  );
+
+  uint64_t storeAddr = dyn_cast<ConstantExpr>(address)->getZExtValue();
+  if (storeAddr != recoveryInfo->loadAddr) {
+    return;
+  }
+
+  /* copy data to dependent state... */
+  ExecutionState *dependentState = state.getDependentState();
+  const ObjectState *os = dependentState->addressSpace.findObject(mo);
+  ObjectState *wos = dependentState->addressSpace.getWriteable(mo, os);
+  wos->write(offset, value);
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message("copying from %p to %p", &state, dependentState)
+  );
+
+  /* TODO: ... */
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message(
+      "%p: updating recovered value for %p (index = %u, slice id = %u)",
+      &state,
+      dependentState,
+      recoveryInfo->snapshotIndex,
+      recoveryInfo->sliceId
+    )
+  );
+  if (UseRecoveryCache) {
+    dependentState->updateRecoveredValue(
+      recoveryInfo->snapshotIndex,
+      recoveryInfo->sliceId,
+      storeAddr,
+      value
+    );
+  }
+}
+
+void Executor::onNormalStateWrite(
+  ExecutionState &state,
+  ref<Expr> address,
+  ref<Expr> value
+) {
+  if (!state.isInDependentMode()) {
+    return;
+  }
+
+  if (state.prevPC->inst->getOpcode() != Instruction::Store) {
+    /* TODO: this must be a vastart call, check! */
+    return;
+  }
+
+  if (!isOverridingStore(state.prevPC)) {
+    return;
+  }
+
+  assert(isa<ConstantExpr>(address));
+
+  uint64_t concreteAddress = dyn_cast<ConstantExpr>(address)->getZExtValue();
+  size_t sizeInBytes = value->getWidth() / 8;
+  if (value->getWidth() == Expr::Bool) {
+    /* in this case, the width of the written value is extended to Int8 */
+    sizeInBytes = 1;
+  } else {
+    sizeInBytes = value->getWidth() / 8;
+    assert(sizeInBytes * 8 == value->getWidth());
+  }
+
+  /* TODO: don't add if already recovered */
+  state.addWrittenAddress(concreteAddress, sizeInBytes, state.getCurrentSnapshotIndex());
+  DEBUG_WITH_TYPE(
+    DEBUG_BASIC,
+    klee_message("%p: adding written address: (%lx, %zu)",
+      &state,
+      concreteAddress,
+      sizeInBytes
+    )
+  );
+}
+
+/* checking if a store may override a skipped function stores ... */
+bool Executor::isOverridingStore(KInstruction *ki) {
+  assert(ki->inst->getOpcode() == Instruction::Store);
+  return ki->mayOverride;
+}
+
+void Executor::onNormalStateRead(
+  ExecutionState &state,
+  ref<Expr> address,
+  Expr::Width width
+) {
+  if (!state.isInDependentMode()) {
+    return;
+  }
+
+  if (state.isBlockingLoadRecovered()) {
+    return;
+  }
+
+  assert(isa<ConstantExpr>(address));
+
+  ConstantExpr *ce = dyn_cast<ConstantExpr>(address);
+  uint64_t addr = ce->getZExtValue();
+
+  /* update recovered loads */
+  state.addRecoveredAddress(addr);
+  state.markLoadAsRecovered();
+}
+
+void Executor::dumpConstrains(ExecutionState &state) {
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("constraints (state = %p):", &state));
+  for (ConstraintManager::constraint_iterator i = state.constraints.begin(); i != state.constraints.end(); i++) {
+      ref<Expr> e = *i;
+      DEBUG_WITH_TYPE(DEBUG_BASIC, errs() << "  -- "; e->dump());
+  }
+}
+
+MemoryObject *Executor::onExecuteAlloc(ExecutionState &state, uint64_t size, bool isLocal, Instruction *allocInst, bool zeroMemory) {
+    MemoryObject *mo = NULL;
+
+    /* get the context of the allocation instruction */
+    std::vector<Instruction *> callTrace;
+    state.getCallTrace(callTrace);
+    ASContext context(cloner, callTrace, allocInst);
+
+    ExecutionState *dependentState = state.getDependentState();
+    AllocationRecord &guidingAllocationRecord = state.getGuidingAllocationRecord();
+    AllocationRecord &allocationRecord = dependentState->getAllocationRecord();
+
+    if (guidingAllocationRecord.exists(context)) {
+        /* the address should be already bound */
+        mo = guidingAllocationRecord.getAddr(context);
+        if (mo) {
+            DEBUG_WITH_TYPE(
+                DEBUG_BASIC,
+                klee_message("%p: reusing allocated address: %lx, size: %lu", &state, mo->address, size)
+            );
+        } else {
+            DEBUG_WITH_TYPE(
+                DEBUG_BASIC,
+                klee_message("%p: reusing null address", &state)
+            );
+        }
+    } else {
+        if (size < HUGE_ALLOC_SIZE) {
+            mo = memory->allocate(size, isLocal, false, allocInst);
+            DEBUG_WITH_TYPE(
+                DEBUG_BASIC,
+                klee_message("%p: allocating new address: %lx, size: %lu", &state, mo->address, size)
+            );
+        } else {
+            mo = NULL;
+            DEBUG_WITH_TYPE(
+                DEBUG_BASIC,
+                klee_message("%p: allocating null address", &state)
+            );
+        }
+
+        /* TODO: do we need to add the MemoryObject here? */
+        allocationRecord.addAddr(context, mo);
+        if (state.isNormalState()) {
+          state.getAllocationRecord().addAddr(context, mo);
+        }
+    }
+
+    if (mo) {
+        /* bind the address to the dependent states */
+        bindAll(dependentState, mo, isLocal, zeroMemory);
+    }
+
+    return mo;
+}
+
+bool Executor::isDynamicAlloc(Instruction *allocInst) {
+    CallInst *callInst = dyn_cast<CallInst>(allocInst);
+    if (!callInst) {
+        return false;
+    }
+
+    Value *calledValue = callInst->getCalledValue();
+    const char *functions[] = {
+        "malloc",
+        "calloc",
+        "realloc",
+    };
+
+    for (unsigned int i = 0; i < sizeof(functions) / sizeof(functions[0]); i++) {
+        if (calledValue->getName() == StringRef(functions[i])) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void Executor::onExecuteFree(ExecutionState *state, const MemoryObject *mo) {
+    ExecutionState *dependentState = state->getDependentState();
+    unbindAll(dependentState, mo);
+}
+
+void Executor::terminateStateRecursively(ExecutionState &state) {
+  ExecutionState *current = &state;
+  ExecutionState *next = NULL;
+
+  DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("recursively terminating..."));
+  while (current) {
+    if (current->isRecoveryState()) {
+      next = current->getDependentState();
+      assert(next);
+    } else {
+      next = NULL;
+    }
+
+    DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("terminating state %p", current));
+    terminateState(*current);
+    current = next;
+  }
+}
+
+void Executor::mergeConstraints(ExecutionState &dependentState, ref<Expr> condition) {
+    assert(dependentState.isNormalState());
+    addConstraint(dependentState, condition);
+}
+
+bool Executor::isFunctionToSkip(ExecutionState &state, Function *f) {
+    for (auto i = interpreterOpts.skippedFunctions.begin(), e = interpreterOpts.skippedFunctions.end(); i != e; i++) {
+        const SkippedFunctionOption &option = *i;
+        if ((option.name == f->getName().str())) {
+            Instruction *callInst = state.prevPC->inst;
+            const InstructionInfo &info = kmodule->infos->getInfo(callInst);
+            const std::vector<unsigned int> &lines = option.lines;
+
+            /* skip any call site */
+            if (lines.empty()) {
+                return true;
+            }
+
+            /* check if we have debug information */
+            if (info.line == 0) {
+                klee_warning_once(0, "call filter for %s: debug info not found...", option.name.data());
+                return true;
+            }
+
+            return std::find(lines.begin(), lines.end(), info.line) != lines.end();
+        }
+    }
+
+    return false;
+}
+
+void Executor::bindAll(ExecutionState *state, MemoryObject *mo, bool isLocal, bool zeroMemory) {
+    ExecutionState *next;
+    do {
+        /* this state is a normal state (and might be a recovery state as well) */
+        next = NULL;
+        if (state->isRecoveryState()) {
+            next = state->getDependentState();
+        }
+
+        DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("%p: binding address: %lx", state, mo->address));
+        if (!state->addressSpace.findObject(mo)) {
+            ObjectState *os = bindObjectInState(*state, mo, isLocal);
+            /* initialize allocated object */
+            if (zeroMemory) {
+                os->initializeToZero();
+            } else {
+                os->initializeToRandom();
+            }
+        }
+
+        state = next;
+    } while (next);
+}
+
+void Executor::unbindAll(ExecutionState *state, const MemoryObject *mo) {
+    ExecutionState *next;
+    do {
+        /* this state is a normal state (and might be a recovery state as well) */
+        next = NULL;
+        if (state->isRecoveryState()) {
+            next = state->getDependentState();
+        }
+
+        DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("%p: unbinding address %lx", state, mo->address));
+        state->addressSpace.unbindObject(mo);
+
+        state = next;
+    } while (next);
+}
+
+void Executor::forkDependentStates(ExecutionState *trueState, ExecutionState *falseState) {
+    ExecutionState *current = trueState->getDependentState();
+    ExecutionState *forked = NULL;
+    ExecutionState *prevForked = falseState;
+    ExecutionState *forkedOriginatingState = NULL;
+
+    /* fork the chain of dependent states */
+    do {
+        forked = new ExecutionState(*current);
+        assert(forked->isSuspended());
+        DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("forked dependent state: %p (from %p)", forked, current));
+
+        if (forked->isRecoveryState()) {
+            interpreterHandler->incRecoveryStatesCount();
+        }
+
+        forked->setRecoveryState(prevForked);
+        prevForked->setDependentState(forked);
+
+        current->ptreeNode->data = 0;
+        std::pair<PTree::Node*, PTree::Node*> res = processTree->split(current->ptreeNode, forked, current);
+        forked->ptreeNode = res.first;
+        current->ptreeNode = res.second;
+
+        if (current->isRecoveryState()) {
+            prevForked = forked;
+            current = current->getDependentState();
+        } else {
+            forkedOriginatingState = forked;
+            current = NULL;
+        }
+    } while (current);
+
+    /* update originating state */
+    current = falseState;
+    do {
+        if (current->isRecoveryState()) {
+            DEBUG_WITH_TYPE(
+              DEBUG_BASIC,
+              klee_message("%p: updating originating state %p", current, forkedOriginatingState)
+            );
+            current->setOriginatingState(forkedOriginatingState);
+            current = current->getDependentState();
+        } else {
+            /* TODO: initialize originating state to NULL? */
+            current = NULL;
+        }
+    } while (current);
+}
+
+void Executor::mergeConstraintsForAll(ExecutionState &recoveryState, ref<Expr> condition) {
+    ExecutionState *next = recoveryState.getDependentState();
+    do {
+        mergeConstraints(*next, condition);
+
+        if (next->isRecoveryState()) {
+            next = next->getDependentState();
+        } else {
+            next = NULL;
+        }
+    } while (next);
+
+    /* add the guiding constraints only to the originating state */
+    ExecutionState *originatingState = recoveryState.getOriginatingState();
+    originatingState->addGuidingConstraint(condition);
+}
+
+/* on demand slicing... */
+Function *Executor::getSlice(Function *target, uint32_t sliceId, ModRefAnalysis::SideEffectType type) {
+    Cloner::SliceInfo *sliceInfo = NULL;
+
+    sliceInfo = cloner->getSliceInfo(target, sliceId);
+    if (!sliceInfo || !sliceInfo->isSliced) {
+        DEBUG_WITH_TYPE(DEBUG_BASIC,
+            klee_message("generating slice for: %s (id = %u)", target->getName().data(), sliceId)
+        );
+        sliceGenerator->generateSlice(target, sliceId, type);
+        sliceGenerator->dumpSlice(target, sliceId, true);
+
+        /* update statistics */
+        interpreterHandler->incGeneratedSlicesCount();
+
+        if (!sliceInfo) {
+            sliceInfo = cloner->getSliceInfo(target, sliceId);
+            assert(sliceInfo);
+        }
+
+        std::set<Function *> &reachable = ra->getReachableFunctions(target);
+        for (std::set<Function *>::iterator i = reachable.begin(); i != reachable.end(); i++) {
+            /* original function */
+            Function *f = *i;
+            if (f->isDeclaration()) {
+                continue;
+            }
+
+            /* get the cloned function (using the slice id) */
+            Function *cloned = cloner->getSliceInfo(f, sliceId)->f;
+            if (cloned->isDeclaration()) {
+                /* a sliced function can become empty (a decleration) */
+                continue;
+            }
+
+            /* initialize KFunction */
+            KFunction *kcloned = new KFunction(cloned, kmodule);
+            kcloned->isCloned = true;
+
+            DEBUG_WITH_TYPE(DEBUG_BASIC, klee_message("adding function: %s", cloned->getName().data()));
+            /* update debug info */
+            kmodule->infos->addClonedInfo(cloner, cloned);
+            /* update function map */
+            kmodule->addFunction(kcloned, true, cloner, mra);
+            /* update the instruction constants of the new KFunction */
+            for (unsigned i = 0; i < kcloned->numInstructions; ++i) {
+                bindInstructionConstants(kcloned->instructions[i]);
+            }
+            /* when we add a KFunction, additional constants might be added */
+            for (unsigned i = kmodule->constantTable.size(); i < kmodule->constants.size(); ++i) {
+                Cell c = {
+                    .value = evalConstant(kmodule->constants[i])
+                };
+                kmodule->constantTable.push_back(c);
+            }
+        }
+    }
+
+    return sliceInfo->f;
+}
+
+ExecutionState *Executor::createSnapshotState(ExecutionState &state) {
+    ExecutionState *snapshotState = new ExecutionState(state);
+
+    /* remove guiding constraints */
+    snapshotState->clearGuidingConstraints();
+
+    return snapshotState;
+}
diff --git a/lib/Core/Executor.h b/lib/Core/Executor.h
index 93d1443..2d56893 100644
--- a/lib/Core/Executor.h
+++ b/lib/Core/Executor.h
@@ -25,6 +25,13 @@
 
 #include "llvm/ADT/Twine.h"
 
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
 #include <vector>
 #include <string>
 #include <map>
@@ -74,8 +81,6 @@ namespace klee {
   class TreeStreamWriter;
   template<class T> class ref;
 
-
-
   /// \todo Add a context object to keep track of data only live
   /// during an instruction step. Should contain addedStates,
   /// removedStates, and haltExecution, among others.
@@ -86,6 +91,7 @@ class Executor : public Interpreter {
   friend class RandomPathSearcher;
   friend class OwningSearcher;
   friend class WeightedRandomSearcher;
+  friend class RandomRecoveryPath;
   friend class SpecialFunctionHandler;
   friend class StatsTracker;
 
@@ -210,6 +216,20 @@ private:
   // @brief buffer to store logs before flushing to file
   llvm::raw_string_ostream debugLogBuffer;
 
+  /* TODO: ... */
+  std::vector<ExecutionState *> suspendedStates;
+  std::vector<ExecutionState *> resumedStates;
+  ReachabilityAnalysis *ra;
+  Inliner *inliner;
+  AAPass *aa;
+  ModRefAnalysis *mra;
+  Cloner *cloner;
+  SliceGenerator *sliceGenerator;
+
+  unsigned int errorCount;
+
+  llvm::raw_ostream *logFile;
+
   llvm::Function* getTargetFunction(llvm::Value *calledVal,
                                     ExecutionState &state);
   
@@ -433,8 +453,55 @@ private:
   void printDebugInstructions(ExecutionState &state);
   void doDumpStates();
 
+  bool isMayBlockingLoad(ExecutionState &state, KInstruction *ki);
+  bool isRecoveryRequired(ExecutionState &state, KInstruction *ki);
+  bool handleMayBlockingLoad(ExecutionState &state, KInstruction *ki,
+                             bool &success);
+  bool getAllRecoveryInfo(ExecutionState &state, KInstruction *kinst,
+                          std::list<ref<RecoveryInfo> > &result);
+  bool getLoadInfo(ExecutionState &state, KInstruction *kinst,
+                   uint64_t &loadBase, uint64_t &loadAddr, uint64_t &loadSize,
+                   ModRefAnalysis::AllocSite &allocSite);
+  void suspendState(ExecutionState &state);
+  void resumeState(ExecutionState &state, bool implicitlyCreated);
+  void notifyDependentState(ExecutionState &recoveryState);
+  void onRecoveryStateExit(ExecutionState &state);
+  void startRecoveryState(ExecutionState &state, ref<RecoveryInfo> recoveryInfo);
+  void onRecoveryStateWrite(
+    ExecutionState &state,
+    ref<Expr> address,
+    const MemoryObject *mo,
+    ref<Expr> offset,
+    ref<Expr> value
+  );
+  void onNormalStateWrite(
+    ExecutionState &state,
+    ref<Expr> address,
+    ref<Expr> value
+  );
+  bool isOverridingStore(KInstruction *kinst);
+  void onNormalStateRead(
+    ExecutionState &state,
+    ref<Expr> address,
+    Expr::Width width
+  );
+  void dumpConstrains(ExecutionState &state);
+  MemoryObject *onExecuteAlloc(ExecutionState &state, uint64_t size, bool isLocal, llvm::Instruction *allocInst, bool zeroMemory);
+  bool isDynamicAlloc(llvm::Instruction *allocInst);
+  void onExecuteFree(ExecutionState *state, const MemoryObject *mo);
+  void terminateStateRecursively(ExecutionState &state);
+  void mergeConstraints(ExecutionState &dependedState, ref<Expr> condition);
+  bool isFunctionToSkip(ExecutionState &state, llvm::Function *f);
+  bool canSkipCallSite(ExecutionState &state, llvm::Function *f);
+  void bindAll(ExecutionState *state, MemoryObject *mo, bool isLocal, bool zeroMemory);
+  void unbindAll(ExecutionState *state, const MemoryObject *mo);
+  void forkDependentStates(ExecutionState *trueState, ExecutionState *falseState);
+  void mergeConstraintsForAll(ExecutionState &recoveryState, ref<Expr> condition);
+  llvm::Function *getSlice(llvm::Function *target, uint32_t sliceId, ModRefAnalysis::SideEffectType type);
+  ExecutionState *createSnapshotState(ExecutionState &state);
+
 public:
-  Executor(const InterpreterOptions &opts, InterpreterHandler *ie);
+  Executor(InterpreterOptions &opts, InterpreterHandler *ie);
   virtual ~Executor();
 
   const InterpreterHandler& getHandler() {
diff --git a/lib/Core/ExecutorTimers.cpp b/lib/Core/ExecutorTimers.cpp
index f1c4510..55e1180 100644
--- a/lib/Core/ExecutorTimers.cpp
+++ b/lib/Core/ExecutorTimers.cpp
@@ -118,16 +118,13 @@ void Executor::processTimers(ExecutionState *current,
   }
 
   if (ticks || dumpPTree || dumpStates) {
-    if (dumpPTree) {
-      char name[32];
-      sprintf(name, "ptree%08d.dot", (int) stats::instructions);
-      llvm::raw_ostream *os = interpreterHandler->openOutputFile(name);
+    if (dumpPTree && processTree->changed) {
+      llvm::raw_ostream *os = interpreterHandler->openOutputFile("ptree.dot");
       if (os) {
         processTree->dump(*os);
         delete os;
       }
-      
-      dumpPTree = 0;
+      getchar();
     }
 
     if (dumpStates) {
diff --git a/lib/Core/ExecutorUtil.cpp b/lib/Core/ExecutorUtil.cpp
index b91b5de..a98b339 100644
--- a/lib/Core/ExecutorUtil.cpp
+++ b/lib/Core/ExecutorUtil.cpp
@@ -90,7 +90,7 @@ namespace klee {
     case Instruction::GetElementPtr: {
       ref<ConstantExpr> base = op1->ZExt(Context::get().getPointerWidth());
 
-      for (gep_type_iterator ii = gep_type_begin(ce), ie = gep_type_end(ce);
+      for (gep_type_iterator ii = klee::gep_type_begin(ce), ie = klee::gep_type_end(ce);
            ii != ie; ++ii) {
         ref<ConstantExpr> addend = 
           ConstantExpr::alloc(0, Context::get().getPointerWidth());
diff --git a/lib/Core/Memory.cpp b/lib/Core/Memory.cpp
index 72f0a1f..395865a 100644
--- a/lib/Core/Memory.cpp
+++ b/lib/Core/Memory.cpp
@@ -444,7 +444,7 @@ void ObjectState::write8(ref<Expr> offset, ref<Expr> value) {
   if (size>4096) {
     std::string allocInfo;
     object->getAllocInfo(allocInfo);
-    klee_warning_once(0, "flushing %d bytes on read, may be slow and/or crash: %s", 
+    klee_warning_once(0, "flushing %d bytes on write, may be slow and/or crash: %s",
                       size,
                       allocInfo.c_str());
   }
diff --git a/lib/Core/Memory.h b/lib/Core/Memory.h
index d08bfb0..990c723 100644
--- a/lib/Core/Memory.h
+++ b/lib/Core/Memory.h
@@ -33,6 +33,7 @@ class MemoryObject {
   friend class STPBuilder;
   friend class ObjectState;
   friend class ExecutionState;
+  friend class AllocationRecord;
 
 private:
   static int counter;
diff --git a/lib/Core/PTree.cpp b/lib/Core/PTree.cpp
index 77698bb..87197e5 100644
--- a/lib/Core/PTree.cpp
+++ b/lib/Core/PTree.cpp
@@ -10,6 +10,7 @@
 #include "PTree.h"
 
 #include <klee/Expr.h>
+#include <klee/ExecutionState.h>
 #include <klee/util/ExprPPrinter.h>
 
 #include <vector>
@@ -18,8 +19,8 @@ using namespace klee;
 
   /* *** */
 
-PTree::PTree(const data_type &_root) : root(new Node(0,_root)) {
-}
+PTree::PTree(const data_type &_root)
+    : root(new Node(0, _root)), changed(false) {}
 
 PTree::~PTree() {}
 
@@ -30,6 +31,7 @@ PTree::split(Node *n,
   assert(n && !n->left && !n->right);
   n->left = new Node(n, leftData);
   n->right = new Node(n, rightData);
+  changed = true;
   return std::make_pair(n->left, n->right);
 }
 
@@ -48,6 +50,7 @@ void PTree::remove(Node *n) {
     delete n;
     n = p;
   } while (n && !n->left && !n->right);
+  changed = true;
 }
 
 void PTree::dump(llvm::raw_ostream &os) {
@@ -58,7 +61,7 @@ void PTree::dump(llvm::raw_ostream &os) {
   os << "\tratio=fill;\n";
   os << "\trotate=90;\n";
   os << "\tcenter = \"true\";\n";
-  os << "\tnode [style=\"filled\",width=.1,height=.1,fontname=\"Terminus\"]\n";
+  os << "\tnode [style=\"filled\",width=1,height=1,fontname=\"Terminus\"]\n";
   os << "\tedge [arrowsize=.3]\n";
   std::vector<PTree::Node*> stack;
   stack.push_back(root);
@@ -72,8 +75,21 @@ void PTree::dump(llvm::raw_ostream &os) {
       pp->print(n->condition);
       os << "\",shape=diamond";
     }
-    if (n->data)
-      os << ",fillcolor=green";
+    if (n->data) {
+      ExecutionState *es = n->data;
+      if (es->isNormalState()) {
+        if (es->isRecoveryState()) {
+          os << ",fillcolor=orange";
+        } else {
+          os << ",fillcolor=green";
+        }
+      } else if (es->isRecoveryState()) {
+        os << ",fillcolor=blue";
+      }
+      if (es->isSuspended()) {
+        os << ",shape=square";
+      }
+    }
     os << "];\n";
     if (n->left) {
       os << "\tn" << n << " -> n" << n->left << ";\n";
@@ -85,6 +101,7 @@ void PTree::dump(llvm::raw_ostream &os) {
     }
   }
   os << "}\n";
+  changed = false;
   delete pp;
 }
 
diff --git a/lib/Core/PTree.h b/lib/Core/PTree.h
index 11d3f48..bb8212a 100644
--- a/lib/Core/PTree.h
+++ b/lib/Core/PTree.h
@@ -21,6 +21,7 @@ namespace klee {
   public:
     typedef class PTreeNode Node;
     Node *root;
+    bool changed;
 
     PTree(const data_type &_root);
     ~PTree();
diff --git a/lib/Core/Searcher.cpp b/lib/Core/Searcher.cpp
index c787382..be9b3af 100644
--- a/lib/Core/Searcher.cpp
+++ b/lib/Core/Searcher.cpp
@@ -109,8 +109,17 @@ void BFSSearcher::update(ExecutionState *current,
   if (!addedStates.empty() && current &&
       std::find(removedStates.begin(), removedStates.end(), current) ==
           removedStates.end()) {
-    assert(states.front() == current);
-    states.pop_front();
+    if (states.front() == current) {
+      // BFS is the only searcher
+      states.pop_front();
+    } else {
+      // interleaved with other searcher
+      std::deque<ExecutionState*>::iterator pos = std::find(states.begin(),
+                                                            states.end(),
+                                                            current);
+      assert(pos != states.end());
+      states.erase(pos);
+    }
     states.push_back(current);
   }
 
@@ -292,7 +301,11 @@ ExecutionState &RandomPathSearcher::selectState() {
     }
   }
 
-  return *n->data;
+  ExecutionState *es = n->data;
+  while (es->isSuspended()) {
+    es = es->getRecoveryState();
+  }
+  return *es;
 }
 
 void
@@ -634,8 +647,14 @@ InterleavedSearcher::~InterleavedSearcher() {
 }
 
 ExecutionState &InterleavedSearcher::selectState() {
-  Searcher *s = searchers[--index];
-  if (index==0) index = searchers.size();
+  assert(!empty());
+  Searcher *s;
+  do {
+    s = searchers[--index];
+    if (index == 0) {
+      index = searchers.size();
+    }
+  } while (s->empty());
   return s->selectState();
 }
 
@@ -646,3 +665,274 @@ void InterleavedSearcher::update(
          ie = searchers.end(); it != ie; ++it)
     (*it)->update(current, addedStates, removedStates);
 }
+
+/* splitted searcher */
+SplittedSearcher::SplittedSearcher(Searcher *baseSearcher, Searcher *recoverySearcher, unsigned int ratio)
+  : baseSearcher(baseSearcher), recoverySearcher(recoverySearcher), ratio(ratio)
+{
+
+}
+
+SplittedSearcher::~SplittedSearcher() {
+  delete baseSearcher;
+}
+
+ExecutionState &SplittedSearcher::selectState() {
+  if (baseSearcher->empty()) {
+    /* the recovery states are supposed to be not empty */
+    return recoverySearcher->selectState();
+  }
+
+  if (recoverySearcher->empty()) {
+    /* the base searcher is supposed to be not empty */
+    return baseSearcher->selectState();
+  }
+
+  /* in this case, both searchers are supposed to be not empty */
+  if (theRNG.getInt32() % 100 < ratio) {
+    /* we handle recovery states in a DFS manner */
+    return recoverySearcher->selectState();
+  } else {
+    return baseSearcher->selectState();
+  }
+}
+
+void SplittedSearcher::update(
+  ExecutionState *current,
+  const std::vector<ExecutionState *> &addedStates,
+  const std::vector<ExecutionState *> &removedStates
+) {
+  std::vector<ExecutionState *> addedOriginatingStates;
+  std::vector<ExecutionState *> addedRecoveryStates;
+  std::vector<ExecutionState *> removedOriginatingStates;
+  std::vector<ExecutionState *> removedRecoveryStates;
+
+  /* split added states */
+  for (auto i = addedStates.begin(); i != addedStates.end(); i++) {
+    ExecutionState *es = *i;
+    if (es->isRecoveryState()) {
+      addedRecoveryStates.push_back(es);
+    } else {
+      addedOriginatingStates.push_back(es);
+    }
+  }
+
+  /* split removed states */
+  for (auto i = removedStates.begin(); i != removedStates.end(); i++) {
+    ExecutionState *es = *i;
+    if (es->isRecoveryState()) {
+      removedRecoveryStates.push_back(es);
+    } else {
+      removedOriginatingStates.push_back(es);
+    }
+  }
+
+  if (current && current->isRecoveryState()) {
+    baseSearcher->update(NULL, addedOriginatingStates, removedOriginatingStates);
+  } else {
+    baseSearcher->update(current, addedOriginatingStates, removedOriginatingStates);
+  }
+
+  if (current && !current->isRecoveryState()) {
+    recoverySearcher->update(NULL, addedRecoveryStates, removedRecoveryStates);
+  } else {
+    recoverySearcher->update(current, addedRecoveryStates, removedRecoveryStates);
+  }
+}
+
+bool SplittedSearcher::empty() {
+  return baseSearcher->empty() && recoverySearcher->empty();
+}
+
+/* random-path searcher for the recovery model */
+RandomRecoveryPath::RandomRecoveryPath(Executor &executor)
+  : executor(executor)
+{
+
+}
+
+RandomRecoveryPath::~RandomRecoveryPath() {
+
+}
+
+ExecutionState &RandomRecoveryPath::selectState() {
+  if (treeStack.empty()) {
+    /* as this point, the order of selection does not matter */
+    return *states.front();
+  }
+
+  unsigned int flips = 0;
+  unsigned int bits = 0;
+
+  /* select the root */
+  PTree::Node *n = treeStack.top();
+
+  while (!n->data) {
+    if (!n->left) {
+      n = n->right;
+    } else if (!n->right) {
+      n = n->left;
+    } else {
+      if (bits==0) {
+        flips = theRNG.getInt32();
+        bits = 32;
+      }
+      --bits;
+      n = (flips&(1<<bits)) ? n->left : n->right;
+    }
+  }
+
+  ExecutionState *es = n->data;
+  while (es->isSuspended()) {
+    es = es->getRecoveryState();
+  }
+  return *es;
+}
+
+void RandomRecoveryPath::update(
+  ExecutionState *current,
+  const std::vector<ExecutionState *> &addedStates,
+  const std::vector<ExecutionState *> &removedStates
+) {
+  for (auto i = addedStates.begin(); i != addedStates.end(); i++) {
+    ExecutionState *es = *i;
+    if (es->getLevel() == treeStack.size()) {
+      /* this state has a higher level, so we push it as a root */
+      treeStack.push(es->ptreeNode);
+    }
+
+    /* add state */
+    states.push_back(es);
+  }
+  for (auto i = removedStates.begin(); i != removedStates.end(); i++) {
+    ExecutionState *es = *i;
+    /* a top level recovery state terminated, so we pop it's root from the stack */
+    if (es->isResumed() && es->getLevel() == treeStack.size() - 1) {
+      treeStack.pop();
+    }
+
+    /* remove state */
+    for (auto j = states.begin(); j != states.end(); j++) {
+      if (es == *j) {
+        states.erase(j);
+        break;
+      }
+    }
+  }
+}
+
+bool RandomRecoveryPath::empty() {
+  return treeStack.empty() && states.empty();
+}
+
+/* optimized splitted searcher */
+OptimizedSplittedSearcher::OptimizedSplittedSearcher(
+  Searcher *baseSearcher,
+  Searcher *recoverySearcher,
+  Searcher *highPrioritySearcher,
+  unsigned int ratio
+) :
+  baseSearcher(baseSearcher),
+  recoverySearcher(recoverySearcher),
+  highPrioritySearcher(highPrioritySearcher),
+  ratio(ratio)
+{
+
+}
+
+OptimizedSplittedSearcher::~OptimizedSplittedSearcher() {
+  delete highPrioritySearcher;
+  delete recoverySearcher;
+  delete baseSearcher;
+}
+
+ExecutionState &OptimizedSplittedSearcher::selectState() {
+  /* high priority recovery states must be considered first */
+  if (!highPrioritySearcher->empty()) {
+    return highPrioritySearcher->selectState();
+  }
+
+  if (baseSearcher->empty()) {
+    /* the recovery states are supposed to be not empty */
+    return recoverySearcher->selectState();
+  }
+
+  if (recoverySearcher->empty()) {
+    /* the base searcher is supposed to be not empty */
+    return baseSearcher->selectState();
+  }
+
+  /* in this case, both searchers are supposed to be not empty */
+  if (theRNG.getInt32() % 100 < ratio) {
+    /* we handle recovery states in a DFS manner */
+    return recoverySearcher->selectState();
+  } else {
+    return baseSearcher->selectState();
+  }
+}
+
+void OptimizedSplittedSearcher::update(
+  ExecutionState *current,
+  const std::vector<ExecutionState *> &addedStates,
+  const std::vector<ExecutionState *> &removedStates
+) {
+  std::vector<ExecutionState *> addedOriginatingStates;
+  std::vector<ExecutionState *> addedRecoveryStates;
+  std::vector<ExecutionState *> removedOriginatingStates;
+  std::vector<ExecutionState *> removedRecoveryStates;
+
+  /* split added states */
+  for (auto i = addedStates.begin(); i != addedStates.end(); i++) {
+    ExecutionState *es = *i;
+    if (es->isRecoveryState()) {
+      if (es->getPriority() == PRIORITY_HIGH) {
+        highPrioritySearcher->addState(es);
+      } else {
+        addedRecoveryStates.push_back(es);
+      }
+    } else {
+      addedOriginatingStates.push_back(es);
+    }
+  }
+
+  /* split removed states */
+  for (auto i = removedStates.begin(); i != removedStates.end(); i++) {
+    ExecutionState *es = *i;
+    if (es->isRecoveryState()) {
+      if (es->getPriority() == PRIORITY_HIGH) {
+        highPrioritySearcher->removeState(es);
+        /* flush the high priority recovery states, only when a root recovery state terminates */
+        if ((es->isResumed() && es->getLevel() == 0)) {
+          int count = 0;
+          while (!highPrioritySearcher->empty()) {
+            ExecutionState &rs = highPrioritySearcher->selectState();
+            highPrioritySearcher->removeState(&rs);
+            rs.setPriority(PRIORITY_LOW);
+            recoverySearcher->addState(&rs);
+            count++;
+          }
+        }
+      } else {
+        removedRecoveryStates.push_back(es);
+      }
+    } else {
+      removedOriginatingStates.push_back(es);
+    }
+  }
+
+  if (current && current->isRecoveryState()) {
+    baseSearcher->update(NULL, addedOriginatingStates, removedOriginatingStates);
+  } else {
+    baseSearcher->update(current, addedOriginatingStates, removedOriginatingStates);
+  }
+
+  if (current && !current->isRecoveryState()) {
+    recoverySearcher->update(NULL, addedRecoveryStates, removedRecoveryStates);
+  } else {
+    recoverySearcher->update(current, addedRecoveryStates, removedRecoveryStates);
+  }
+}
+
+bool OptimizedSplittedSearcher::empty() {
+  return baseSearcher->empty() && recoverySearcher->empty() && highPrioritySearcher->empty();
+}
diff --git a/lib/Core/Searcher.h b/lib/Core/Searcher.h
index 4ede364..607a05c 100644
--- a/lib/Core/Searcher.h
+++ b/lib/Core/Searcher.h
@@ -10,6 +10,8 @@
 #ifndef KLEE_SEARCHER_H
 #define KLEE_SEARCHER_H
 
+#include "PTree.h"
+
 #include "llvm/Support/raw_ostream.h"
 #include <vector>
 #include <set>
@@ -78,6 +80,11 @@ namespace klee {
       NURS_CPICnt,
       NURS_QC
     };
+
+    enum RecoverySearchType {
+      RS_DFS,
+      RS_RandomPath,
+    };
   };
 
   class DFSSearcher : public Searcher {
@@ -288,7 +295,14 @@ namespace klee {
     void update(ExecutionState *current,
                 const std::vector<ExecutionState *> &addedStates,
                 const std::vector<ExecutionState *> &removedStates);
-    bool empty() { return searchers[0]->empty(); }
+    bool empty() {
+      for (Searcher *s : searchers) {
+        if (!s->empty()) {
+          return false;
+        }
+      }
+      return true;
+    }
     void printName(llvm::raw_ostream &os) {
       os << "<InterleavedSearcher> containing "
          << searchers.size() << " searchers:\n";
@@ -299,6 +313,84 @@ namespace klee {
     }
   };
 
+  class SplittedSearcher : public Searcher {
+    Searcher *baseSearcher;
+    Searcher *recoverySearcher;
+    unsigned int ratio;
+
+  public:
+    SplittedSearcher(Searcher *baseSearcher, Searcher *recoverySearcher, unsigned int ratio);
+    ~SplittedSearcher();
+
+    ExecutionState &selectState();
+    void update(ExecutionState *current,
+                const std::vector<ExecutionState *> &addedStates,
+                const std::vector<ExecutionState *> &removedStates);
+    bool empty();
+    void printName(llvm::raw_ostream &os) {
+      os << "SplittedSearcher\n";
+      os << "- base searcher: "; baseSearcher->printName(os);
+      os << "- recovery searcher: "; recoverySearcher->printName(os);
+      os << "- ratio = " << ratio << "\n";
+    }
+  };
+
+  class RandomRecoveryPath : public Searcher {
+    Executor &executor;
+    /* a stack of recovery states,
+     * where each state is the root of a recovery tree
+     */
+    std::stack<PTree::Node *> treeStack;
+    /* this is a simple way to keep track of the states of the recovery trees */
+    std::vector<ExecutionState *> states;
+
+  public:
+    RandomRecoveryPath(Executor &executor);
+
+    ~RandomRecoveryPath();
+
+    ExecutionState &selectState();
+
+    void update(ExecutionState *current,
+                const std::vector<ExecutionState *> &addedStates,
+                const std::vector<ExecutionState *> &removedStates);
+
+    bool empty();
+
+    void printName(llvm::raw_ostream &os) {
+      os << "RandomRecoveryPath\n";
+    }
+
+  };
+
+  class OptimizedSplittedSearcher : public Searcher {
+    Searcher *baseSearcher;
+    Searcher *recoverySearcher;
+    Searcher *highPrioritySearcher;
+    unsigned int ratio;
+
+  public:
+    OptimizedSplittedSearcher(
+      Searcher *baseSearcher,
+      Searcher *recoverySearcher,
+      Searcher *highPrioritySearcher,
+      unsigned int ratio
+    );
+    ~OptimizedSplittedSearcher();
+
+    ExecutionState &selectState();
+    void update(ExecutionState *current,
+                const std::vector<ExecutionState *> &addedStates,
+                const std::vector<ExecutionState *> &removedStates);
+    bool empty();
+    void printName(llvm::raw_ostream &os) {
+      os << "OptimizedSplittedSearcher\n";
+      os << "- base searcher: "; baseSearcher->printName(os);
+      os << "- low priority searcher: "; recoverySearcher->printName(os);
+      os << "- high priority searcher: "; highPrioritySearcher->printName(os);
+      os << "- ratio = " << ratio << "\n";
+    }
+  };
 }
 
 #endif
diff --git a/lib/Core/StatsTracker.cpp b/lib/Core/StatsTracker.cpp
index 97ed26e..06e80b0 100644
--- a/lib/Core/StatsTracker.cpp
+++ b/lib/Core/StatsTracker.cpp
@@ -451,7 +451,7 @@ void StatsTracker::writeStatsLine() {
              << "," << stats::forkTime / 1000000.
              << "," << stats::resolveTime / 1000000.
 #ifdef DEBUG
-             << "," << stats::arrayHashTime / 1000000.
+             //<< "," << stats::arrayHashTime / 1000000.
 #endif
              << ")\n";
   statsFile->flush();
diff --git a/lib/Core/UserSearcher.cpp b/lib/Core/UserSearcher.cpp
index 725836e..995e88d 100644
--- a/lib/Core/UserSearcher.cpp
+++ b/lib/Core/UserSearcher.cpp
@@ -61,6 +61,22 @@ namespace {
   UseBumpMerge("use-bump-merge", 
            cl::desc("Enable support for klee_merge() (extra experimental)"));
 
+  cl::opt<bool> UseSplittedSearcher("split-search", cl::desc("..."));
+
+  cl::list<Searcher::RecoverySearchType> RecoverySearch(
+    "recovery-search",
+    cl::desc("Specify the recovery search heuristic (disabled by default)"),
+	  cl::values(
+      clEnumValN(Searcher::RS_DFS, "dfs", "use depth first search"),
+      clEnumValN(Searcher::RS_RandomPath, "random-path", "use random path selection"),
+      clEnumValEnd
+    )
+  );
+
+  cl::opt<unsigned int>
+  SplitRatio("split-ratio",
+            cl::desc("ratio for choosing recovery states (default = 20)"),
+            cl::init(20));
 }
 
 
@@ -132,6 +148,33 @@ Searcher *klee::constructUserSearcher(Executor &executor) {
     searcher = new IterativeDeepeningTimeSearcher(searcher);
   }
 
+  if (UseSplittedSearcher) {
+    /* TODO: Should both of the searchers be of the same type? */
+    searcher = new SplittedSearcher(searcher, new DFSSearcher(), SplitRatio);
+  }
+
+  if (!RecoverySearch.empty()) {
+    Searcher *recoverySearcher = NULL;
+    switch (RecoverySearch[0]) {
+    case Searcher::RS_DFS:
+        recoverySearcher = new DFSSearcher();
+        break;
+
+    case Searcher::RS_RandomPath:
+        recoverySearcher = new RandomRecoveryPath(executor);
+        break;
+    }
+
+    if (recoverySearcher == NULL) {
+      klee_error("invalid recovery search heuristic");
+    }
+
+    searcher = new OptimizedSplittedSearcher(searcher,
+                                             new DFSSearcher(),
+                                             recoverySearcher,
+                                             SplitRatio);
+  }
+
   llvm::raw_ostream &os = executor.getHandler().getInfoStream();
 
   os << "BEGIN searcher description\n";
diff --git a/lib/Expr/CMakeLists.txt b/lib/Expr/CMakeLists.txt
index 4c63fe5..c60930e 100644
--- a/lib/Expr/CMakeLists.txt
+++ b/lib/Expr/CMakeLists.txt
@@ -27,3 +27,8 @@ set(LLVM_COMPONENTS
 )
 klee_get_llvm_libs(LLVM_LIBS ${LLVM_COMPONENTS})
 target_link_libraries(kleaverExpr PUBLIC ${LLVM_LIBS})
+target_include_directories(kleaverExpr PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/lib/Module/CMakeLists.txt b/lib/Module/CMakeLists.txt
index 006443a..c29470d 100644
--- a/lib/Module/CMakeLists.txt
+++ b/lib/Module/CMakeLists.txt
@@ -17,6 +17,7 @@ klee_add_component(kleeModule
   Optimize.cpp
   PhiCleaner.cpp
   RaiseAsm.cpp
+  ReturnToVoidFunctionPass.cpp
 )
 
 set(LLVM_COMPONENTS
@@ -35,6 +36,7 @@ endif()
 klee_get_llvm_libs(LLVM_LIBS ${LLVM_COMPONENTS})
 target_link_libraries(kleeModule PUBLIC ${LLVM_LIBS})
 target_link_libraries(kleeModule PRIVATE
+  kleeAnalysis
   kleeSupport
   # FIXME:
   # There is a circular dependency between `kleeModule` and `kleeCore`.
@@ -42,3 +44,8 @@ target_link_libraries(kleeModule PRIVATE
   # `kleeCore` uses `kleeModule`.
   kleeCore
 )
+target_include_directories(kleeModule PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/lib/Module/InstructionInfoTable.cpp b/lib/Module/InstructionInfoTable.cpp
index 7e9a9e2..b760ec4 100644
--- a/lib/Module/InstructionInfoTable.cpp
+++ b/lib/Module/InstructionInfoTable.cpp
@@ -46,6 +46,8 @@
 #include "llvm/Analysis/ValueTracking.h"
 #include "llvm/Support/ErrorHandling.h"
 
+#include "klee/Internal/Analysis/Cloner.h"
+
 #include <map>
 #include <string>
 
@@ -112,7 +114,7 @@ bool InstructionInfoTable::getInstructionDebugInfo(const llvm::Instruction *I,
   return false;
 }
 
-InstructionInfoTable::InstructionInfoTable(Module *m) 
+InstructionInfoTable::InstructionInfoTable(Module *m, bool isSkippingFunctions, Cloner *cloner)
   : dummyString(""), dummyInfo(0, dummyString, 0, 0) {
   unsigned id = 0;
   std::map<const Instruction*, unsigned> lineTable;
@@ -148,9 +150,48 @@ InstructionInfoTable::InstructionInfoTable(Module *m)
                                   InstructionInfo(id++, *file, line,
                                                   assemblyLine)));
     }
+
+    if (!isSkippingFunctions) {
+        continue;
+    }
+
+    /* handle cloned functions */
+    Cloner::SliceMap *sliceMap = cloner->getSlices(fnIt);
+    if (sliceMap != 0) {
+      for (Cloner::SliceMap::iterator s = sliceMap->begin(); s != sliceMap->end(); s++ ) {
+        Cloner::SliceInfo &sliceInfo = s->second;
+        if (!sliceInfo.isSliced) {
+            continue;
+        }
+
+        Function *cloned = sliceInfo.f;
+        addClonedInfo(cloner, cloned);
+      }
+    }
   }
 }
 
+void InstructionInfoTable::addClonedInfo(Cloner *cloner, Function *f) {
+    for (inst_iterator it = inst_begin(f); it != inst_end(f); it++) {
+        /* translate cloned instruction */
+        Instruction *inst = &*it;
+        Value *value = cloner->translateValue(inst);
+        if (value) {
+            /* add original instruction information */
+            Instruction *origInst = dyn_cast<Instruction>(value);
+            if (!origInst) {
+                llvm_unreachable("something is wrong with the cloner mapping");
+            }
+
+            const InstructionInfo &info = getInfo(origInst);
+            infos.insert(std::make_pair(inst, info));
+        } else {
+            /* instruction information not available (probably due to slicer insertions) */
+            infos.insert(std::make_pair(inst, dummyInfo));
+        }
+    }
+}
+
 InstructionInfoTable::~InstructionInfoTable() {
   for (std::set<const std::string *, ltstr>::iterator
          it = internedStrings.begin(), ie = internedStrings.end();
diff --git a/lib/Module/KModule.cpp b/lib/Module/KModule.cpp
index 57346a3..f163615 100644
--- a/lib/Module/KModule.cpp
+++ b/lib/Module/KModule.cpp
@@ -56,6 +56,13 @@
 
 #include <llvm/Transforms/Utils/Cloning.h>
 
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
 #include <sstream>
 
 using namespace llvm;
@@ -99,6 +106,11 @@ namespace {
   cl::opt<bool>
   DebugPrintEscapingFunctions("debug-print-escaping-functions", 
                               cl::desc("Print functions whose address is taken."));
+
+  cl::opt<bool>
+  UseSVFPTA("use-svf-analysis",
+            cl::desc("Use SVF pointer analysis for reachability analysis (default=on)"),
+            cl::init(true));
 }
 
 KModule::KModule(Module *_module) 
@@ -109,12 +121,10 @@ KModule::KModule(Module *_module)
     targetData(new DataLayout(module)),
 #endif
     kleeMergeFn(0),
-    infos(0),
-    constantTable(0) {
+    infos(0) {
 }
 
 KModule::~KModule() {
-  delete[] constantTable;
   delete infos;
 
   for (std::vector<KFunction*>::iterator it = functions.begin(), 
@@ -240,7 +250,14 @@ void KModule::addInternalFunction(const char* functionName){
 }
 
 void KModule::prepare(const Interpreter::ModuleOptions &opts,
-                      InterpreterHandler *ih) {
+		              const std::vector<Interpreter::SkippedFunctionOption> &skippedFunctions,
+                      InterpreterHandler *ih,
+                      ReachabilityAnalysis *ra,
+                      Inliner *inliner,
+                      AAPass *aa,
+                      ModRefAnalysis *mra,
+                      Cloner *cloner,
+                      SliceGenerator *sliceGenerator) {
   if (!MergeAtExit.empty()) {
     Function *mergeFn = module->getFunction("klee_merge");
     if (!mergeFn) {
@@ -297,6 +314,7 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
   // optimize is seeing what is as close as possible to the final
   // module.
   PassManager pm;
+  pm.add(new ReturnToVoidFunctionPass(skippedFunctions));
   pm.add(new RaiseAsmPass());
   if (opts.CheckDivZero) pm.add(new DivCheckPass());
   if (opts.CheckOvershift) pm.add(new OvershiftCheckPass());
@@ -433,24 +451,68 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
 
   kleeMergeFn = module->getFunction("klee_merge");
 
+  if (!skippedFunctions.empty()) {
+    /* prepare reachability analysis */
+    ra->prepare();
+
+    /* first, we need to do the inlining... */
+    inliner->run();
+
+    /* run pointer analysis */
+    klee_message("Runnining pointer analysis...");
+    PassManager passManager;
+    passManager.add(aa);
+    passManager.run(*module);
+
+    /* run reachability analysis */
+    klee_message("Runnining reachability analysis...");
+    ra->usePA(aa);
+    ra->run(UseSVFPTA);
+
+    /* run mod-ref analysis */
+    klee_message("Runnining mod-ref analysis...");
+    mra->run();
+
+    if (sliceGenerator) {
+      /* TODO: rename... */
+      sliceGenerator->generate();
+    }
+  }
+
   /* Build shadow structures */
 
-  infos = new InstructionInfoTable(module);  
+  infos = new InstructionInfoTable(module, !skippedFunctions.empty(), cloner);
   
   for (Module::iterator it = module->begin(), ie = module->end();
        it != ie; ++it) {
-    if (it->isDeclaration())
+    Function *f = it;
+    if (f->isDeclaration()) {
       continue;
+    }
 
-    KFunction *kf = new KFunction(it, this);
-    
-    for (unsigned i=0; i<kf->numInstructions; ++i) {
-      KInstruction *ki = kf->instructions[i];
-      ki->info = &infos->getInfo(ki->inst);
+    std::set<KFunction *> pool;
+    pool.insert(new KFunction(f, this));
+
+    if (!skippedFunctions.empty()) {
+      Cloner::SliceMap *sliceMap = cloner->getSlices(f);
+      if (sliceMap != 0) {
+        for (Cloner::SliceMap::iterator s = sliceMap->begin(); s != sliceMap->end(); s++ ) {
+          Cloner::SliceInfo &sliceInfo = s->second;
+          if (!sliceInfo.isSliced) {
+              /* don't add a cloned function which was not sliced */
+              continue;
+          }
+
+          KFunction *kcloned = new KFunction(sliceInfo.f, this);
+          kcloned->isCloned = true;
+          pool.insert(kcloned);
+        }
+      }
     }
 
-    functions.push_back(kf);
-    functionMap.insert(std::make_pair(it, kf));
+    for (std::set<KFunction *>::iterator kfi = pool.begin(); kfi != pool.end(); kfi++) {
+      addFunction(*kfi, !skippedFunctions.empty(), cloner, mra);
+    }
   }
 
   /* Compute various interesting properties */
@@ -472,6 +534,39 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
   }
 }
 
+void KModule::addFunction(KFunction *kf, bool isSkippingFunctions, Cloner *cloner, ModRefAnalysis *mra) {
+    for (unsigned i=0; i<kf->numInstructions; ++i) {
+        KInstruction *ki = kf->instructions[i];
+        ki->info = &infos->getInfo(ki->inst);
+        ki->isCloned = kf->isCloned;
+        ki->origInst = NULL;
+        ki->mayBlock = false;
+        ki->mayOverride = false;
+
+        if (!isSkippingFunctions) {
+            continue;
+        }
+
+        if (kf->isCloned) {
+            Value *origValue = cloner->translateValue(ki->inst);
+            if (origValue) {
+                /* TODO: some instructions can't be translated (RET, ...) */
+                ki->origInst = dyn_cast<llvm::Instruction>(origValue);
+            }
+        }
+
+        if (ki->inst->getOpcode() == Instruction::Load) {
+            ki->mayBlock = mra->mayBlock(ki->getOrigInst());
+        }
+        if (ki->inst->getOpcode() == Instruction::Store) {
+            ki->mayOverride = mra->mayOverride(ki->getOrigInst());
+        }
+    }
+
+    functions.push_back(kf);
+    functionMap.insert(std::make_pair(kf->function, kf));
+}
+
 KConstant* KModule::getKConstant(Constant *c) {
   std::map<llvm::Constant*, KConstant*>::iterator it = constantMap.find(c);
   if (it != constantMap.end())
@@ -488,6 +583,7 @@ unsigned KModule::getConstantID(Constant *c, KInstruction* ki) {
   kc = new KConstant(c, id, ki);
   constantMap.insert(std::make_pair(c, kc));
   constants.push_back(c);
+
   return id;
 }
 
@@ -524,7 +620,8 @@ KFunction::KFunction(llvm::Function *_function,
   : function(_function),
     numArgs(function->arg_size()),
     numInstructions(0),
-    trackCoverage(true) {
+    trackCoverage(true),
+    isCloned(false) {
   for (llvm::Function::iterator bbit = function->begin(), 
          bbie = function->end(); bbit != bbie; ++bbit) {
     BasicBlock *bb = bbit;
diff --git a/lib/Module/ModuleUtil.cpp b/lib/Module/ModuleUtil.cpp
index a539406..99e53f8 100644
--- a/lib/Module/ModuleUtil.cpp
+++ b/lib/Module/ModuleUtil.cpp
@@ -449,7 +449,7 @@ Function *klee::getDirectCallTarget(CallSite cs) {
 
     // NOTE: This assert may fire, it isn't necessarily a problem and
     // can be disabled, I just wanted to know when and if it happened.
-    assert(0 && "FIXME: Unresolved direct target for a constant expression.");
+    //assert(0 && "FIXME: Unresolved direct target for a constant expression.");
   }
   
   return 0;
diff --git a/lib/Module/Passes.h b/lib/Module/Passes.h
index 4f1a145..bb7167f 100644
--- a/lib/Module/Passes.h
+++ b/lib/Module/Passes.h
@@ -10,11 +10,13 @@
 #ifndef KLEE_PASSES_H
 #define KLEE_PASSES_H
 
+#include "klee/Interpreter.h"
 #include "klee/Config/Version.h"
 
 #if LLVM_VERSION_CODE >= LLVM_VERSION(3, 3)
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/Instructions.h"
+#include "llvm/InstVisitor.h"
 #include "llvm/IR/Module.h"
 #else
 #include "llvm/Constants.h"
@@ -180,6 +182,24 @@ private:
                      llvm::BasicBlock *defaultBlock);
 };
 
+class ReturnToVoidFunctionPass : public llvm::ModulePass {
+  static char ID;
+  const std::vector<Interpreter::SkippedFunctionOption> skippedFunctions;
+
+public:
+  ReturnToVoidFunctionPass(const std::vector<Interpreter::SkippedFunctionOption> _skippedFunctions) :
+    ModulePass(ID),
+    skippedFunctions(_skippedFunctions)
+  {
+
+  }
+  virtual bool runOnModule(llvm::Module &module);
+  virtual bool runOnFunction(llvm::Function &f, llvm::Module &modue);
+  llvm::Function *createWrapperFunction(llvm::Function &f, llvm::Module &module);
+  void replaceCalls(llvm::Function *f, llvm::Function *wrapper, const std::vector<unsigned int> &lines);
+  void replaceCall(llvm::CallInst *origCallInst, llvm::Function *f, llvm::Function *wrapper);
+};
+
 }
 
 #endif
diff --git a/lib/Module/ReturnToVoidFunctionPass.cpp b/lib/Module/ReturnToVoidFunctionPass.cpp
new file mode 100644
index 0000000..a99aa05
--- /dev/null
+++ b/lib/Module/ReturnToVoidFunctionPass.cpp
@@ -0,0 +1,192 @@
+//===-- ReturnToVoidFunctionPass.cpp --------------------------------------===//
+//
+//                     The KLEE Symbolic Virtual Machine
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Passes.h"
+
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/Support/CFG.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/GlobalValue.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/InstVisitor.h"
+#include "llvm/DebugInfo.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/Utils/ValueMapper.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+
+using namespace llvm;
+using namespace std;
+
+char klee::ReturnToVoidFunctionPass::ID = 0;
+
+bool klee::ReturnToVoidFunctionPass::runOnFunction(Function &f, Module &module) {
+  // skip void functions
+  if (f.getReturnType()->isVoidTy()) {
+    return false;
+  }
+
+  bool changed = false;
+  for (std::vector<Interpreter::SkippedFunctionOption>::const_iterator i = skippedFunctions.begin(); i != skippedFunctions.end(); i++) {
+    if (string("__wrap_") + f.getName().str() == i->name) {
+      Function *wrapper = createWrapperFunction(f, module);
+      replaceCalls(&f, wrapper, i->lines);
+      changed = true;
+    }
+  }
+
+  return changed;
+}
+
+/// We replace a returning function f with a void __wrap_f function that:
+///  1- takes as first argument a variable __result that will contain the result
+///  2- calls f and stores the return value in __result
+Function *klee::ReturnToVoidFunctionPass::createWrapperFunction(Function &f, Module &module) {
+  // create new function parameters: *return_var + original function's parameters
+  vector<Type *> paramTypes;
+  Type *returnType = f.getReturnType();
+  paramTypes.push_back(PointerType::get(returnType, 0));
+  paramTypes.insert(paramTypes.end(), f.getFunctionType()->param_begin(), f.getFunctionType()->param_end());
+
+  // create new void function
+  FunctionType *newFunctionType = FunctionType::get(Type::getVoidTy(getGlobalContext()), makeArrayRef(paramTypes), f.isVarArg());
+  string wrappedName = string("__wrap_") + f.getName().str();
+  Function *wrapper = cast<Function>(module.getOrInsertFunction(wrappedName, newFunctionType));
+
+  // set the arguments' name: __result + original parameters' name
+  vector<Value *> argsForCall;
+  Function::arg_iterator i = wrapper->arg_begin();
+  Value *resultArg = i++;
+  resultArg->setName("__result");
+  for (Function::arg_iterator j = f.arg_begin(); j != f.arg_end(); j++) {
+    Value *origArg = j;
+    Value *arg = i++;
+    arg->setName(origArg->getName());
+    argsForCall.push_back(arg);
+  }
+
+  // create basic block 'entry' in the new function
+  BasicBlock *block = BasicBlock::Create(getGlobalContext(), "entry", wrapper);
+  IRBuilder<> builder(block);
+
+  // insert call to the original function
+  Value *callInst = builder.CreateCall(&f, makeArrayRef(argsForCall), "__call");
+  // insert store for the return value to __result parameter
+  builder.CreateStore(callInst, resultArg);
+  // terminate function with void return
+  builder.CreateRetVoid();
+
+  return wrapper;
+}
+
+/// Replaces calls to f with the wrapper function __wrap_f
+/// The replacement will occur at all call sites only if the user has not specified a given line in the '-skip-functions' options
+void klee::ReturnToVoidFunctionPass::replaceCalls(Function *f, Function *wrapper, const vector<unsigned int> &lines) {
+  vector<CallInst*> to_remove;
+  for (auto ui = f->use_begin(), ue = f->use_end(); ui != ue; ui++) {
+    if (Instruction *inst = dyn_cast<Instruction>(*ui)) {
+      if (inst->getParent()->getParent() == wrapper) {
+        continue;
+      }
+
+      if (!lines.empty()) {
+        if (MDNode *N = inst->getMetadata("dbg")) {
+          DILocation Loc(N);
+          if (find(lines.begin(), lines.end(), Loc.getLineNumber()) == lines.end()) {
+            continue;
+          }
+        }
+      }
+
+      if (CallInst *call = dyn_cast<CallInst>(inst)) {
+        replaceCall(call, f, wrapper);
+        to_remove.push_back(call);
+      }
+    }
+  }
+  for (auto ci = to_remove.begin(), ce = to_remove.end(); ci != ce; ci++) {
+    (*ci)->eraseFromParent();
+  }
+}
+
+/// We replace a given CallInst to f with a new CallInst to __wrap_f
+/// If the original return value was used in a StoreInst, we use directly such variable, instead of creating a new one
+void klee::ReturnToVoidFunctionPass::replaceCall(CallInst *origCallInst, Function *f, Function *wrapper) {
+  Value *allocaInst = NULL;
+  StoreInst *prevStoreInst = NULL;
+  bool hasPhiUse = false;
+
+  // We can perform this optimization only when the return value is stored, and
+  // that is the _only_ use
+  if (origCallInst->getNumUses() == 1) {
+    for (auto ui = origCallInst->use_begin(), ue = origCallInst->use_end();
+         ui != ue; ui++) {
+      if (StoreInst *storeInst = dyn_cast<StoreInst>(*ui)) {
+        if (storeInst->getOperand(0) == origCallInst &&
+            isa<AllocaInst>(storeInst->getOperand(1))) {
+          allocaInst = storeInst->getOperand(1);
+          prevStoreInst = storeInst;
+        }
+      }
+    }
+  }
+
+  /* check if we have a PHI use */
+  for (auto ui = origCallInst->use_begin(), ue = origCallInst->use_end(); ui != ue; ui++) {
+    if (isa<PHINode>(*ui)) {
+      hasPhiUse = true;
+    }
+  }
+
+  IRBuilder<> builder(origCallInst);
+  // insert alloca for return value
+  if (!allocaInst)
+    allocaInst = builder.CreateAlloca(f->getReturnType());
+
+  // insert call for the wrapper function
+  vector<Value *> argsForCall;
+  argsForCall.push_back(allocaInst);
+  for (unsigned int i = 0; i < origCallInst->getNumArgOperands(); i++) {
+    argsForCall.push_back(origCallInst->getArgOperand(i));
+  }
+  CallInst *callInst = builder.CreateCall(wrapper, makeArrayRef(argsForCall));
+  callInst->setDebugLoc(origCallInst->getDebugLoc());
+
+  // if there was a StoreInst, we remove it
+  if (prevStoreInst) {
+    prevStoreInst->eraseFromParent();
+  } else {
+    // otherwise, we create a LoadInst for the return value at each use
+    if (hasPhiUse) {
+      // FIXME: phi nodes are not easy to handle: 1) we can't add the load as
+      // first instruction of the basic block, 2) we need to find a
+      // precedessor which dominates all the uses.
+      // now relying on unoptimized creation of load
+      Value *load = builder.CreateLoad(allocaInst);
+      origCallInst->replaceAllUsesWith(load);
+    } else {
+      while (origCallInst->getNumUses() > 0) {
+        llvm::Instruction *II = cast<llvm::Instruction>(*origCallInst->use_begin());
+        IRBuilder<> builder_use(II);
+        Value *load = builder_use.CreateLoad(allocaInst);
+        II->replaceUsesOfWith(origCallInst, load);
+      }
+    }
+  }
+}
+
+bool klee::ReturnToVoidFunctionPass::runOnModule(Module &module) {
+  // we assume to have everything linked inside the single .bc file
+  bool dirty = false;
+  for (Module::iterator f = module.begin(), fe = module.end(); f != fe; ++f)
+    dirty |= runOnFunction(*f, module);
+
+  return dirty;
+}
diff --git a/lib/Solver/CMakeLists.txt b/lib/Solver/CMakeLists.txt
index 1302db3..2406a51 100644
--- a/lib/Solver/CMakeLists.txt
+++ b/lib/Solver/CMakeLists.txt
@@ -40,4 +40,8 @@ target_link_libraries(kleaverSolver PRIVATE
   kleaverExpr
   kleeSupport
   ${KLEE_SOLVER_LIBRARIES})
-
+target_include_directories(kleaverSolver PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/lib/Support/CMakeLists.txt b/lib/Support/CMakeLists.txt
index 4e44fbc..dacbfc7 100644
--- a/lib/Support/CMakeLists.txt
+++ b/lib/Support/CMakeLists.txt
@@ -24,3 +24,8 @@ set(LLVM_COMPONENTS
 )
 klee_get_llvm_libs(LLVM_LIBS ${LLVM_COMPONENTS})
 target_link_libraries(kleeSupport PUBLIC ${LLVM_LIBS})
+target_include_directories(kleeSupport PUBLIC
+    ${SVF_ROOT_DIR}/include
+    ${DG_ROOT_DIR}/src
+    ${DG_ROOT_DIR}/tools
+)
diff --git a/runtime/Intrinsic/klee_init_args.c b/runtime/Intrinsic/klee_init_args.c
new file mode 100644
index 0000000..20dcee8
--- /dev/null
+++ b/runtime/Intrinsic/klee_init_args.c
@@ -0,0 +1,152 @@
+//===-- klee_init_env.c ---------------------------------------------------===//
+//
+//                     The KLEE Symbolic Virtual Machine
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "klee/klee.h"
+#ifndef _LARGEFILE64_SOURCE
+#define _LARGEFILE64_SOURCE
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+static void __emit_error(const char *msg) {
+  klee_report_error(__FILE__, __LINE__, msg, "user.err");
+}
+
+/* Helper function that converts a string to an integer, and
+   terminates the program with an error message is the string is not a
+   proper number */
+static long int __str_to_int(char *s, const char *error_msg) {
+  long int res = 0;
+  char c;
+
+  if (!*s) __emit_error(error_msg);
+
+  while ((c = *s++)) {
+    if (c == '\0') {
+      break;
+    } else if (c>='0' && c<='9') {
+      res = res*10 + (c - '0');
+    } else {
+      __emit_error(error_msg);
+    }
+  }
+  return res;
+}
+
+static int __isprint(const char c) {
+  /* Assume ASCII */
+  return (32 <= c && c <= 126);
+}
+
+static int __streq(const char *a, const char *b) {
+  while (*a == *b) {
+    if (!*a)
+      return 1;
+    a++;
+    b++;
+  }
+  return 0;
+}
+
+static char *__get_sym_str(int numChars, char *name) {
+  int i;
+  char *s = malloc(numChars+1);
+  klee_mark_global(s);
+  klee_make_symbolic(s, numChars+1, name);
+
+  for (i=0; i<numChars; i++)
+    klee_posix_prefer_cex(s, __isprint(s[i]));
+
+  s[numChars] = '\0';
+  return s;
+}
+
+static void __add_arg(int *argc, char **argv, char *arg, int argcMax) {
+  if (*argc==argcMax) {
+    __emit_error("too many arguments for klee_init_env");
+  } else {
+    argv[*argc] = arg;
+    (*argc)++;
+  }
+}
+
+void klee_init_args(int* argcPtr, char*** argvPtr) {
+  int argc = *argcPtr;
+  char** argv = *argvPtr;
+
+  int new_argc = 0, n_args;
+  char* new_argv[1024];
+  unsigned max_len, min_argvs, max_argvs;
+  char** final_argv;
+  char sym_arg_name[5] = "arg";
+  unsigned sym_arg_num = 0;
+  int k=0, i;
+
+  sym_arg_name[4] = '\0';
+
+  // Recognize --help when it is the sole argument.
+  if (argc == 2 && __streq(argv[1], "--help")) {
+    __emit_error("klee_init_env\n\n\
+   usage: (klee_init_env) [options] [program arguments]\n\
+  -sym-arg <N>              - Replace by a symbolic argument with length N\n\
+  -sym-args <MIN> <MAX> <N> - Replace by at least MIN arguments and at most\n\
+                              MAX arguments, each with maximum length N\n");
+  }
+
+  while (k < argc) {
+    if (__streq(argv[k], "--sym-arg") || __streq(argv[k], "-sym-arg")) {
+      const char *msg = "--sym-arg expects an integer argument <max-len>";
+      if (++k == argc)
+	__emit_error(msg);
+
+      max_len = __str_to_int(argv[k++], msg);
+      sym_arg_name[3] = '0' + sym_arg_num++;
+      __add_arg(&new_argc, new_argv,
+                __get_sym_str(max_len, sym_arg_name),
+                1024);
+    }
+    else if (__streq(argv[k], "--sym-args") || __streq(argv[k], "-sym-args")) {
+      const char *msg =
+        "--sym-args expects three integer arguments <min-argvs> <max-argvs> <max-len>";
+
+      if (k+3 >= argc)
+	__emit_error(msg);
+
+      k++;
+      min_argvs = __str_to_int(argv[k++], msg);
+      max_argvs = __str_to_int(argv[k++], msg);
+      max_len = __str_to_int(argv[k++], msg);
+
+      n_args = klee_range(min_argvs, max_argvs+1, "n_args");
+      for (i=0; i < n_args; i++) {
+        sym_arg_name[3] = '0' + sym_arg_num++;
+        __add_arg(&new_argc, new_argv,
+                  __get_sym_str(max_len, sym_arg_name),
+                  1024);
+      }
+    }
+    else {
+      /* simply copy arguments */
+      __add_arg(&new_argc, new_argv, argv[k++], 1024);
+    }
+  }
+
+  final_argv = (char**) malloc((new_argc+1) * sizeof(*final_argv));
+  klee_mark_global(final_argv);
+  memcpy(final_argv, new_argv, new_argc * sizeof(*final_argv));
+  final_argv[new_argc] = 0;
+
+  *argcPtr = new_argc;
+  *argvPtr = final_argv;
+}
diff --git a/runtime/Makefile.cmake.bitcode.config.in b/runtime/Makefile.cmake.bitcode.config.in
index 5efa015..2cdbbc7 100644
--- a/runtime/Makefile.cmake.bitcode.config.in
+++ b/runtime/Makefile.cmake.bitcode.config.in
@@ -13,6 +13,7 @@
 LLVMCC := @LLVMCC@
 LLVM_LINK := @LLVM_LINK@
 LLVM_AR := @LLVM_AR@
+LLVM_OPT := @LLVM_OPT@
 LLVM_VERSION_MAJOR := @LLVM_VERSION_MAJOR@
 LLVM_VERSION_MINOR := @LLVM_VERSION_MINOR@
 
@@ -42,6 +43,7 @@ RM := rm
 CMP := cmp
 
 # Compiler flags
+#LLVMCC.ExtraFlags += "-m32"
 LLVMCC.Flags += $(LLVMCC.ExtraFlags) \
 	-I@CMAKE_SOURCE_DIR@/include \
 	-I@CMAKE_BINARY_DIR@/include \
diff --git a/runtime/Makefile.cmake.bitcode.rules b/runtime/Makefile.cmake.bitcode.rules
index 8261ce9..8f26fed 100644
--- a/runtime/Makefile.cmake.bitcode.rules
+++ b/runtime/Makefile.cmake.bitcode.rules
@@ -97,6 +97,7 @@ $(LOCAL_BUILD_DIR)/%.bc : $(SRC_DIR)/%.c
 	@echo "LLVMCC ($(RUNTIME_CONFIG_STRING)) $<"
 	$(Verb) $(MKDIR) -p $(LOCAL_BUILD_DIR)
 	$(Verb) $(LLVMCC) $(LLVMCC.Flags) $(LLVMCC.Warnings) $< -c -o $@ -MP -MMD -MF $(LOCAL_BUILD_DIR)/$*.dep
+	$(Verb) $(LLVM_OPT) -mem2reg $@ -o $@
 
 # $(LLVMCC_FLAGS_FILE) depends on `force` which will force the rule to
 # rerun every build. However the rule will only update the file when the
diff --git a/runtime/POSIX/fd_64.c b/runtime/POSIX/fd_64.c
index 03fccc4..27c8530 100644
--- a/runtime/POSIX/fd_64.c
+++ b/runtime/POSIX/fd_64.c
@@ -107,7 +107,7 @@ int statfs(const char *path, struct statfs *buf) {
   return __fd_statfs(path, buf);
 }
 
-int getdents64(unsigned int fd, struct dirent *dirp, unsigned int count) {
+__ssize_t getdents64(int fd, void *dirp, size_t count) {
   return __fd_getdents(fd, (struct dirent64*) dirp, count);
 }
 int __getdents64(unsigned int fd, struct dirent *dirp, unsigned int count)
diff --git a/runtime/POSIX/fd_init.c b/runtime/POSIX/fd_init.c
index 0cfa578..327ddb5 100644
--- a/runtime/POSIX/fd_init.c
+++ b/runtime/POSIX/fd_init.c
@@ -74,20 +74,20 @@ static void __create_new_dfile(exe_disk_file_t *dfile, unsigned size,
      reasonable. */
   klee_assume((s->st_blksize & ~0xFFFF) == 0);
 
-  klee_posix_prefer_cex(s, !(s->st_mode & ~(S_IFMT | 0777)));
-  klee_posix_prefer_cex(s, s->st_dev == defaults->st_dev);
-  klee_posix_prefer_cex(s, s->st_rdev == defaults->st_rdev);
-  klee_posix_prefer_cex(s, (s->st_mode&0700) == 0600);
-  klee_posix_prefer_cex(s, (s->st_mode&0070) == 0040);
-  klee_posix_prefer_cex(s, (s->st_mode&0007) == 0004);
-  klee_posix_prefer_cex(s, (s->st_mode&S_IFMT) == S_IFREG);
-  klee_posix_prefer_cex(s, s->st_nlink == 1);
-  klee_posix_prefer_cex(s, s->st_uid == defaults->st_uid);
-  klee_posix_prefer_cex(s, s->st_gid == defaults->st_gid);
-  klee_posix_prefer_cex(s, s->st_blksize == 4096);
-  klee_posix_prefer_cex(s, s->st_atime == defaults->st_atime);
-  klee_posix_prefer_cex(s, s->st_mtime == defaults->st_mtime);
-  klee_posix_prefer_cex(s, s->st_ctime == defaults->st_ctime);
+  klee_prefer_cex(s, !(s->st_mode & ~(S_IFMT | 0777)));
+  klee_prefer_cex(s, s->st_dev == defaults->st_dev);
+  klee_prefer_cex(s, s->st_rdev == defaults->st_rdev);
+  klee_prefer_cex(s, (s->st_mode&0700) == 0600);
+  klee_prefer_cex(s, (s->st_mode&0070) == 0040);
+  klee_prefer_cex(s, (s->st_mode&0007) == 0004);
+  klee_prefer_cex(s, (s->st_mode&S_IFMT) == S_IFREG);
+  klee_prefer_cex(s, s->st_nlink == 1);
+  klee_prefer_cex(s, s->st_uid == defaults->st_uid);
+  klee_prefer_cex(s, s->st_gid == defaults->st_gid);
+  klee_prefer_cex(s, s->st_blksize == 4096);
+  klee_prefer_cex(s, s->st_atime == defaults->st_atime);
+  klee_prefer_cex(s, s->st_mtime == defaults->st_mtime);
+  klee_prefer_cex(s, s->st_ctime == defaults->st_ctime);
 
   s->st_size = dfile->size;
   s->st_blocks = 8;
diff --git a/runtime/POSIX/stubs.c b/runtime/POSIX/stubs.c
index b4f31bf..b7869d5 100644
--- a/runtime/POSIX/stubs.c
+++ b/runtime/POSIX/stubs.c
@@ -240,6 +240,7 @@ int strverscmp (__const char *__s1, __const char *__s2) {
   return strcmp(__s1, __s2); /* XXX no doubt this is bad */
 }
 
+/*
 unsigned int gnu_dev_major(unsigned long long int __dev) __attribute__((weak));
 unsigned int gnu_dev_major(unsigned long long int __dev) {
   return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
@@ -256,6 +257,7 @@ unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __mino
           | (((unsigned long long int) (__minor & ~0xff)) << 12)
           | (((unsigned long long int) (__major & ~0xfff)) << 32));
 }
+*/
 
 char *canonicalize_file_name (const char *name) __attribute__((weak));
 char *canonicalize_file_name (const char *name) {
diff --git a/runtime/klee-libc/memset.c b/runtime/klee-libc/memset.c
index 81025d3..31dc588 100644
--- a/runtime/klee-libc/memset.c
+++ b/runtime/klee-libc/memset.c
@@ -10,7 +10,7 @@
 #include <stdlib.h>
 
 void *memset(void * dst, int s, size_t count) {
-    char * a = dst;
+    char *a = dst;
     while (count-- > 0)
       *a++ = s;
     return dst;
diff --git a/runtime/klee-libc/strndup.c b/runtime/klee-libc/strndup.c
new file mode 100644
index 0000000..9963279
--- /dev/null
+++ b/runtime/klee-libc/strndup.c
@@ -0,0 +1,15 @@
+#include <string.h>
+#include <stdlib.h>
+
+char *strndup(const char *s1, size_t n) {
+    char *s;
+
+    n = strnlen(s1, n);
+    if ((s = malloc(n + 1)) != NULL) {
+        memcpy(s, s1, n);
+        s[n] = 0;
+    }
+
+    return s;
+}
+
diff --git a/runtime/klee-libc/strnlen.c b/runtime/klee-libc/strnlen.c
new file mode 100644
index 0000000..63bdcce
--- /dev/null
+++ b/runtime/klee-libc/strnlen.c
@@ -0,0 +1,21 @@
+/*===-- strnlen.c ----------------------------------------------------------===//
+//
+//                     The KLEE Symbolic Virtual Machine
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===*/
+
+#include <string.h>
+
+size_t strnlen(const char *str, size_t max) {
+    const char *p = str;
+
+    while (max && *p) {
+        ++p;
+        --max;
+    }
+
+    return p - str;
+}
diff --git a/test/Feature/ExitOnErrorLocation.c b/test/Feature/ExitOnErrorLocation.c
new file mode 100644
index 0000000..bc2fbe8
--- /dev/null
+++ b/test/Feature/ExitOnErrorLocation.c
@@ -0,0 +1,17 @@
+// RUN: %llvmgcc %s -g -emit-llvm -O0 -c -o %t1.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=bfs -exit-on-error-type Assert -error-location=ExitOnErrorLocation.c:11/13 %t1.bc 2>&1
+
+#include <assert.h>
+#include <klee/klee.h>
+
+int main() {
+  int x = klee_int("x");
+  if (x < 42) {
+	assert(0);
+  } else if (x > 100) {
+	assert(0);
+  }
+  while(1) { }
+  return 0;
+}
diff --git a/test/Slicing/allocation-record.c b/test/Slicing/allocation-record.c
new file mode 100644
index 0000000..20f6391
--- /dev/null
+++ b/test/Slicing/allocation-record.c
@@ -0,0 +1,48 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: %opt -mem2reg %t.bc -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef struct {
+    int x;
+} object_t;
+
+void f(int x, object_t **result) {
+    if (!result) {
+        return;
+    }
+
+    object_t *o = malloc(sizeof(*o));
+    o->x = x;
+
+    *result = o;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t *o;
+
+    f(7, &o);
+	if (o) {
+        if (o->x == 7) {
+            printf("Correct\n");
+        } else {
+            printf("Incorrect\n");
+        }
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/allocation-record2.c b/test/Slicing/allocation-record2.c
new file mode 100644
index 0000000..162334c
--- /dev/null
+++ b/test/Slicing/allocation-record2.c
@@ -0,0 +1,53 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: %opt -mem2reg %t.bc -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 3
+// CHECK-SLICES: KLEE: done: generated slices = 3
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define MAGIX_X (100)
+#define MAGIX_Y (200)
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(int x, int y, object_t **result) {
+    if (!result) {
+        return;
+    }
+
+    object_t *o = malloc(sizeof(*o));
+    o->x = x;
+    o->y = y;
+
+    *result = o;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t *o;
+
+    f(MAGIX_X, MAGIX_Y, &o);
+	if (o) {
+        if (o->x == MAGIX_X && o->y == MAGIX_Y) {
+            printf("Correct\n");
+        } else {
+            printf("Incorrect\n");
+        }
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/allocation-record3.c b/test/Slicing/allocation-record3.c
new file mode 100644
index 0000000..39b495e
--- /dev/null
+++ b/test/Slicing/allocation-record3.c
@@ -0,0 +1,51 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: %opt -mem2reg %t.bc -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define MAGIX_X (100)
+#define MAGIX_Y (200)
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *objects[], size_t count) {
+    for (unsigned int i = 0; i < count; i++) {
+        object_t *o = malloc(sizeof(*o));
+        o->x = MAGIX_X;
+        o->y = MAGIX_Y;
+        objects[i] = o;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t *objects[2];
+
+    f(objects, 2);
+    object_t *o = objects[0];
+	if (o->x) {
+        if (o->x == MAGIX_X) {
+            printf("Correct\n");
+        } else {
+            printf("Incorrect\n");
+        }
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/allocation-record4.c b/test/Slicing/allocation-record4.c
new file mode 100644
index 0000000..b124ab7
--- /dev/null
+++ b/test/Slicing/allocation-record4.c
@@ -0,0 +1,45 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: %opt -mem2reg %t.bc -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 4
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define MAGIX_X (100)
+
+typedef struct {
+    int x;
+} object_t;
+
+object_t *g_object = NULL;
+
+void f() {
+    if (g_object == NULL) {
+        g_object = malloc(sizeof(*g_object));
+        g_object->x = MAGIX_X;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    f();
+    f();
+    if (g_object->x == MAGIX_X) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/allocation-record5.c b/test/Slicing/allocation-record5.c
new file mode 100644
index 0000000..749ce37
--- /dev/null
+++ b/test/Slicing/allocation-record5.c
@@ -0,0 +1,53 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: %opt -mem2reg %t.bc -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 5
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define MAGIX_X (100)
+#define OBJECTS_COUNT (4)
+
+typedef struct {
+    int x;
+} object_t;
+
+object_t *g_objects[OBJECTS_COUNT];
+
+void f() {
+    for (unsigned int i = 0; i < OBJECTS_COUNT; i++) {
+        object_t *o = malloc(sizeof(*o));
+        g_objects[i] = o;
+    }
+}
+
+void g() {
+    for (unsigned int i = 0; i < OBJECTS_COUNT; i++) {
+        g_objects[i]->x = MAGIX_X;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    f();
+    g();
+    object_t *o = g_objects[1];
+    if (o->x == MAGIX_X) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/array-1.c b/test/Slicing/array-1.c
new file mode 100644
index 0000000..565470b
--- /dev/null
+++ b/test/Slicing/array-1.c
@@ -0,0 +1,34 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+// CHECK-A: True branch
+// CHECK-B: False branch
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+void f(char *s) {
+    s[0] = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    char array[10] = {0,};
+
+    f(array);
+    if (array[0] == 7) {
+        printf("True branch\n");
+    } else {
+        printf("False branch\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/array-2.c b/test/Slicing/array-2.c
new file mode 100644
index 0000000..214b6ba
--- /dev/null
+++ b/test/Slicing/array-2.c
@@ -0,0 +1,34 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+// CHECK-A: True branch
+// CHECK-B: False branch
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+void f(char *s) {
+    s[1] = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    char array[10] = {0,};
+
+    f(array);
+    if (array[0] == 0) {
+        printf("True branch\n");
+    } else {
+        printf("False branch\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/array-3.c b/test/Slicing/array-3.c
new file mode 100644
index 0000000..ea85fdf
--- /dev/null
+++ b/test/Slicing/array-3.c
@@ -0,0 +1,44 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 10
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdbool.h>
+
+#include <klee/klee.h>
+
+void f(char *buffer, unsigned int size) {
+    memset(buffer, 7, size);
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    char buffer[10] = {0,};
+
+    f(buffer, sizeof(buffer));
+
+    bool valid = true;
+    for (unsigned int i = 0; i < sizeof(buffer); i++) {
+        if (buffer[i] != 7) {
+            valid = false;
+            break;
+        }
+    }
+
+    if (valid) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/array-4.c b/test/Slicing/array-4.c
new file mode 100644
index 0000000..0141943
--- /dev/null
+++ b/test/Slicing/array-4.c
@@ -0,0 +1,41 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdbool.h>
+
+#include <klee/klee.h>
+
+void f(short *buffer) {
+    buffer[0] = 1000;
+}
+
+void g(short *buffer) {
+    buffer[1] = 2000;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    short buffer[10] = {0,};
+
+    f(buffer);
+    g(buffer);
+
+    if (buffer[0] == 1000) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/array-5.c b/test/Slicing/array-5.c
new file mode 100644
index 0000000..79786dd
--- /dev/null
+++ b/test/Slicing/array-5.c
@@ -0,0 +1,36 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdbool.h>
+
+#include <klee/klee.h>
+
+void f(unsigned char *buffer) {
+    buffer[0] = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    unsigned char buffer[10] = {0,};
+
+    f(buffer);
+    memset(buffer, 1, sizeof(buffer));
+    if (buffer[0] == 1) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/array-6.c b/test/Slicing/array-6.c
new file mode 100644
index 0000000..c59e9fe
--- /dev/null
+++ b/test/Slicing/array-6.c
@@ -0,0 +1,36 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+// CHECK-A: Correct
+// CHECK-B: Incorrect
+
+#include <stdio.h>
+#include <stdbool.h>
+
+#include <klee/klee.h>
+
+void f(unsigned char *buffer, size_t size) {
+    memset(buffer, 7, size);
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    unsigned char buffer[10] = {0,};
+
+    f(buffer, sizeof(buffer));
+    buffer[0] = 1;
+    if (buffer[1] == 7) {
+        printf("Correct\n");
+    } else {
+        printf("Incorrect\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/basic.c b/test/Slicing/basic.c
new file mode 100644
index 0000000..5f59d67
--- /dev/null
+++ b/test/Slicing/basic.c
@@ -0,0 +1,25 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <assert.h>
+
+void foo(int *a)
+{
+	++a;
+	*a = 8;
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	int a[2] = {0,1};
+	foo(a);
+	assert(a[1] == 8);
+	return 0;
+}
diff --git a/test/Slicing/consecutive-dependent-functions.c b/test/Slicing/consecutive-dependent-functions.c
new file mode 100644
index 0000000..d4353cd
--- /dev/null
+++ b/test/Slicing/consecutive-dependent-functions.c
@@ -0,0 +1,41 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+  int x;
+  int y;
+  int z;
+} point;
+
+void f(point *o) {
+  o->x++;
+}
+
+void g(point *o) {
+  o->x = o->y * 2 + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+  point o;
+  o.x = 1; o.y = 1; o.z = 1;
+
+  f(&o);
+  g(&o);
+  if (o.x == 3) {
+    printf("x is 3\n");
+  } else {
+    printf("x is not 3\n");
+  }
+
+  return 0;
+}
diff --git a/test/Slicing/dependent-functions.c b/test/Slicing/dependent-functions.c
new file mode 100644
index 0000000..67ae281
--- /dev/null
+++ b/test/Slicing/dependent-functions.c
@@ -0,0 +1,69 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g,h %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Z
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 3
+// CHECK-SLICES: KLEE: done: generated slices = 3
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+// CHECK-A:a is 3
+// CHECK-B:b is 2
+// CHECK-Z:z is gt 3
+// CHECK-ANOT:a is not 3
+// CHECK-BNOT:b is not 2
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o) {
+	o->x++;
+}
+
+void g(point *o) {
+	o->y = o->x * 2 + 1;
+}
+
+void h(point *o) {
+	o->z = o->y + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1; o.y = 0; o.z = 0;
+    int a,b;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+
+    f(&o);
+    if (a == 3) {
+    	printf("a is 3\n");
+    } else {
+    	printf("a is not 3\n");
+    	g(&o);
+    	if (b == 2) {
+    		printf("b is 2\n");
+    		h(&o);
+    		if (o.z > 3) {
+    			printf("z is gt 3\n");
+    		}
+    	} else {
+    		printf("b is not 2\n");
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/dynamic-list.c b/test/Slicing/dynamic-list.c
new file mode 100644
index 0000000..66e3b95
--- /dev/null
+++ b/test/Slicing/dynamic-list.c
@@ -0,0 +1,33 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=insert_list %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdlib.h>
+#include <assert.h>
+
+typedef struct list {
+    int key;
+    struct list *next;
+} mlist;
+
+mlist *head;
+
+void insert_list(int k){
+    mlist *l = (mlist*) malloc(sizeof(mlist));
+    l->key = k;
+    head = l;
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+    mlist *temp;
+
+    insert_list(2);
+    assert(head->key == 2);
+}
diff --git a/test/Slicing/field-sensitivity.c b/test/Slicing/field-sensitivity.c
new file mode 100644
index 0000000..ffa5d07
--- /dev/null
+++ b/test/Slicing/field-sensitivity.c
@@ -0,0 +1,42 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-CORRECT
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-INCORRECT
+
+// CHECK-CORRECT: correct
+// CHECK-INCORRECT: incorrect
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 0
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *o) {
+    o->x++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t o = {
+        .x = 0,
+        .y = 0
+    };
+
+    f(&o);
+    if (o.y) {
+        printf("incorrect\n");
+    } else {
+        printf("correct\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/fork.c b/test/Slicing/fork.c
new file mode 100644
index 0000000..d63fc25
--- /dev/null
+++ b/test/Slicing/fork.c
@@ -0,0 +1,43 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-T
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-F
+
+// CHECK-T: True branch
+// CHECK-F: False branch
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *o) {
+    o->x = 0;
+    o->y = 0;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t o;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o);
+    if (k > 0) {
+        printf("True branch %d\n", o.x);
+    } else {
+        printf("False branch %d\n", o.y);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/function-pointer.c b/test/Slicing/function-pointer.c
new file mode 100644
index 0000000..8566590
--- /dev/null
+++ b/test/Slicing/function-pointer.c
@@ -0,0 +1,32 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=call %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <assert.h>
+
+int glob;
+
+void setglob(void)
+{
+	glob = 8;
+}
+
+void (*funcarray[10])(void) = {setglob};
+
+void call(void (**funcarray)(void), int idx)
+{
+	funcarray[idx]();
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	call(funcarray, 0);
+	assert(glob == 8);
+	return 0;
+}
diff --git a/test/Slicing/function-pointer2.c b/test/Slicing/function-pointer2.c
new file mode 100644
index 0000000..3d38fbc
--- /dev/null
+++ b/test/Slicing/function-pointer2.c
@@ -0,0 +1,37 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=call %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <assert.h>
+
+int glob;
+
+void setglob(void)
+{
+	glob = 8;
+}
+
+void setglob2(void)
+{
+	glob = 13;
+}
+
+void (*funcarray[10])(void) = {setglob, setglob2};
+
+void call(void (**funcarray)(void), int idx)
+{
+	funcarray[idx]();
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	call(funcarray, 1);
+	assert(glob == 13);
+	return 0;
+}
diff --git a/test/Slicing/function-pointer3.c b/test/Slicing/function-pointer3.c
new file mode 100644
index 0000000..d853846
--- /dev/null
+++ b/test/Slicing/function-pointer3.c
@@ -0,0 +1,33 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+
+int glob;
+
+int *setglob(void)
+{
+	glob = 23;
+    return NULL;
+}
+
+void foo(int *(f)(void), int **result)
+{
+	*result = f();
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	int *p;
+	foo(setglob, &p);
+	assert(glob == 23);
+	return 0;
+}
diff --git a/test/Slicing/guiding-constraints-in-recovery-state.c b/test/Slicing/guiding-constraints-in-recovery-state.c
new file mode 100644
index 0000000..cb005a7
--- /dev/null
+++ b/test/Slicing/guiding-constraints-in-recovery-state.c
@@ -0,0 +1,51 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 4
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A: x = 0, y = 1
+// CHECK-B: x = 1, y = 2
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *p, int k) {
+    if (k == 0) {
+        p->x = 0;
+    } else {
+        p->x = 1;
+    }
+}
+
+void g(point *p) {
+    p->y = p->x + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 0,
+        .y = 0
+    };
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    g(&o);
+    printf("x = %d, y = %d\n", o.x, o.y);
+
+    return 0;
+}
diff --git a/test/Slicing/guiding-constraints.c b/test/Slicing/guiding-constraints.c
new file mode 100644
index 0000000..cba700d
--- /dev/null
+++ b/test/Slicing/guiding-constraints.c
@@ -0,0 +1,50 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-C
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A: x = 1
+// CHECK-B: x = 2
+// CHECK-C: adding 1 guiding constraints
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *p, int k) {
+    if (k > 0) {
+        p->x = 1;
+    } else {
+        p->x = 2;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 0,
+        .y = 0
+    };
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    if (k > 1) {
+        printf("x = %d\n", o.x);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/guiding-constraints2.c b/test/Slicing/guiding-constraints2.c
new file mode 100644
index 0000000..f619de5
--- /dev/null
+++ b/test/Slicing/guiding-constraints2.c
@@ -0,0 +1,57 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-C
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 4
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+// CHECK-A: x = 1
+// CHECK-B: x = 2
+// CHECK-C: y = 7
+// CHECK-D: adding 0 guiding constraints
+// CHECK-E: adding 1 guiding constraints
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *p, int k) {
+    if (k > 0) {
+        p->x = 1;
+    } else {
+        p->x = 2;
+    }
+}
+
+void g(point *p) {
+    p->y = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 0,
+        .y = 0
+    };
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    printf("x = %d\n", o.x);
+
+    g(&o);
+    printf("y = %d\n", o.y);
+
+    return 0;
+}
diff --git a/test/Slicing/guiding-constraints3.c b/test/Slicing/guiding-constraints3.c
new file mode 100644
index 0000000..60b83cf
--- /dev/null
+++ b/test/Slicing/guiding-constraints3.c
@@ -0,0 +1,59 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-C
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 3
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A: x = 1
+// CHECK-B: x = 2
+// CHECK-C: y = 7
+// CHECK-D: adding 0 guiding constraints
+// CHECK-E: adding 2 guiding constraints
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *p, int k) {
+    if (k > 0) {
+        p->x = 1;
+    } else {
+        p->x = 2;
+    }
+}
+
+void g(point *p) {
+    p->y = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 0,
+        .y = 0
+    };
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    printf("x = %d\n", o.x);
+
+    if (k > 1) {
+        g(&o);
+        printf("y = %d\n", o.y);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/independent-functions.c b/test/Slicing/independent-functions.c
new file mode 100644
index 0000000..224d9e1
--- /dev/null
+++ b/test/Slicing/independent-functions.c
@@ -0,0 +1,67 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g,h %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Z
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A:a is 3
+// CHECK-B:b is 2
+// CHECK-Z:z is gt 3
+// CHECK-ANOT:a is not 3
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o) {
+	o->x++;
+}
+
+void g(point *o) {
+	o->y *= 2 + 1;
+}
+
+void h(point *o) {
+	o->z += 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1; o.y = 1; o.z = 1;
+    int a,b;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+
+    f(&o);
+    if (a == 3) {
+    	printf("a is 3\n");
+    } else {
+    	printf("a is not 3\n");
+    	g(&o);
+    	if (o.x == 2) {
+    		printf("b is 2\n");
+    		h(&o);
+    		if (o.z > 0) {
+    			printf("z is gt 3\n");
+    		}
+    	} else {
+    		printf("b is not 2\n");
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/infeasible.c b/test/Slicing/infeasible.c
new file mode 100644
index 0000000..30a96a1
--- /dev/null
+++ b/test/Slicing/infeasible.c
@@ -0,0 +1,64 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Y
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-YNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 4
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A:k is 3
+// CHECK-ANOT:k is not 3
+// CHECK-Y:y is gt 2
+// CHECK-YNOT:y is not gt 2
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int *a) {
+	if (*a > 0)
+		o->x++;
+	else
+		o->x--;
+}
+
+void g(point *o) {
+    o->y = o->x * 2 + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 1,
+        .y = 0
+    };
+    int a,k;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, &a);
+    if (k == 3) {
+    	printf("k is 3\n");
+    } else {
+    	printf("k is not 3\n");
+    	g(&o);
+        if (o.y > 2) {
+            printf("y is gt 2\n");
+        } else {
+            printf("y is not gt 2\n");
+        }
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/infeasible2.c b/test/Slicing/infeasible2.c
new file mode 100644
index 0000000..d14b42c
--- /dev/null
+++ b/test/Slicing/infeasible2.c
@@ -0,0 +1,57 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A: a is gt 0
+// CHECK-ANOT: a is not gt 0
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+} point;
+
+void f(point *o, int *a) {
+	if (*a > 0) {
+		printf("incrementing x\n");
+		o->x++;
+	}
+	else {
+		printf("decrementing x\n");
+		o->x--;
+	}
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1;
+    int a;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    int c = a;
+
+    f(&o, &a);
+    if (c > 0) {
+    	printf("a is gt 0\n");
+    	if (o.x == 0) {
+    		assert(0);
+    	}
+    } else {
+    	printf("a is not gt 0\n");
+    	if (o.x == 2) {
+    		assert(0);
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/infeasible3.c b/test/Slicing/infeasible3.c
new file mode 100644
index 0000000..d5481c9
--- /dev/null
+++ b/test/Slicing/infeasible3.c
@@ -0,0 +1,68 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 5
+// CHECK-STATES: KLEE: done: recovery states = 6
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-A:k is 3
+// CHECK-ANOT:k is not 3
+// CHECK-B:y is gt 2
+// CHECK-BNOT:y is not gt 2
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int *a) {
+	if (*a > 0)
+		o->x++;
+	else
+		o->x--;
+}
+
+void g(point *o, int *b) {
+	if (*b > 0)
+		o->y = o->x * 2 + 1;
+	else
+		o->y = o->x + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 1,
+        .y = 0
+    };
+    int a,b,k;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, &a);
+    if (k == 3) {
+    	printf("k is 3\n");
+    } else {
+    	printf("k is not 3\n");
+    	g(&o, &b);
+        if (o.y > 2) {
+            printf("y is gt 2\n"); 
+        } else {
+            printf("y is not gt 2\n"); 
+        }
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/infeasible4.c b/test/Slicing/infeasible4.c
new file mode 100644
index 0000000..cc71819
--- /dev/null
+++ b/test/Slicing/infeasible4.c
@@ -0,0 +1,82 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g,h %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Z
+
+// CHECK-PATHS: KLEE: done: completed paths = 7
+// CHECK-STATES: KLEE: done: recovery states = 11
+// CHECK-SLICES: KLEE: done: generated slices = 3
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+// CHECK-A:k is 3
+// CHECK-ANOT:k is not
+// CHECK-B:k is 2
+// CHECK-BNOT:k is not 2
+// CHECK-Z:z is gt 3
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o, int *a) {
+    if (*a > 0)
+        o->x++;
+    else
+        o->x--;
+}
+
+void g(point *o, int *b) {
+    if (*b > 0)
+        o->y = o->x * 2 + 1;
+    else
+        o->y = o->x + 1;
+}
+
+void h(point *o, int *c) {
+    if (*c > 0)
+        o->z = o->y + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o = {
+        .x = 1,
+        .y = 0,
+        .z = 0
+    };
+    int a,b,c,k;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+    klee_make_symbolic(&c, sizeof(b), "c");
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, &a);
+    if (k == 3) {
+        printf("k is 3\n");
+    } else {
+        printf("k is not 3\n");
+        g(&o, &b);
+        if (k == 2) {
+            printf("k is 2\n");
+            h(&o, &c);
+            if (o.z > 3) {
+                printf("z is gt 3\n");
+            }
+        } else {
+            printf("k is not 2\n");
+        }
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/libc-atexit.c b/test/Slicing/libc-atexit.c
new file mode 100644
index 0000000..085d791
--- /dev/null
+++ b/test/Slicing/libc-atexit.c
@@ -0,0 +1,24 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out --libc=klee -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out --libc=uclibc -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 0
+
+
+#include<stdio.h>
+
+void foo() {
+	printf("At exit\n");
+}
+
+int main() {
+  atexit(foo);
+  return 0;
+}
diff --git a/test/Slicing/malloc.c b/test/Slicing/malloc.c
new file mode 100644
index 0000000..9ef5011
--- /dev/null
+++ b/test/Slicing/malloc.c
@@ -0,0 +1,28 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdlib.h>
+#include <assert.h>
+
+void foo(int **result)
+{
+	int *i = malloc(sizeof *i);
+    *result = i;
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	int *a = NULL;
+    foo(&a);
+	*a = 3;
+	assert(*a == 3);
+
+	return 0;
+}
diff --git a/test/Slicing/multiple-allocsite-multiple-callsite.c b/test/Slicing/multiple-allocsite-multiple-callsite.c
new file mode 100644
index 0000000..9cc7f25
--- /dev/null
+++ b/test/Slicing/multiple-allocsite-multiple-callsite.c
@@ -0,0 +1,61 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-XZERO
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-XONE
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-X2ZERO
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-X2ONE
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-X3ZERO
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-X3ONE
+
+// CHECK-PATHS: KLEE: done: completed paths = 4
+// CHECK-STATES: KLEE: done: recovery states = 5
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+// CHECK-XZERO: x: 0
+// CHECK-XONE: x: 1
+// CHECK-X2ZERO: x2: 0
+// CHECK-X2ONE: x2: 1
+// CHECK-X3ZERO: x3: 0
+// CHECK-X3ONE: x3: 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o) {
+	o->x++;
+	o->y++;
+}
+
+void call(point *o, int k) {
+    f(o);
+    if (k > 0) {
+    	printf("x: %d\n", o->x);
+    	printf("x2: %d\n", o->x);
+    } else {
+    	printf("x3: %d\n", o->x);
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o, o2;
+    o.x = 0; o.y = 0;
+    o2.x = -1; o2.y = -1;
+    int k,j;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+    klee_make_symbolic(&j, sizeof(j), "j");
+
+    call(&o, k);
+    call(&o2, j);
+
+    return 0;
+}
diff --git a/test/Slicing/multiple-slices.c b/test/Slicing/multiple-slices.c
new file mode 100644
index 0000000..9d2ccab
--- /dev/null
+++ b/test/Slicing/multiple-slices.c
@@ -0,0 +1,50 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 4
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int k) {
+    if (k > 0) {
+    	o->x++;
+    } else {
+        o->y++;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 0; o.y = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    if (o.x > 0) {
+    	printf("x greater than zero\n");
+        if (o.y > 0) {
+        	assert(0);
+        }
+    }
+    if (o.y > 0) {
+    	printf("y greater than zero\n");
+    	if (o.x > 0) {
+    		assert(0);
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/no-skip-function-in-body.c b/test/Slicing/no-skip-function-in-body.c
new file mode 100644
index 0000000..270a44c
--- /dev/null
+++ b/test/Slicing/no-skip-function-in-body.c
@@ -0,0 +1,25 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: not %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo2 %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ERROR
+
+// CHECK-ERROR: KLEE: ERROR: skip-function option: 'foo2' not found in module
+
+#include <stdlib.h>
+#include <assert.h>
+
+void foo(int **result)
+{
+	int *i = malloc(sizeof *i);
+    *result = i;
+}
+
+int main(int argc, char *argv[], char *envp[])
+{
+	int *a = NULL;
+    foo(&a);
+	*a = 3;
+	assert(*a == 3);
+
+	return 0;
+}
diff --git a/test/Slicing/non-void-skip-without-recovery.c b/test/Slicing/non-void-skip-without-recovery.c
new file mode 100644
index 0000000..9a261c5
--- /dev/null
+++ b/test/Slicing/non-void-skip-without-recovery.c
@@ -0,0 +1,29 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-RECOVERY: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 0
+
+#include <stdio.h>
+
+int foo(int a) {
+    return ++a;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    int ret = foo(10);
+    int a;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    if (a > 123) {
+    	printf("First\n");
+    } else {
+    	printf("Second\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/non-void-skip-without-recovery2.c b/test/Slicing/non-void-skip-without-recovery2.c
new file mode 100644
index 0000000..5513ec8
--- /dev/null
+++ b/test/Slicing/non-void-skip-without-recovery2.c
@@ -0,0 +1,29 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-RECOVERY: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 0
+
+#include <stdio.h>
+
+int foo(int a) {
+    return ++a;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    foo(10);
+    int a;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    if (a > 123) {
+    	printf("First\n");
+    } else {
+       printf("Second\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/non-void-skip.c b/test/Slicing/non-void-skip.c
new file mode 100644
index 0000000..ba5a79c
--- /dev/null
+++ b/test/Slicing/non-void-skip.c
@@ -0,0 +1,33 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+
+int foo(int a) {
+	return ++a;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+	int ret = foo(10);
+    int a;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    if (a > 123) {
+    	printf("First\n");
+    } else {
+    	if (ret > a) {
+        	printf("Second\n");
+    	} else {
+        	printf("Third\n");
+    	}
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/non-void-skip2.c b/test/Slicing/non-void-skip2.c
new file mode 100644
index 0000000..2563f20
--- /dev/null
+++ b/test/Slicing/non-void-skip2.c
@@ -0,0 +1,34 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+
+int foo(int a) {
+    return ++a;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    int ret = foo(10);
+    int a;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    if (a > 123) {
+    	printf("First\n");
+    } else {
+    	int ret2 = ret;
+    	if (ret2 > a) {
+        	printf("Second\n");
+    	} else {
+        	printf("Third\n");
+    	}
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/overriding-store-non-void.c b/test/Slicing/overriding-store-non-void.c
new file mode 100644
index 0000000..a45676d
--- /dev/null
+++ b/test/Slicing/overriding-store-non-void.c
@@ -0,0 +1,30 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+int f(int k) {
+  return ++k;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    int k;
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    int ret = f(k);
+    ret = 876;
+    if (k > 0) {
+    	printf("ret: %d\n", ret);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/overriding-store-non-void2.c b/test/Slicing/overriding-store-non-void2.c
new file mode 100644
index 0000000..805c009
--- /dev/null
+++ b/test/Slicing/overriding-store-non-void2.c
@@ -0,0 +1,42 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int w;
+    int z;
+} point;
+
+point f() {
+	point o;
+	o.x = 0; o.y = 0; o.w = 0; o.z = 0;
+	o.x++;
+	o.y++;
+	return o;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    point o = f();
+    o.x = 876; // overriding store, but too complex to catch in the pass
+    if (k > 0) {
+    	printf("x: %d\n", o.x);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/overriding-store.c b/test/Slicing/overriding-store.c
new file mode 100644
index 0000000..43162c5
--- /dev/null
+++ b/test/Slicing/overriding-store.c
@@ -0,0 +1,39 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int k) {
+	o->x++;
+	o->y++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 0; o.y = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    o.x = 876;
+    if (k > 0) {
+    	printf("x: %d\n", o.x);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/overriding-store2.c b/test/Slicing/overriding-store2.c
new file mode 100644
index 0000000..6293c14
--- /dev/null
+++ b/test/Slicing/overriding-store2.c
@@ -0,0 +1,39 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int k) {
+	o->x++;
+	o->y++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 0; o.y = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    o.y = 876;
+    if (k > 0) {
+    	printf("x: %d\n", o.x);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/random-path-searcher.c b/test/Slicing/random-path-searcher.c
new file mode 100644
index 0000000..d0c9e6e
--- /dev/null
+++ b/test/Slicing/random-path-searcher.c
@@ -0,0 +1,67 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=random-path -skip-functions=f,g,h %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS
+// -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES
+// -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Z
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 3
+// CHECK-SLICES: KLEE: done: generated slices = 3
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+// CHECK-A:a is 3
+// CHECK-B:b is 2
+// CHECK-Z:z is gt 3
+// CHECK-ANOT:a is not 3
+// CHECK-BNOT:b is not 2
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+  int x;
+  int y;
+  int z;
+} point;
+
+void f(point *o) { o->x++; }
+
+void g(point *o) { o->y = o->x * 2 + 1; }
+
+void h(point *o) { o->z = o->y + 1; }
+
+int main(int argc, char *argv[], char *envp[]) {
+  point o;
+  o.x = 1;
+  o.y = 0;
+  o.z = 0;
+  int a, b;
+
+  klee_make_symbolic(&a, sizeof(a), "a");
+  klee_make_symbolic(&b, sizeof(b), "b");
+
+  f(&o);
+  if (a == 3) {
+    printf("a is 3\n");
+  } else {
+    printf("a is not 3\n");
+    g(&o);
+    if (b == 2) {
+      printf("b is 2\n");
+      h(&o);
+      if (o.z > 3) {
+        printf("z is gt 3\n");
+      }
+    } else {
+      printf("b is not 2\n");
+    }
+  }
+
+  return 0;
+}
diff --git a/test/Slicing/regression-pass.c b/test/Slicing/regression-pass.c
new file mode 100644
index 0000000..42e3395
--- /dev/null
+++ b/test/Slicing/regression-pass.c
@@ -0,0 +1,29 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PRINTF -check-prefix=CHECK-PTA
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-PRINTF: KLEE: WARNING ONCE: calling external: printf(
+// CHECK-PTA: INFO: Points-to analysis took
+
+int foo(int x) {
+  return x + 1;
+}
+
+int main() {
+  int k;
+  klee_make_symbolic(&k, sizeof(k), "k");
+
+  int r = foo(7);
+  if (k) {
+    printf("%d\n", r);
+  } else {
+    printf("\n");
+  }
+}
diff --git a/test/Slicing/single-allocsite-multiple-callsite.c b/test/Slicing/single-allocsite-multiple-callsite.c
new file mode 100644
index 0000000..18f8138
--- /dev/null
+++ b/test/Slicing/single-allocsite-multiple-callsite.c
@@ -0,0 +1,40 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+//  FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: grep -c x: %t.out | grep 3
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int k) {
+	o->x++;
+	o->y++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 0; o.y = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    if (k > 0) {
+    	printf("x: %d\n", o.x);
+    }
+    printf("x: %d\n", o.x);
+
+    return 0;
+}
diff --git a/test/Slicing/single-allocsite-multiple-callsite2.c b/test/Slicing/single-allocsite-multiple-callsite2.c
new file mode 100644
index 0000000..0d781a0
--- /dev/null
+++ b/test/Slicing/single-allocsite-multiple-callsite2.c
@@ -0,0 +1,41 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 4
+// CHECK-STATES: KLEE: done: recovery states = 11
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 3
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+void foo(int **result, int *k) {
+	int *i = malloc(sizeof *i);
+    *result = i;
+    if (*k > 0) {
+    	**result = 0;
+    } else {
+    	**result = 987641;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+	int k,j;
+	klee_make_symbolic(&k, sizeof(k), "k");
+	klee_make_symbolic(&j, sizeof(j), "j");
+
+	int *a = NULL;
+    foo(&a, &k);
+    if (*a < 3) {
+    	printf("got a\n");
+    }
+    foo(&a, &j);
+    if (*a > 3) {
+    	printf("a gt 3\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/single-allocsite-multiple-callsite3.c b/test/Slicing/single-allocsite-multiple-callsite3.c
new file mode 100644
index 0000000..0c33eb5
--- /dev/null
+++ b/test/Slicing/single-allocsite-multiple-callsite3.c
@@ -0,0 +1,48 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=foo,bar %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 4
+// CHECK-STATES: KLEE: done: recovery states = 8
+// CHECK-SLICES: KLEE: done: generated slices = 4
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+void foo(int **result, int *k) {
+	int *i = malloc(sizeof *i);
+    *result = i;
+    if (*k > 0) {
+    	**result = 0;
+    } else {
+    	**result = 987641;
+    }
+}
+
+void bar(int **result, int *k) {
+	int *i = malloc(sizeof *i);
+    *result = i;
+    if (*k > 0) {
+    	**result = -1;
+    } else {
+    	**result = 123;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+	int k,j;
+	klee_make_symbolic(&k, sizeof(k), "k");
+	klee_make_symbolic(&j, sizeof(j), "j");
+
+	int *a = NULL;
+    foo(&a, &k);
+    bar(&a, &j);
+    if (*a > 3) {
+    	printf("a gt 3\n");
+    }
+
+	return 0;
+}
diff --git a/test/Slicing/single-allocsite-single-callsite.c b/test/Slicing/single-allocsite-single-callsite.c
new file mode 100644
index 0000000..b76b09f
--- /dev/null
+++ b/test/Slicing/single-allocsite-single-callsite.c
@@ -0,0 +1,38 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+//  FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} point;
+
+void f(point *o, int k) {
+	o->x++;
+	o->y++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 0; o.y = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    if (k > 0) {
+    	printf("x: %d\n", o.x);
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-called-function.c b/test/Slicing/skip-called-function.c
new file mode 100644
index 0000000..80fde6e
--- /dev/null
+++ b/test/Slicing/skip-called-function.c
@@ -0,0 +1,69 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Y
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A:a is 3
+// CHECK-B:b is 2
+// CHECK-Y:y is gt 3
+// CHECK-ANOT:a is not 3
+// CHECK-BNOT:b is not 2
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o) {
+	o->x++;
+}
+
+void g(point *o) {
+	f(o);
+	o->y = o->x * 2 + 1;
+}
+
+void h(point *o) {
+	g(o);
+	o->z = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1; o.y = 0; o.z = 0;
+    int a,b;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+
+    if (a == 3) {
+    	printf("a is 3\n");
+    } else {
+    	printf("a is not 3\n");
+    	if (b == 2) {
+    		printf("b is 2\n");
+    		h(&o);
+    		if (o.y > 3) {
+    			printf("y is gt 3\n");
+    		}
+    	} else {
+    		printf("b is not 2\n");
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-calling-function.c b/test/Slicing/skip-calling-function.c
new file mode 100644
index 0000000..e37b4fa
--- /dev/null
+++ b/test/Slicing/skip-calling-function.c
@@ -0,0 +1,69 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=h %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Z
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-ANOT
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-BNOT
+
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+// CHECK-A:a is 3
+// CHECK-B:b is 2
+// CHECK-Z:z is gt 3
+// CHECK-ANOT:a is not 3
+// CHECK-BNOT:b is not 2
+
+#include <stdio.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o) {
+	o->x++;
+}
+
+void g(point *o) {
+	f(o);
+	o->y = 2 + 1;
+}
+
+void h(point *o) {
+	g(o);
+	o->z = 7;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1; o.y = 0; o.z = 0;
+    int a,b;
+
+    klee_make_symbolic(&a, sizeof(a), "a");
+    klee_make_symbolic(&b, sizeof(b), "b");
+
+    if (a == 3) {
+    	printf("a is 3\n");
+    } else {
+    	printf("a is not 3\n");
+    	if (b == 2) {
+    		printf("b is 2\n");
+    		h(&o);
+    		if (o.z > 3) {
+    			printf("z is gt 3\n");
+    		}
+    	} else {
+    		printf("b is not 2\n");
+    	}
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-multiple-without-recovery.c b/test/Slicing/skip-multiple-without-recovery.c
new file mode 100644
index 0000000..c1582d8
--- /dev/null
+++ b/test/Slicing/skip-multiple-without-recovery.c
@@ -0,0 +1,49 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-CORRECT
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-INCORRECT
+
+// CHECK-CORRECT: correct
+// CHECK-INCORRECT: incorrect
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} object_t;
+
+void f(object_t *o) {
+    o->x++;
+}
+
+void g(object_t *o) {
+    o->y = o->x + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t o = {
+        .x = 0,
+        .y = 0,
+        .z = 1
+    };
+
+    f(&o);
+    g(&o);
+    if (o.z) {
+        printf("correct\n");
+    } else {
+        printf("incorrect\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-switch.c b/test/Slicing/skip-switch.c
new file mode 100644
index 0000000..b546548
--- /dev/null
+++ b/test/Slicing/skip-switch.c
@@ -0,0 +1,55 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -debug-only=basic -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-A
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-B
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-C
+
+// CHECK-A: x is 10
+// CHECK-B: x is 20
+// CHECK-C: adding 1 guiding constraints
+// CHECK-PATHS: KLEE: done: completed paths = 3
+// CHECK-STATES: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *o, int k) {
+    switch (k) {
+    case 0:
+        o->x = 0;
+        break;
+
+    case 1:
+        o->x = 10;
+        break;
+
+    default:
+        o->x = 20;
+        break;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t o;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, k);
+    if (k > 0) {
+        printf("x is %d\n", o.x);
+    }
+
+    return 0;
+}
+
diff --git a/test/Slicing/skip-with-buffer.c b/test/Slicing/skip-with-buffer.c
new file mode 100644
index 0000000..a1a8cfd
--- /dev/null
+++ b/test/Slicing/skip-with-buffer.c
@@ -0,0 +1,41 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=target %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 1
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <assert.h>
+
+#include <klee/klee.h>
+
+#define BUG() \
+{ \
+    char *p = NULL; \
+    *p = 0; \
+}
+
+#define SIZE 10
+
+void target(char buf[SIZE], size_t size) {
+    for (unsigned int i = 0; i < size; i++) {
+        buf[i] = i % 2;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    char buf[SIZE];
+
+    target(buf, sizeof(buf));
+    if (buf[7] == 1) {
+        BUG();
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-with-buffer2.c b/test/Slicing/skip-with-buffer2.c
new file mode 100644
index 0000000..d2a82d7
--- /dev/null
+++ b/test/Slicing/skip-with-buffer2.c
@@ -0,0 +1,45 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=target %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-RECOVERY -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-RECOVERY: KLEE: done: recovery states = 2
+// CHECK-SLICES: KLEE: done: generated slices = 1
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <assert.h>
+
+#include <klee/klee.h>
+
+#define BUG() \
+{ \
+    char *p = NULL; \
+    *p = 0; \
+}
+
+#define SIZE 10
+
+void target(char buf[SIZE], size_t size) {
+
+    for (unsigned int i = 0; i < size; i++) {
+        buf[i] = i % 2;
+    }
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    char buf[SIZE];
+
+    target(buf, sizeof(buf));
+    if (buf[0] == 1) {
+        BUG();
+    }
+    if (buf[1] == 1) {
+        BUG();
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/skip-without-recovery.c b/test/Slicing/skip-without-recovery.c
new file mode 100644
index 0000000..92cce9e
--- /dev/null
+++ b/test/Slicing/skip-without-recovery.c
@@ -0,0 +1,47 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -search=dfs -skip-functions=f %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-CORRECT
+// RUN: not FileCheck %s -input-file=%t.out -check-prefix=CHECK-INCORRECT
+
+// CHECK-CORRECT: correct
+// CHECK-INCORRECT: incorrect
+// CHECK-PATHS: KLEE: done: completed paths = 1
+// CHECK-STATES: KLEE: done: recovery states = 0
+// CHECK-SLICES: KLEE: done: generated slices = 0
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 0
+
+#include <stdio.h>
+
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+} object_t;
+
+void f(object_t *o) {
+    o->x++;
+    o->y++;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    object_t o1 = {
+        .x = 0,
+        .y = 0
+    };
+    object_t o2 = {
+        .x = 0,
+        .y = 0
+    };
+
+    f(&o1);
+    if (o2.x) {
+        printf("incorrect\n");
+    } else {
+        printf("correct\n");
+    }
+
+    return 0;
+}
diff --git a/test/Slicing/test-check-consistency.c b/test/Slicing/test-check-consistency.c
new file mode 100644
index 0000000..f1d7b29
--- /dev/null
+++ b/test/Slicing/test-check-consistency.c
@@ -0,0 +1,59 @@
+// RUN: %llvmgcc %s -emit-llvm -O0 -c -o %t.bc
+// RUN: rm -rf %t.klee-out
+// RUN: %klee --output-dir=%t.klee-out -exit-on-error -search=dfs -skip-functions=f,g %t.bc > %t.out 2>&1
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-PATHS -check-prefix=CHECK-STATES -check-prefix=CHECK-SLICES -check-prefix=CHECK-SNAPSHOTS
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-X
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-Y
+// RUN: FileCheck %s -input-file=%t.out -check-prefix=CHECK-OTHER
+
+// CHECK-PATHS: KLEE: done: completed paths = 2
+// CHECK-RECOVERY: KLEE: done: recovery states = 3
+// CHECK-SLICES: KLEE: done: generated slices = 2
+// CHECK-SNAPSHOTS: KLEE: done: created snapshots = 2
+
+// CHECK-X: x is 987421
+// CHECK-Y: y is 1974843
+// CHECK-OTHER: other branch
+
+#include <stdio.h>
+#include <assert.h>
+#include <klee/klee.h>
+
+typedef struct {
+    int x;
+    int y;
+    int z;
+} point;
+
+void f(point *o, int *k) {
+	if (*k == 123)
+		o->x++;
+	else
+		o->x = 987421;
+}
+
+void g(point *o) {
+	o->y = o->x * 2 + 1;
+}
+
+int main(int argc, char *argv[], char *envp[]) {
+    point o;
+    o.x = 1; o.y = 0; o.z = 0;
+    int k;
+
+    klee_make_symbolic(&k, sizeof(k), "k");
+
+    f(&o, &k);
+	g(&o);
+    if (k == 3) {
+    	printf("y is %d\n", o.y);
+    	printf("x is %d\n", o.x);
+    	if (o.x == 2) {
+    		assert(0);
+    	}
+    } else {
+    	printf("other branch\n");
+    }
+
+    return 0;
+}
diff --git a/test/lit.cfg b/test/lit.cfg
index 3155288..ca8f794 100644
--- a/test/lit.cfg
+++ b/test/lit.cfg
@@ -76,7 +76,7 @@ if config.test_exec_root is None:
 
 
 # Add substitutions from lit.site.cfg
-subs = [ 'llvmgcc', 'llvmgxx', 'cc', 'cxx']
+subs = [ 'llvmgcc', 'llvmgxx', 'cc', 'cxx', 'opt']
 for name in subs:
     value = getattr(config, name, None)
     if value == None:
diff --git a/test/lit.site.cfg.in b/test/lit.site.cfg.in
index e53b132..01efebf 100644
--- a/test/lit.site.cfg.in
+++ b/test/lit.site.cfg.in
@@ -13,6 +13,7 @@ config.llvm_version_minor = "@LLVM_VERSION_MINOR@"
 # FIXME: use llvmcc not llvmgcc
 config.llvmgcc = "@LLVMCC@"
 config.llvmgxx = "@LLVMCXX@"
+config.opt = "@LLVM_TOOLS_DIR@/opt"
 
 config.cc = "@NATIVE_CC@"
 config.cxx = "@NATIVE_CXX@"
diff --git a/tools/klee/CMakeLists.txt b/tools/klee/CMakeLists.txt
index 8b05c35..681a9cf 100644
--- a/tools/klee/CMakeLists.txt
+++ b/tools/klee/CMakeLists.txt
@@ -14,7 +14,22 @@ set(KLEE_LIBS
   kleeCore
 )
 
-target_link_libraries(klee ${KLEE_LIBS})
+find_library(SVF_LIB Svf.so HINTS ${SVF_ROOT_DIR}/build/lib)
+find_library(CUDD_LIB Cudd.so HINTS ${SVF_ROOT_DIR}/build/lib/CUDD)
+find_library(LLVMDG_LIB LLVMdg HINTS ${DG_ROOT_DIR}/build/src)
+find_library(LLVMPTA_LIB LLVMpta HINTS ${DG_ROOT_DIR}/build/src)
+find_library(PTA_LIB PTA HINTS ${DG_ROOT_DIR}/build/src)
+find_library(RD_LIB RD HINTS ${DG_ROOT_DIR}/build/src)
+
+target_link_libraries(klee
+    ${SVF_LIB}
+    ${CUDD_LIB}
+    ${LLVMDG_LIB}
+    ${LLVMPTA_LIB}
+    ${PTA_LIB}
+    ${RD_LIB}
+    ${KLEE_LIBS}
+)
 
 install(TARGETS klee RUNTIME DESTINATION bin)
 
diff --git a/tools/klee/main.cpp b/tools/klee/main.cpp
index e95522a..473c376 100644
--- a/tools/klee/main.cpp
+++ b/tools/klee/main.cpp
@@ -79,10 +79,30 @@ namespace {
   cl::opt<std::string>
   InputFile(cl::desc("<input bytecode>"), cl::Positional, cl::init("-"));
 
+  cl::opt<std::string> SkippedFunctions(
+      "skip-functions",
+      cl::desc("Comma-separated list of functions to skip. "
+               "Optionally, a line number can be specified to choose a specific call site "
+               "(e.g. <function1>[:line],<function2>[:line],..)"));
+
+  cl::opt<std::string>
+  InlinedFunctions("inline",
+                   cl::desc("Comma-separated list of functions to be inlined (e.g. <function1>,<function2>,..)"),
+                   cl::init(""));
+
+  cl::opt<unsigned int>
+  MaxErrorCount("max-error-count",
+                cl::desc("max error count before exit"),
+                cl::init(0));
+
+  cl::opt<std::string>
+  ErrorLocation("error-location",
+                cl::desc("Comma-separated list of locations where a failure is expected (e.g. <file1>[:line],<file2>[:line],..)"));
+
   cl::opt<std::string>
   EntryPoint("entry-point",
-               cl::desc("Consider the function with the given name as the entrypoint"),
-               cl::init("main"));
+             cl::desc("Consider the function with the given name as the entrypoint"),
+             cl::init("main"));
 
   cl::opt<std::string>
   RunInDir("run-in", cl::desc("Change to the given directory prior to executing"));
@@ -154,6 +174,11 @@ namespace {
 		cl::desc("Link with POSIX runtime.  Options that can be passed as arguments to the programs are: --sym-arg <max-len>  --sym-args <min-argvs> <max-argvs> <max-len> + file model options"),
 		cl::init(false));
 
+  cl::opt<bool>
+  WithSymArgsRuntime("sym-arg-runtime",
+		cl::desc("Options that can be passed as arguments to the programs are: --sym-arg <max-len>  --sym-args <min-argvs> <max-argvs> <max-len>"),
+		cl::init(false));
+
   cl::opt<bool>
   OptimizeModule("optimize",
                  cl::desc("Optimize before execution"),
@@ -237,6 +262,9 @@ private:
 
   unsigned m_testIndex;  // number of tests written so far
   unsigned m_pathsExplored; // number of paths explored so far
+  unsigned m_recoveryStatesCount; // number of recovery states
+  unsigned m_generatedSlicesCount; // number of generated slices
+  unsigned m_snapshotsCount; // number of created snapshots
 
   // used for writing .ktest files
   int m_argc;
@@ -251,6 +279,30 @@ public:
   unsigned getNumPathsExplored() { return m_pathsExplored; }
   void incPathsExplored() { m_pathsExplored++; }
 
+  unsigned getRecoveryStatesCount() {
+    return m_recoveryStatesCount;
+  }
+
+  void incRecoveryStatesCount() {
+    m_recoveryStatesCount++;
+  }
+
+  unsigned getGeneratedSlicesCount() {
+    return m_generatedSlicesCount;
+  }
+
+  void incGeneratedSlicesCount() {
+    m_generatedSlicesCount++;
+  }
+
+  unsigned getSnapshotsCount() {
+    return m_snapshotsCount;
+  }
+
+  void incSnapshotsCount() {
+    m_snapshotsCount++;
+  }
+
   void setInterpreter(Interpreter *i);
 
   void processTestCase(const ExecutionState  &state,
@@ -280,6 +332,9 @@ KleeHandler::KleeHandler(int argc, char **argv)
     m_outputDirectory(),
     m_testIndex(0),
     m_pathsExplored(0),
+    m_recoveryStatesCount(0),
+    m_generatedSlicesCount(0),
+    m_snapshotsCount(0),
     m_argc(argc),
     m_argv(argv) {
 
@@ -691,12 +746,22 @@ static int initEnv(Module *mainModule) {
   std::vector<const Type*> params;
   params.push_back(Type::getInt32Ty(getGlobalContext()));
   params.push_back(Type::getInt32Ty(getGlobalContext()));
-  Function* initEnvFn =
+
+  Function* initEnvFn = NULL;
+  if (WithPOSIXRuntime)
+  initEnvFn =
     cast<Function>(mainModule->getOrInsertFunction("klee_init_env",
                                                    Type::getVoidTy(getGlobalContext()),
                                                    argcPtr->getType(),
                                                    argvPtr->getType(),
                                                    NULL));
+  if (WithSymArgsRuntime)
+	  initEnvFn =
+	    cast<Function>(mainModule->getOrInsertFunction("klee_init_args",
+	                                                   Type::getVoidTy(getGlobalContext()),
+	                                                   argcPtr->getType(),
+	                                                   argvPtr->getType(),
+	                                                   NULL));
   assert(initEnvFn);
   std::vector<Value*> args;
   args.push_back(argcPtr);
@@ -1158,6 +1223,88 @@ static llvm::Module *linkWithUclibc(llvm::Module *mainModule, StringRef libDir)
 }
 #endif
 
+bool parseNameLineOption(
+    std::string option,
+    std::string &fname,
+    std::vector<unsigned int> &lines
+) {
+    std::istringstream stream(option);
+    std::string token;
+    char *endptr;
+
+    if (std::getline(stream, token, ':')) {
+        fname = token;
+        while (std::getline(stream, token, '/')) {
+            /* TODO: handle errors */
+            const char *s = token.c_str();
+            unsigned int line = strtol(s, &endptr, 10);
+            if ((errno == ERANGE) || (endptr == s) || (*endptr != '\0')) {
+                return false;
+            }
+            lines.push_back(line);
+        }
+    }
+
+    return true;
+}
+
+void parseSkippingParameter(
+    Module *module,
+    std::string parameter,
+    std::vector<Interpreter::SkippedFunctionOption> &result
+) {
+    std::istringstream stream(parameter);
+    std::string token;
+    std::string fname;
+
+    while (std::getline(stream, token, ',')) {
+        std::vector<unsigned int> lines;
+        if (!parseNameLineOption(token, fname, lines)) {
+            klee_error("skip-function option: invalid parameter: %s", token.c_str());
+        }
+        Function *f = module->getFunction(fname);
+		if (!f) {
+          klee_error("skip-function option: '%s' not found in module.", fname.c_str());
+        }
+
+		if (!f->getReturnType()->isVoidTy()) {
+		  fname = std::string("__wrap_") + fname;
+		}
+        result.push_back(Interpreter::SkippedFunctionOption(fname, lines));
+    }
+}
+
+void parseInlinedFunctions(
+    Module *module,
+    std::string parameter,
+    std::vector<std::string> &result
+) {
+    std::istringstream stream(parameter);
+    std::string fname;
+
+    while (std::getline(stream, fname, ',')) {
+        if (!module->getFunction(fname)) {
+          klee_error("inline option: '%s' not found in module.", fname.c_str());
+        }
+
+        result.push_back(fname);
+    }
+}
+
+void parseErrorLocationParameter(std::string parameter, std::map<std::string, std::vector<unsigned> > &result) {
+    std::istringstream stream(parameter);
+    std::string token;
+    std::string fname;
+
+    while (std::getline(stream, token, ',')) {
+        std::vector<unsigned int> lines;
+        if (!parseNameLineOption(token, fname, lines)) {
+            klee_error("error-location option: invalid parameter: %s", token.c_str());
+        }
+        result.insert(std::pair<std::string, std::vector<unsigned> >(fname, lines));
+    }
+}
+
 int main(int argc, char **argv, char **envp) {
   atexit(llvm_shutdown);  // Call llvm_shutdown() on exit.
 
@@ -1281,7 +1428,7 @@ int main(int argc, char **argv, char **envp) {
   }
 #endif
 
-  if (WithPOSIXRuntime) {
+  if (WithPOSIXRuntime || WithSymArgsRuntime) {
     int r = initEnv(mainModule);
     if (r != 0)
       return r;
@@ -1338,6 +1485,15 @@ int main(int argc, char **argv, char **envp) {
     klee_error("'%s' function not found in module.", EntryPoint.c_str());
   }
 
+  std::vector<Interpreter::SkippedFunctionOption> skippingOptions;
+  parseSkippingParameter(mainModule, SkippedFunctions, skippingOptions);
+
+  std::vector<std::string> inlinedFunctions;
+  parseInlinedFunctions(mainModule, InlinedFunctions, inlinedFunctions);
+
+  std::map<std::string, std::vector<unsigned> > errorLocationOptions;
+  parseErrorLocationParameter(ErrorLocation, errorLocationOptions);
+
   // FIXME: Change me to std types.
   int pArgc;
   char **pArgv;
@@ -1385,6 +1541,10 @@ int main(int argc, char **argv, char **envp) {
 
   Interpreter::InterpreterOptions IOpts;
   IOpts.MakeConcreteSymbolic = MakeConcreteSymbolic;
+  IOpts.skippedFunctions = skippingOptions;
+  IOpts.inlinedFunctions = inlinedFunctions;
+  IOpts.errorLocations = errorLocationOptions;
+  IOpts.maxErrorCount = MaxErrorCount;
   KleeHandler *handler = new KleeHandler(pArgc, pArgv);
   Interpreter *interpreter =
     theInterpreter = Interpreter::create(IOpts, handler);
@@ -1488,7 +1648,7 @@ int main(int argc, char **argv, char **envp) {
     }
 
     if (!seeds.empty()) {
-      klee_message("KLEE: using %lu seeds\n", seeds.size());
+      klee_message("KLEE: using %zu seeds\n", seeds.size());
       interpreter->useSeeds(&seeds);
     }
     if (RunInDir != "") {
@@ -1560,6 +1720,16 @@ int main(int argc, char **argv, char **envp) {
   stats << "KLEE: done: generated tests = "
         << handler->getNumTestCases() << "\n";
 
+  /* these are relevant only when we have a slicing option */
+  if (!IOpts.skippedFunctions.empty()) {
+    stats << "KLEE: done: recovery states = "
+          << handler->getRecoveryStatesCount() << "\n";
+    stats << "KLEE: done: generated slices = "
+          << handler->getGeneratedSlicesCount() << "\n";
+    stats << "KLEE: done: created snapshots = "
+          << handler->getSnapshotsCount() << "\n";
+  }
+
   bool useColors = llvm::errs().is_displayed();
   if (useColors)
     llvm::errs().changeColor(llvm::raw_ostream::GREEN,
diff --git a/tools/ktest-tool/ktest-tool b/tools/ktest-tool/ktest-tool
index b73c637..b77a16a 100755
--- a/tools/ktest-tool/ktest-tool
+++ b/tools/ktest-tool/ktest-tool
@@ -91,6 +91,7 @@ def main(args):
     op.add_option('','--write-ints', dest='writeInts', action='store_true',
                   default=False,
                   help='convert 4-byte sequences to integers')
+    op.add_option('-d','--dump-file', dest='dump_file')
     
     opts,args = op.parse_args()
     if not args:
@@ -113,6 +114,8 @@ def main(args):
             if opts.writeInts and len(data) == 4: 
                 print('object %4d: data: %r' % (i, struct.unpack('i',str)[0]))
             else:
+                if opts.dump_file is not None:
+                    open(opts.dump_file, "w+").write(str)
                 print('object %4d: data: %r' % (i, str))
         if file != args[-1]:
             print()
