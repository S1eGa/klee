diff a/lib/Module/KModule.cpp b/lib/Module/KModule.cpp	(rejected hunks)
@@ -56,6 +56,13 @@
 
 #include <llvm/Transforms/Utils/Cloning.h>
 
+#include "klee/Internal/Analysis/ReachabilityAnalysis.h"
+#include "klee/Internal/Analysis/Inliner.h"
+#include "klee/Internal/Analysis/AAPass.h"
+#include "klee/Internal/Analysis/ModRefAnalysis.h"
+#include "klee/Internal/Analysis/Cloner.h"
+#include "klee/Internal/Analysis/SliceGenerator.h"
+
 #include <sstream>
 
 using namespace llvm;
@@ -99,6 +106,11 @@ namespace {
   cl::opt<bool>
   DebugPrintEscapingFunctions("debug-print-escaping-functions", 
                               cl::desc("Print functions whose address is taken."));
+
+  cl::opt<bool>
+  UseSVFPTA("use-svf-analysis",
+            cl::desc("Use SVF pointer analysis for reachability analysis (default=on)"),
+            cl::init(true));
 }
 
 KModule::KModule(Module *_module) 
@@ -109,12 +121,10 @@ KModule::KModule(Module *_module)
     targetData(new DataLayout(module)),
 #endif
     kleeMergeFn(0),
-    infos(0),
-    constantTable(0) {
+    infos(0) {
 }
 
 KModule::~KModule() {
-  delete[] constantTable;
   delete infos;
 
   for (std::vector<KFunction*>::iterator it = functions.begin(), 
@@ -240,7 +250,14 @@ void KModule::addInternalFunction(const char* functionName){
 }
 
 void KModule::prepare(const Interpreter::ModuleOptions &opts,
-                      InterpreterHandler *ih) {
+		              const std::vector<Interpreter::SkippedFunctionOption> &skippedFunctions,
+                      InterpreterHandler *ih,
+                      ReachabilityAnalysis *ra,
+                      Inliner *inliner,
+                      AAPass *aa,
+                      ModRefAnalysis *mra,
+                      Cloner *cloner,
+                      SliceGenerator *sliceGenerator) {
   if (!MergeAtExit.empty()) {
     Function *mergeFn = module->getFunction("klee_merge");
     if (!mergeFn) {
@@ -297,6 +314,7 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
   // optimize is seeing what is as close as possible to the final
   // module.
   PassManager pm;
+  pm.add(new ReturnToVoidFunctionPass(skippedFunctions));
   pm.add(new RaiseAsmPass());
   if (opts.CheckDivZero) pm.add(new DivCheckPass());
   if (opts.CheckOvershift) pm.add(new OvershiftCheckPass());
@@ -433,24 +451,68 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
 
   kleeMergeFn = module->getFunction("klee_merge");
 
+  if (!skippedFunctions.empty()) {
+    /* prepare reachability analysis */
+    ra->prepare();
+
+    /* first, we need to do the inlining... */
+    inliner->run();
+
+    /* run pointer analysis */
+    klee_message("Runnining pointer analysis...");
+    PassManager passManager;
+    passManager.add(aa);
+    passManager.run(*module);
+
+    /* run reachability analysis */
+    klee_message("Runnining reachability analysis...");
+    ra->usePA(aa);
+    ra->run(UseSVFPTA);
+
+    /* run mod-ref analysis */
+    klee_message("Runnining mod-ref analysis...");
+    mra->run();
+
+    if (sliceGenerator) {
+      /* TODO: rename... */
+      sliceGenerator->generate();
+    }
+  }
+
   /* Build shadow structures */
 
-  infos = new InstructionInfoTable(module);  
+  infos = new InstructionInfoTable(module, !skippedFunctions.empty(), cloner);
   
   for (Module::iterator it = module->begin(), ie = module->end();
        it != ie; ++it) {
-    if (it->isDeclaration())
+    Function *f = it;
+    if (f->isDeclaration()) {
       continue;
+    }
 
-    KFunction *kf = new KFunction(it, this);
-    
-    for (unsigned i=0; i<kf->numInstructions; ++i) {
-      KInstruction *ki = kf->instructions[i];
-      ki->info = &infos->getInfo(ki->inst);
+    std::set<KFunction *> pool;
+    pool.insert(new KFunction(f, this));
+
+    if (!skippedFunctions.empty()) {
+      Cloner::SliceMap *sliceMap = cloner->getSlices(f);
+      if (sliceMap != 0) {
+        for (Cloner::SliceMap::iterator s = sliceMap->begin(); s != sliceMap->end(); s++ ) {
+          Cloner::SliceInfo &sliceInfo = s->second;
+          if (!sliceInfo.isSliced) {
+              /* don't add a cloned function which was not sliced */
+              continue;
+          }
+
+          KFunction *kcloned = new KFunction(sliceInfo.f, this);
+          kcloned->isCloned = true;
+          pool.insert(kcloned);
+        }
+      }
     }
 
-    functions.push_back(kf);
-    functionMap.insert(std::make_pair(it, kf));
+    for (std::set<KFunction *>::iterator kfi = pool.begin(); kfi != pool.end(); kfi++) {
+      addFunction(*kfi, !skippedFunctions.empty(), cloner, mra);
+    }
   }
 
   /* Compute various interesting properties */
@@ -472,6 +534,39 @@ void KModule::prepare(const Interpreter::ModuleOptions &opts,
   }
 }
 
+void KModule::addFunction(KFunction *kf, bool isSkippingFunctions, Cloner *cloner, ModRefAnalysis *mra) {
+    for (unsigned i=0; i<kf->numInstructions; ++i) {
+        KInstruction *ki = kf->instructions[i];
+        ki->info = &infos->getInfo(ki->inst);
+        ki->isCloned = kf->isCloned;
+        ki->origInst = NULL;
+        ki->mayBlock = false;
+        ki->mayOverride = false;
+
+        if (!isSkippingFunctions) {
+            continue;
+        }
+
+        if (kf->isCloned) {
+            Value *origValue = cloner->translateValue(ki->inst);
+            if (origValue) {
+                /* TODO: some instructions can't be translated (RET, ...) */
+                ki->origInst = dyn_cast<llvm::Instruction>(origValue);
+            }
+        }
+
+        if (ki->inst->getOpcode() == Instruction::Load) {
+            ki->mayBlock = mra->mayBlock(ki->getOrigInst());
+        }
+        if (ki->inst->getOpcode() == Instruction::Store) {
+            ki->mayOverride = mra->mayOverride(ki->getOrigInst());
+        }
+    }
+
+    functions.push_back(kf);
+    functionMap.insert(std::make_pair(kf->function, kf));
+}
+
 KConstant* KModule::getKConstant(Constant *c) {
   std::map<llvm::Constant*, KConstant*>::iterator it = constantMap.find(c);
   if (it != constantMap.end())
@@ -488,6 +583,7 @@ unsigned KModule::getConstantID(Constant *c, KInstruction* ki) {
   kc = new KConstant(c, id, ki);
   constantMap.insert(std::make_pair(c, kc));
   constants.push_back(c);
+
   return id;
 }
 
@@ -524,7 +620,8 @@ KFunction::KFunction(llvm::Function *_function,
   : function(_function),
     numArgs(function->arg_size()),
     numInstructions(0),
-    trackCoverage(true) {
+    trackCoverage(true),
+    isCloned(false) {
   for (llvm::Function::iterator bbit = function->begin(), 
          bbie = function->end(); bbit != bbie; ++bbit) {
     BasicBlock *bb = bbit;
