diff a/tools/klee/main.cpp b/tools/klee/main.cpp	(rejected hunks)
@@ -79,10 +79,30 @@ namespace {
   cl::opt<std::string>
   InputFile(cl::desc("<input bytecode>"), cl::Positional, cl::init("-"));
 
+  cl::opt<std::string> SkippedFunctions(
+      "skip-functions",
+      cl::desc("Comma-separated list of functions to skip. "
+               "Optionally, a line number can be specified to choose a specific call site "
+               "(e.g. <function1>[:line],<function2>[:line],..)"));
+
+  cl::opt<std::string>
+  InlinedFunctions("inline",
+                   cl::desc("Comma-separated list of functions to be inlined (e.g. <function1>,<function2>,..)"),
+                   cl::init(""));
+
+  cl::opt<unsigned int>
+  MaxErrorCount("max-error-count",
+                cl::desc("max error count before exit"),
+                cl::init(0));
+
+  cl::opt<std::string>
+  ErrorLocation("error-location",
+                cl::desc("Comma-separated list of locations where a failure is expected (e.g. <file1>[:line],<file2>[:line],..)"));
+
   cl::opt<std::string>
   EntryPoint("entry-point",
-               cl::desc("Consider the function with the given name as the entrypoint"),
-               cl::init("main"));
+             cl::desc("Consider the function with the given name as the entrypoint"),
+             cl::init("main"));
 
   cl::opt<std::string>
   RunInDir("run-in", cl::desc("Change to the given directory prior to executing"));
@@ -154,6 +174,11 @@ namespace {
 		cl::desc("Link with POSIX runtime.  Options that can be passed as arguments to the programs are: --sym-arg <max-len>  --sym-args <min-argvs> <max-argvs> <max-len> + file model options"),
 		cl::init(false));
 
+  cl::opt<bool>
+  WithSymArgsRuntime("sym-arg-runtime",
+		cl::desc("Options that can be passed as arguments to the programs are: --sym-arg <max-len>  --sym-args <min-argvs> <max-argvs> <max-len>"),
+		cl::init(false));
+
   cl::opt<bool>
   OptimizeModule("optimize",
                  cl::desc("Optimize before execution"),
@@ -237,6 +262,9 @@ private:
 
   unsigned m_testIndex;  // number of tests written so far
   unsigned m_pathsExplored; // number of paths explored so far
+  unsigned m_recoveryStatesCount; // number of recovery states
+  unsigned m_generatedSlicesCount; // number of generated slices
+  unsigned m_snapshotsCount; // number of created snapshots
 
   // used for writing .ktest files
   int m_argc;
@@ -251,6 +279,30 @@ public:
   unsigned getNumPathsExplored() { return m_pathsExplored; }
   void incPathsExplored() { m_pathsExplored++; }
 
+  unsigned getRecoveryStatesCount() {
+    return m_recoveryStatesCount;
+  }
+
+  void incRecoveryStatesCount() {
+    m_recoveryStatesCount++;
+  }
+
+  unsigned getGeneratedSlicesCount() {
+    return m_generatedSlicesCount;
+  }
+
+  void incGeneratedSlicesCount() {
+    m_generatedSlicesCount++;
+  }
+
+  unsigned getSnapshotsCount() {
+    return m_snapshotsCount;
+  }
+
+  void incSnapshotsCount() {
+    m_snapshotsCount++;
+  }
+
   void setInterpreter(Interpreter *i);
 
   void processTestCase(const ExecutionState  &state,
@@ -280,6 +332,9 @@ KleeHandler::KleeHandler(int argc, char **argv)
     m_outputDirectory(),
     m_testIndex(0),
     m_pathsExplored(0),
+    m_recoveryStatesCount(0),
+    m_generatedSlicesCount(0),
+    m_snapshotsCount(0),
     m_argc(argc),
     m_argv(argv) {
 
@@ -691,12 +746,22 @@ static int initEnv(Module *mainModule) {
   std::vector<const Type*> params;
   params.push_back(Type::getInt32Ty(getGlobalContext()));
   params.push_back(Type::getInt32Ty(getGlobalContext()));
-  Function* initEnvFn =
+
+  Function* initEnvFn = NULL;
+  if (WithPOSIXRuntime)
+  initEnvFn =
     cast<Function>(mainModule->getOrInsertFunction("klee_init_env",
                                                    Type::getVoidTy(getGlobalContext()),
                                                    argcPtr->getType(),
                                                    argvPtr->getType(),
                                                    NULL));
+  if (WithSymArgsRuntime)
+	  initEnvFn =
+	    cast<Function>(mainModule->getOrInsertFunction("klee_init_args",
+	                                                   Type::getVoidTy(getGlobalContext()),
+	                                                   argcPtr->getType(),
+	                                                   argvPtr->getType(),
+	                                                   NULL));
   assert(initEnvFn);
   std::vector<Value*> args;
   args.push_back(argcPtr);
@@ -1158,6 +1223,88 @@ static llvm::Module *linkWithUclibc(llvm::Module *mainModule, StringRef libDir)
 }
 #endif
 
+bool parseNameLineOption(
+    std::string option,
+    std::string &fname,
+    std::vector<unsigned int> &lines
+) {
+    std::istringstream stream(option);
+    std::string token;
+    char *endptr;
+
+    if (std::getline(stream, token, ':')) {
+        fname = token;
+        while (std::getline(stream, token, '/')) {
+            /* TODO: handle errors */
+            const char *s = token.c_str();
+            unsigned int line = strtol(s, &endptr, 10);
+            if ((errno == ERANGE) || (endptr == s) || (*endptr != '\0')) {
+                return false;
+            }
+            lines.push_back(line);
+        }
+    }
+
+    return true;
+}
+
+void parseSkippingParameter(
+    Module *module,
+    std::string parameter,
+    std::vector<Interpreter::SkippedFunctionOption> &result
+) {
+    std::istringstream stream(parameter);
+    std::string token;
+    std::string fname;
+
+    while (std::getline(stream, token, ',')) {
+        std::vector<unsigned int> lines;
+        if (!parseNameLineOption(token, fname, lines)) {
+            klee_error("skip-function option: invalid parameter: %s", token.c_str());
+        }
+        Function *f = module->getFunction(fname);
+		if (!f) {
+          klee_error("skip-function option: '%s' not found in module.", fname.c_str());
+        }
+
+		if (!f->getReturnType()->isVoidTy()) {
+		  fname = std::string("__wrap_") + fname;
+		}
+        result.push_back(Interpreter::SkippedFunctionOption(fname, lines));
+    }
+}
+
+void parseInlinedFunctions(
+    Module *module,
+    std::string parameter,
+    std::vector<std::string> &result
+) {
+    std::istringstream stream(parameter);
+    std::string fname;
+
+    while (std::getline(stream, fname, ',')) {
+        if (!module->getFunction(fname)) {
+          klee_error("inline option: '%s' not found in module.", fname.c_str());
+        }
+
+        result.push_back(fname);
+    }
+}
+
+void parseErrorLocationParameter(std::string parameter, std::map<std::string, std::vector<unsigned> > &result) {
+    std::istringstream stream(parameter);
+    std::string token;
+    std::string fname;
+
+    while (std::getline(stream, token, ',')) {
+        std::vector<unsigned int> lines;
+        if (!parseNameLineOption(token, fname, lines)) {
+            klee_error("error-location option: invalid parameter: %s", token.c_str());
+        }
+        result.insert(std::pair<std::string, std::vector<unsigned> >(fname, lines));
+    }
+}
+
 int main(int argc, char **argv, char **envp) {
   atexit(llvm_shutdown);  // Call llvm_shutdown() on exit.
 
@@ -1281,7 +1428,7 @@ int main(int argc, char **argv, char **envp) {
   }
 #endif
 
-  if (WithPOSIXRuntime) {
+  if (WithPOSIXRuntime || WithSymArgsRuntime) {
     int r = initEnv(mainModule);
     if (r != 0)
       return r;
@@ -1338,6 +1485,15 @@ int main(int argc, char **argv, char **envp) {
     klee_error("'%s' function not found in module.", EntryPoint.c_str());
   }
 
+  std::vector<Interpreter::SkippedFunctionOption> skippingOptions;
+  parseSkippingParameter(mainModule, SkippedFunctions, skippingOptions);
+
+  std::vector<std::string> inlinedFunctions;
+  parseInlinedFunctions(mainModule, InlinedFunctions, inlinedFunctions);
+
+  std::map<std::string, std::vector<unsigned> > errorLocationOptions;
+  parseErrorLocationParameter(ErrorLocation, errorLocationOptions);
+
   // FIXME: Change me to std types.
   int pArgc;
   char **pArgv;
@@ -1385,6 +1541,10 @@ int main(int argc, char **argv, char **envp) {
 
   Interpreter::InterpreterOptions IOpts;
   IOpts.MakeConcreteSymbolic = MakeConcreteSymbolic;
+  IOpts.skippedFunctions = skippingOptions;
+  IOpts.inlinedFunctions = inlinedFunctions;
+  IOpts.errorLocations = errorLocationOptions;
+  IOpts.maxErrorCount = MaxErrorCount;
   KleeHandler *handler = new KleeHandler(pArgc, pArgv);
   Interpreter *interpreter =
     theInterpreter = Interpreter::create(IOpts, handler);
@@ -1560,6 +1720,16 @@ int main(int argc, char **argv, char **envp) {
   stats << "KLEE: done: generated tests = "
         << handler->getNumTestCases() << "\n";
 
+  /* these are relevant only when we have a slicing option */
+  if (!IOpts.skippedFunctions.empty()) {
+    stats << "KLEE: done: recovery states = "
+          << handler->getRecoveryStatesCount() << "\n";
+    stats << "KLEE: done: generated slices = "
+          << handler->getGeneratedSlicesCount() << "\n";
+    stats << "KLEE: done: created snapshots = "
+          << handler->getSnapshotsCount() << "\n";
+  }
+
   bool useColors = llvm::errs().is_displayed();
   if (useColors)
     llvm::errs().changeColor(llvm::raw_ostream::GREEN,
